#include "__native_ced4bbd844d3a34b6fc2.h"
#include "__native_internal_ced4bbd844d3a34b6fc2.h"

static int
ops___BasicBlock_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___BasicBlock_setup(PyTypeObject *type);
PyObject *CPyDef_ops___BasicBlock(CPyTagged cpy_r_label);

static PyObject *
ops___BasicBlock_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___BasicBlock) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___BasicBlock_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___BasicBlock_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___BasicBlock_traverse(mypyc___ir___ops___BasicBlockObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_label)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_label));
    }
    Py_VISIT(self->_ops);
    Py_VISIT(self->_error_handler);
    return 0;
}

static int
ops___BasicBlock_clear(mypyc___ir___ops___BasicBlockObject *self)
{
    if (CPyTagged_CheckLong(self->_label)) {
        CPyTagged __tmp = self->_label;
        self->_label = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_ops);
    Py_CLEAR(self->_error_handler);
    return 0;
}

static void
ops___BasicBlock_dealloc(mypyc___ir___ops___BasicBlockObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___BasicBlock_dealloc)
    ops___BasicBlock_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___BasicBlock_vtable[3];
static bool
CPyDef_ops___BasicBlock_trait_vtable_setup(void)
{
    CPyVTableItem ops___BasicBlock_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___BasicBlock_____init__,
        (CPyVTableItem)CPyDef_ops___BasicBlock___terminated,
        (CPyVTableItem)CPyDef_ops___BasicBlock___terminator,
    };
    memcpy(ops___BasicBlock_vtable, ops___BasicBlock_vtable_scratch, sizeof(ops___BasicBlock_vtable));
    return 1;
}

static PyObject *
ops___BasicBlock_get_label(mypyc___ir___ops___BasicBlockObject *self, void *closure);
static int
ops___BasicBlock_set_label(mypyc___ir___ops___BasicBlockObject *self, PyObject *value, void *closure);
static PyObject *
ops___BasicBlock_get_ops(mypyc___ir___ops___BasicBlockObject *self, void *closure);
static int
ops___BasicBlock_set_ops(mypyc___ir___ops___BasicBlockObject *self, PyObject *value, void *closure);
static PyObject *
ops___BasicBlock_get_error_handler(mypyc___ir___ops___BasicBlockObject *self, void *closure);
static int
ops___BasicBlock_set_error_handler(mypyc___ir___ops___BasicBlockObject *self, PyObject *value, void *closure);
static PyObject *
ops___BasicBlock_get_referenced(mypyc___ir___ops___BasicBlockObject *self, void *closure);
static int
ops___BasicBlock_set_referenced(mypyc___ir___ops___BasicBlockObject *self, PyObject *value, void *closure);
static PyObject *
ops___BasicBlock_get_terminated(mypyc___ir___ops___BasicBlockObject *self, void *closure);
static PyObject *
ops___BasicBlock_get_terminator(mypyc___ir___ops___BasicBlockObject *self, void *closure);

static PyGetSetDef ops___BasicBlock_getseters[] = {
    {"label",
     (getter)ops___BasicBlock_get_label, (setter)ops___BasicBlock_set_label,
     NULL, NULL},
    {"ops",
     (getter)ops___BasicBlock_get_ops, (setter)ops___BasicBlock_set_ops,
     NULL, NULL},
    {"error_handler",
     (getter)ops___BasicBlock_get_error_handler, (setter)ops___BasicBlock_set_error_handler,
     NULL, NULL},
    {"referenced",
     (getter)ops___BasicBlock_get_referenced, (setter)ops___BasicBlock_set_referenced,
     NULL, NULL},
    {"terminated",
     (getter)ops___BasicBlock_get_terminated,
    NULL, NULL, NULL},
    {"terminator",
     (getter)ops___BasicBlock_get_terminator,
    NULL, NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___BasicBlock_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___BasicBlock_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___BasicBlock_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "BasicBlock",
    .tp_new = ops___BasicBlock_new,
    .tp_dealloc = (destructor)ops___BasicBlock_dealloc,
    .tp_traverse = (traverseproc)ops___BasicBlock_traverse,
    .tp_clear = (inquiry)ops___BasicBlock_clear,
    .tp_getset = ops___BasicBlock_getseters,
    .tp_methods = ops___BasicBlock_methods,
    .tp_init = ops___BasicBlock_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___BasicBlockObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___BasicBlock_template = &CPyType_ops___BasicBlock_template_;

static PyObject *
ops___BasicBlock_setup(PyTypeObject *type)
{
    mypyc___ir___ops___BasicBlockObject *self;
    self = (mypyc___ir___ops___BasicBlockObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___BasicBlock_vtable;
    self->_label = CPY_INT_TAG;
    self->_referenced = 2;
    return (PyObject *)self;
}

PyObject *CPyDef_ops___BasicBlock(CPyTagged cpy_r_label)
{
    PyObject *self = ops___BasicBlock_setup(CPyType_ops___BasicBlock);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___BasicBlock_____init__(self, cpy_r_label);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___BasicBlock_get_label(mypyc___ir___ops___BasicBlockObject *self, void *closure)
{
    if (unlikely(self->_label == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'label' of 'BasicBlock' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_label);
    PyObject *retval = CPyTagged_StealAsObject(self->_label);
    return retval;
}

static int
ops___BasicBlock_set_label(mypyc___ir___ops___BasicBlockObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'BasicBlock' object attribute 'label' cannot be deleted");
        return -1;
    }
    if (self->_label != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_label);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_label = tmp;
    return 0;
}

static PyObject *
ops___BasicBlock_get_ops(mypyc___ir___ops___BasicBlockObject *self, void *closure)
{
    if (unlikely(self->_ops == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'ops' of 'BasicBlock' undefined");
        return NULL;
    }
    CPy_INCREF(self->_ops);
    PyObject *retval = self->_ops;
    return retval;
}

static int
ops___BasicBlock_set_ops(mypyc___ir___ops___BasicBlockObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'BasicBlock' object attribute 'ops' cannot be deleted");
        return -1;
    }
    if (self->_ops != NULL) {
        CPy_DECREF(self->_ops);
    }
    PyObject *tmp;
    if (likely(PyList_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("list", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_ops = tmp;
    return 0;
}

static PyObject *
ops___BasicBlock_get_error_handler(mypyc___ir___ops___BasicBlockObject *self, void *closure)
{
    if (unlikely(self->_error_handler == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_handler' of 'BasicBlock' undefined");
        return NULL;
    }
    CPy_INCREF(self->_error_handler);
    PyObject *retval = self->_error_handler;
    return retval;
}

static int
ops___BasicBlock_set_error_handler(mypyc___ir___ops___BasicBlockObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'BasicBlock' object attribute 'error_handler' cannot be deleted");
        return -1;
    }
    if (self->_error_handler != NULL) {
        CPy_DECREF(self->_error_handler);
    }
    PyObject *tmp;
    if (Py_TYPE(value) == CPyType_ops___BasicBlock)
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9855;
    if (value == Py_None)
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9855;
    CPy_TypeError("mypyc.ir.ops.BasicBlock or None", value); 
    tmp = NULL;
__LL9855: ;
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_error_handler = tmp;
    return 0;
}

static PyObject *
ops___BasicBlock_get_referenced(mypyc___ir___ops___BasicBlockObject *self, void *closure)
{
    PyObject *retval = self->_referenced ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___BasicBlock_set_referenced(mypyc___ir___ops___BasicBlockObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'BasicBlock' object attribute 'referenced' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_referenced = tmp;
    return 0;
}

static PyObject *
ops___BasicBlock_get_terminated(mypyc___ir___ops___BasicBlockObject *self, void *closure)
{
    char retval = CPyDef_ops___BasicBlock___terminated((PyObject *) self);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
}

static PyObject *
ops___BasicBlock_get_terminator(mypyc___ir___ops___BasicBlockObject *self, void *closure)
{
    return CPyDef_ops___BasicBlock___terminator((PyObject *) self);
}

static PyObject *ops___Value_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Value(void);

static PyObject *
ops___Value_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Value) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    return ops___Value_setup(type);
}

static int
ops___Value_traverse(mypyc___ir___ops___ValueObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    return 0;
}

static int
ops___Value_clear(mypyc___ir___ops___ValueObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    return 0;
}

static void
ops___Value_dealloc(mypyc___ir___ops___ValueObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Value_dealloc)
    ops___Value_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Value_vtable[2];
static bool
CPyDef_ops___Value_trait_vtable_setup(void)
{
    CPyVTableItem ops___Value_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Value_____mypyc_defaults_setup,
    };
    memcpy(ops___Value_vtable, ops___Value_vtable_scratch, sizeof(ops___Value_vtable));
    return 1;
}

static PyObject *
ops___Value_get_line(mypyc___ir___ops___ValueObject *self, void *closure);
static int
ops___Value_set_line(mypyc___ir___ops___ValueObject *self, PyObject *value, void *closure);
static PyObject *
ops___Value_get_type(mypyc___ir___ops___ValueObject *self, void *closure);
static int
ops___Value_set_type(mypyc___ir___ops___ValueObject *self, PyObject *value, void *closure);
static PyObject *
ops___Value_get_is_borrowed(mypyc___ir___ops___ValueObject *self, void *closure);
static int
ops___Value_set_is_borrowed(mypyc___ir___ops___ValueObject *self, PyObject *value, void *closure);
static PyObject *
ops___Value_get_is_void(mypyc___ir___ops___ValueObject *self, void *closure);

static PyGetSetDef ops___Value_getseters[] = {
    {"line",
     (getter)ops___Value_get_line, (setter)ops___Value_set_line,
     NULL, NULL},
    {"type",
     (getter)ops___Value_get_type, (setter)ops___Value_set_type,
     NULL, NULL},
    {"is_borrowed",
     (getter)ops___Value_get_is_borrowed, (setter)ops___Value_set_is_borrowed,
     NULL, NULL},
    {"is_void",
     (getter)ops___Value_get_is_void,
    NULL, NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Value_methods[] = {
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Value_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Value_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Value",
    .tp_new = ops___Value_new,
    .tp_dealloc = (destructor)ops___Value_dealloc,
    .tp_traverse = (traverseproc)ops___Value_traverse,
    .tp_clear = (inquiry)ops___Value_clear,
    .tp_getset = ops___Value_getseters,
    .tp_methods = ops___Value_methods,
    .tp_basicsize = sizeof(mypyc___ir___ops___ValueObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Value_template = &CPyType_ops___Value_template_;

static PyObject *
ops___Value_setup(PyTypeObject *type)
{
    mypyc___ir___ops___ValueObject *self;
    self = (mypyc___ir___ops___ValueObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Value_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    if (CPyDef_ops___Value_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Value(void)
{
    PyObject *self = ops___Value_setup(CPyType_ops___Value);
    if (self == NULL)
        return NULL;
    return self;
}

static PyObject *
ops___Value_get_line(mypyc___ir___ops___ValueObject *self, void *closure)
{
    if (unlikely(self->_line == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'line' of 'Value' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_line);
    PyObject *retval = CPyTagged_StealAsObject(self->_line);
    return retval;
}

static int
ops___Value_set_line(mypyc___ir___ops___ValueObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Value' object attribute 'line' cannot be deleted");
        return -1;
    }
    if (self->_line != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_line);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_line = tmp;
    return 0;
}

static PyObject *
ops___Value_get_type(mypyc___ir___ops___ValueObject *self, void *closure)
{
    if (unlikely(self->_type == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'type' of 'Value' undefined");
        return NULL;
    }
    CPy_INCREF(self->_type);
    PyObject *retval = self->_type;
    return retval;
}

static int
ops___Value_set_type(mypyc___ir___ops___ValueObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Value' object attribute 'type' cannot be deleted");
        return -1;
    }
    if (self->_type != NULL) {
        CPy_DECREF(self->_type);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_rtypes___RType)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_type = tmp;
    return 0;
}

static PyObject *
ops___Value_get_is_borrowed(mypyc___ir___ops___ValueObject *self, void *closure)
{
    PyObject *retval = self->_is_borrowed ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___Value_set_is_borrowed(mypyc___ir___ops___ValueObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Value' object attribute 'is_borrowed' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_is_borrowed = tmp;
    return 0;
}

static PyObject *
ops___Value_get_is_void(mypyc___ir___ops___ValueObject *self, void *closure)
{
    char retval = CPyDef_ops___Value___is_void((PyObject *) self);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
}

static int
ops___Register_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Register_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Register(PyObject *cpy_r_type, PyObject *cpy_r_name, char cpy_r_is_arg, CPyTagged cpy_r_line);

static PyObject *
ops___Register_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Register) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Register_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Register_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Register_traverse(mypyc___ir___ops___RegisterObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    Py_VISIT(self->_name);
    return 0;
}

static int
ops___Register_clear(mypyc___ir___ops___RegisterObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    Py_CLEAR(self->_name);
    return 0;
}

static void
ops___Register_dealloc(mypyc___ir___ops___RegisterObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Register_dealloc)
    ops___Register_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Register_vtable[6];
static bool
CPyDef_ops___Register_trait_vtable_setup(void)
{
    CPyVTableItem ops___Register_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Register___is_void,
        (CPyVTableItem)CPyDef_ops___Register_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Register_____init__,
        (CPyVTableItem)CPyDef_ops___Register___is_void,
        (CPyVTableItem)CPyDef_ops___Register_____repr__,
        (CPyVTableItem)CPyDef_ops___Register_____mypyc_defaults_setup,
    };
    memcpy(ops___Register_vtable, ops___Register_vtable_scratch, sizeof(ops___Register_vtable));
    return 1;
}

static PyObject *
ops___Register_get_name(mypyc___ir___ops___RegisterObject *self, void *closure);
static int
ops___Register_set_name(mypyc___ir___ops___RegisterObject *self, PyObject *value, void *closure);
static PyObject *
ops___Register_get_is_arg(mypyc___ir___ops___RegisterObject *self, void *closure);
static int
ops___Register_set_is_arg(mypyc___ir___ops___RegisterObject *self, PyObject *value, void *closure);
static PyObject *
ops___Register_get_is_void(mypyc___ir___ops___RegisterObject *self, void *closure);

static PyGetSetDef ops___Register_getseters[] = {
    {"name",
     (getter)ops___Register_get_name, (setter)ops___Register_set_name,
     NULL, NULL},
    {"is_arg",
     (getter)ops___Register_get_is_arg, (setter)ops___Register_set_is_arg,
     NULL, NULL},
    {"is_void",
     (getter)ops___Register_get_is_void,
    NULL, NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Register_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Register_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__repr__",
     (PyCFunction)CPyPy_ops___Register_____repr__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Register_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Register_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Register",
    .tp_new = ops___Register_new,
    .tp_dealloc = (destructor)ops___Register_dealloc,
    .tp_traverse = (traverseproc)ops___Register_traverse,
    .tp_clear = (inquiry)ops___Register_clear,
    .tp_getset = ops___Register_getseters,
    .tp_methods = ops___Register_methods,
    .tp_init = ops___Register_init,
    .tp_repr = CPyDef_ops___Register_____repr__,
    .tp_basicsize = sizeof(mypyc___ir___ops___RegisterObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Register_template = &CPyType_ops___Register_template_;

static PyObject *
ops___Register_setup(PyTypeObject *type)
{
    mypyc___ir___ops___RegisterObject *self;
    self = (mypyc___ir___ops___RegisterObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Register_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_is_arg = 2;
    if (CPyDef_ops___Register_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Register(PyObject *cpy_r_type, PyObject *cpy_r_name, char cpy_r_is_arg, CPyTagged cpy_r_line)
{
    PyObject *self = ops___Register_setup(CPyType_ops___Register);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Register_____init__(self, cpy_r_type, cpy_r_name, cpy_r_is_arg, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Register_get_name(mypyc___ir___ops___RegisterObject *self, void *closure)
{
    if (unlikely(self->_name == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'name' of 'Register' undefined");
        return NULL;
    }
    CPy_INCREF(self->_name);
    PyObject *retval = self->_name;
    return retval;
}

static int
ops___Register_set_name(mypyc___ir___ops___RegisterObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Register' object attribute 'name' cannot be deleted");
        return -1;
    }
    if (self->_name != NULL) {
        CPy_DECREF(self->_name);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_name = tmp;
    return 0;
}

static PyObject *
ops___Register_get_is_arg(mypyc___ir___ops___RegisterObject *self, void *closure)
{
    PyObject *retval = self->_is_arg ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___Register_set_is_arg(mypyc___ir___ops___RegisterObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Register' object attribute 'is_arg' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_is_arg = tmp;
    return 0;
}

static PyObject *
ops___Register_get_is_void(mypyc___ir___ops___RegisterObject *self, void *closure)
{
    char retval = CPyDef_ops___Register___is_void((PyObject *) self);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
}

static int
ops___Integer_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Integer_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Integer(CPyTagged cpy_r_value, PyObject *cpy_r_rtype, CPyTagged cpy_r_line);

static PyObject *
ops___Integer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Integer) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Integer_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Integer_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Integer_traverse(mypyc___ir___ops___IntegerObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_value)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_value));
    }
    return 0;
}

static int
ops___Integer_clear(mypyc___ir___ops___IntegerObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_value)) {
        CPyTagged __tmp = self->_value;
        self->_value = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    return 0;
}

static void
ops___Integer_dealloc(mypyc___ir___ops___IntegerObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Integer_dealloc)
    ops___Integer_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Integer_vtable[5];
static bool
CPyDef_ops___Integer_trait_vtable_setup(void)
{
    CPyVTableItem ops___Integer_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Integer_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Integer_____init__,
        (CPyVTableItem)CPyDef_ops___Integer___numeric_value,
        (CPyVTableItem)CPyDef_ops___Integer_____mypyc_defaults_setup,
    };
    memcpy(ops___Integer_vtable, ops___Integer_vtable_scratch, sizeof(ops___Integer_vtable));
    return 1;
}

static PyObject *
ops___Integer_get_value(mypyc___ir___ops___IntegerObject *self, void *closure);
static int
ops___Integer_set_value(mypyc___ir___ops___IntegerObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Integer_getseters[] = {
    {"value",
     (getter)ops___Integer_get_value, (setter)ops___Integer_set_value,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Integer_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Integer_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"numeric_value",
     (PyCFunction)CPyPy_ops___Integer___numeric_value,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Integer_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Integer_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Integer",
    .tp_new = ops___Integer_new,
    .tp_dealloc = (destructor)ops___Integer_dealloc,
    .tp_traverse = (traverseproc)ops___Integer_traverse,
    .tp_clear = (inquiry)ops___Integer_clear,
    .tp_getset = ops___Integer_getseters,
    .tp_methods = ops___Integer_methods,
    .tp_init = ops___Integer_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___IntegerObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Integer_template = &CPyType_ops___Integer_template_;

static PyObject *
ops___Integer_setup(PyTypeObject *type)
{
    mypyc___ir___ops___IntegerObject *self;
    self = (mypyc___ir___ops___IntegerObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Integer_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_value = CPY_INT_TAG;
    if (CPyDef_ops___Integer_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Integer(CPyTagged cpy_r_value, PyObject *cpy_r_rtype, CPyTagged cpy_r_line)
{
    PyObject *self = ops___Integer_setup(CPyType_ops___Integer);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Integer_____init__(self, cpy_r_value, cpy_r_rtype, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Integer_get_value(mypyc___ir___ops___IntegerObject *self, void *closure)
{
    if (unlikely(self->_value == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'value' of 'Integer' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_value);
    PyObject *retval = CPyTagged_StealAsObject(self->_value);
    return retval;
}

static int
ops___Integer_set_value(mypyc___ir___ops___IntegerObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Integer' object attribute 'value' cannot be deleted");
        return -1;
    }
    if (self->_value != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_value);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_value = tmp;
    return 0;
}

static int
ops___Float_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Float_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Float(double cpy_r_value, CPyTagged cpy_r_line);

static PyObject *
ops___Float_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Float) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Float_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Float_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Float_traverse(mypyc___ir___ops___FloatObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    return 0;
}

static int
ops___Float_clear(mypyc___ir___ops___FloatObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    return 0;
}

static void
ops___Float_dealloc(mypyc___ir___ops___FloatObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Float_dealloc)
    ops___Float_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Float_vtable[4];
static bool
CPyDef_ops___Float_trait_vtable_setup(void)
{
    CPyVTableItem ops___Float_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Float_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Float_____init__,
        (CPyVTableItem)CPyDef_ops___Float_____mypyc_defaults_setup,
    };
    memcpy(ops___Float_vtable, ops___Float_vtable_scratch, sizeof(ops___Float_vtable));
    return 1;
}

static PyObject *
ops___Float_get_value(mypyc___ir___ops___FloatObject *self, void *closure);
static int
ops___Float_set_value(mypyc___ir___ops___FloatObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Float_getseters[] = {
    {"value",
     (getter)ops___Float_get_value, (setter)ops___Float_set_value,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Float_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Float_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Float_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Float_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Float",
    .tp_new = ops___Float_new,
    .tp_dealloc = (destructor)ops___Float_dealloc,
    .tp_traverse = (traverseproc)ops___Float_traverse,
    .tp_clear = (inquiry)ops___Float_clear,
    .tp_getset = ops___Float_getseters,
    .tp_methods = ops___Float_methods,
    .tp_init = ops___Float_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___FloatObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Float_template = &CPyType_ops___Float_template_;

static PyObject *
ops___Float_setup(PyTypeObject *type)
{
    mypyc___ir___ops___FloatObject *self;
    self = (mypyc___ir___ops___FloatObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Float_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_value = -113.0;
    if (CPyDef_ops___Float_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Float(double cpy_r_value, CPyTagged cpy_r_line)
{
    PyObject *self = ops___Float_setup(CPyType_ops___Float);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Float_____init__(self, cpy_r_value, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Float_get_value(mypyc___ir___ops___FloatObject *self, void *closure)
{
    PyObject *retval = PyFloat_FromDouble(self->_value);
    return retval;
}

static int
ops___Float_set_value(mypyc___ir___ops___FloatObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Float' object attribute 'value' cannot be deleted");
        return -1;
    }
    double tmp;
    tmp = PyFloat_AsDouble(value);
    if (tmp == -1.0 && PyErr_Occurred()) {
        CPy_TypeError("float", value); return -1;
    }
    self->_value = tmp;
    return 0;
}

static int
ops___Op_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Op_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Op(CPyTagged cpy_r_line);

static PyObject *
ops___Op_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Op) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Op_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Op_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Op_traverse(mypyc___ir___ops___OpObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    return 0;
}

static int
ops___Op_clear(mypyc___ir___ops___OpObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    return 0;
}

static void
ops___Op_dealloc(mypyc___ir___ops___OpObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Op_dealloc)
    ops___Op_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Op_vtable[9];
static bool
CPyDef_ops___Op_trait_vtable_setup(void)
{
    CPyVTableItem ops___Op_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Op_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Op_____init__,
        (CPyVTableItem)CPyDef_ops___Op___can_raise,
        (CPyVTableItem)CPyDef_ops___Op___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Op___accept,
        (CPyVTableItem)CPyDef_ops___Op_____mypyc_defaults_setup,
    };
    memcpy(ops___Op_vtable, ops___Op_vtable_scratch, sizeof(ops___Op_vtable));
    return 1;
}


static PyGetSetDef ops___Op_getseters[] = {
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Op_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Op_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"can_raise",
     (PyCFunction)CPyPy_ops___Op___can_raise,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Op___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"stolen",
     (PyCFunction)CPyPy_ops___Op___stolen,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"unique_sources",
     (PyCFunction)CPyPy_ops___Op___unique_sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Op___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Op_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Op_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Op",
    .tp_new = ops___Op_new,
    .tp_dealloc = (destructor)ops___Op_dealloc,
    .tp_traverse = (traverseproc)ops___Op_traverse,
    .tp_clear = (inquiry)ops___Op_clear,
    .tp_getset = ops___Op_getseters,
    .tp_methods = ops___Op_methods,
    .tp_init = ops___Op_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___OpObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Op_template = &CPyType_ops___Op_template_;

static PyObject *
ops___Op_setup(PyTypeObject *type)
{
    mypyc___ir___ops___OpObject *self;
    self = (mypyc___ir___ops___OpObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Op_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    if (CPyDef_ops___Op_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Op(CPyTagged cpy_r_line)
{
    PyObject *self = ops___Op_setup(CPyType_ops___Op);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Op_____init__(self, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}


static int
ops___BaseAssign_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___BaseAssign_setup(PyTypeObject *type);
PyObject *CPyDef_ops___BaseAssign(PyObject *cpy_r_dest, CPyTagged cpy_r_line);

static PyObject *
ops___BaseAssign_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___BaseAssign) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___BaseAssign_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___BaseAssign_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___BaseAssign_traverse(mypyc___ir___ops___BaseAssignObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    Py_VISIT(self->_dest);
    return 0;
}

static int
ops___BaseAssign_clear(mypyc___ir___ops___BaseAssignObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    Py_CLEAR(self->_dest);
    return 0;
}

static void
ops___BaseAssign_dealloc(mypyc___ir___ops___BaseAssignObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___BaseAssign_dealloc)
    ops___BaseAssign_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___BaseAssign_vtable[11];
static bool
CPyDef_ops___BaseAssign_trait_vtable_setup(void)
{
    CPyVTableItem ops___BaseAssign_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___BaseAssign_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___BaseAssign_____init__,
        (CPyVTableItem)CPyDef_ops___Op___can_raise,
        (CPyVTableItem)CPyDef_ops___Op___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Op___accept,
        (CPyVTableItem)CPyDef_ops___BaseAssign_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___BaseAssign_____init__,
        (CPyVTableItem)CPyDef_ops___BaseAssign_____mypyc_defaults_setup,
    };
    memcpy(ops___BaseAssign_vtable, ops___BaseAssign_vtable_scratch, sizeof(ops___BaseAssign_vtable));
    return 1;
}

static PyObject *
ops___BaseAssign_get_dest(mypyc___ir___ops___BaseAssignObject *self, void *closure);
static int
ops___BaseAssign_set_dest(mypyc___ir___ops___BaseAssignObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___BaseAssign_getseters[] = {
    {"dest",
     (getter)ops___BaseAssign_get_dest, (setter)ops___BaseAssign_set_dest,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___BaseAssign_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___BaseAssign_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___BaseAssign_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___BaseAssign_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "BaseAssign",
    .tp_new = ops___BaseAssign_new,
    .tp_dealloc = (destructor)ops___BaseAssign_dealloc,
    .tp_traverse = (traverseproc)ops___BaseAssign_traverse,
    .tp_clear = (inquiry)ops___BaseAssign_clear,
    .tp_getset = ops___BaseAssign_getseters,
    .tp_methods = ops___BaseAssign_methods,
    .tp_init = ops___BaseAssign_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___BaseAssignObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___BaseAssign_template = &CPyType_ops___BaseAssign_template_;

static PyObject *
ops___BaseAssign_setup(PyTypeObject *type)
{
    mypyc___ir___ops___BaseAssignObject *self;
    self = (mypyc___ir___ops___BaseAssignObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___BaseAssign_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    if (CPyDef_ops___BaseAssign_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___BaseAssign(PyObject *cpy_r_dest, CPyTagged cpy_r_line)
{
    PyObject *self = ops___BaseAssign_setup(CPyType_ops___BaseAssign);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___BaseAssign_____init__(self, cpy_r_dest, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___BaseAssign_get_dest(mypyc___ir___ops___BaseAssignObject *self, void *closure)
{
    if (unlikely(self->_dest == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'dest' of 'BaseAssign' undefined");
        return NULL;
    }
    CPy_INCREF(self->_dest);
    PyObject *retval = self->_dest;
    return retval;
}

static int
ops___BaseAssign_set_dest(mypyc___ir___ops___BaseAssignObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'BaseAssign' object attribute 'dest' cannot be deleted");
        return -1;
    }
    if (self->_dest != NULL) {
        CPy_DECREF(self->_dest);
    }
    PyObject *tmp;
    if (likely(Py_TYPE(value) == CPyType_ops___Register))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Register", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_dest = tmp;
    return 0;
}

static int
ops___Assign_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Assign_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Assign(PyObject *cpy_r_dest, PyObject *cpy_r_src, CPyTagged cpy_r_line);

static PyObject *
ops___Assign_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Assign) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Assign_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Assign_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Assign_traverse(mypyc___ir___ops___AssignObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    Py_VISIT(self->_dest);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    return 0;
}

static int
ops___Assign_clear(mypyc___ir___ops___AssignObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    Py_CLEAR(self->_dest);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    return 0;
}

static void
ops___Assign_dealloc(mypyc___ir___ops___AssignObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Assign_dealloc)
    ops___Assign_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Assign_vtable[16];
static bool
CPyDef_ops___Assign_trait_vtable_setup(void)
{
    CPyVTableItem ops___Assign_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Assign_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Assign_____init__,
        (CPyVTableItem)CPyDef_ops___Op___can_raise,
        (CPyVTableItem)CPyDef_ops___Assign___sources,
        (CPyVTableItem)CPyDef_ops___Assign___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Assign___accept,
        (CPyVTableItem)CPyDef_ops___Assign_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Assign_____init__,
        (CPyVTableItem)CPyDef_ops___Assign_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Assign_____init__,
        (CPyVTableItem)CPyDef_ops___Assign___sources,
        (CPyVTableItem)CPyDef_ops___Assign___stolen,
        (CPyVTableItem)CPyDef_ops___Assign___accept,
        (CPyVTableItem)CPyDef_ops___Assign_____mypyc_defaults_setup,
    };
    memcpy(ops___Assign_vtable, ops___Assign_vtable_scratch, sizeof(ops___Assign_vtable));
    return 1;
}

static PyObject *
ops___Assign_get_error_kind(mypyc___ir___ops___AssignObject *self, void *closure);
static int
ops___Assign_set_error_kind(mypyc___ir___ops___AssignObject *self, PyObject *value, void *closure);
static PyObject *
ops___Assign_get_src(mypyc___ir___ops___AssignObject *self, void *closure);
static int
ops___Assign_set_src(mypyc___ir___ops___AssignObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Assign_getseters[] = {
    {"error_kind",
     (getter)ops___Assign_get_error_kind, (setter)ops___Assign_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___Assign_get_src, (setter)ops___Assign_set_src,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Assign_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Assign_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Assign___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"stolen",
     (PyCFunction)CPyPy_ops___Assign___stolen,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Assign___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Assign_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Assign_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Assign",
    .tp_new = ops___Assign_new,
    .tp_dealloc = (destructor)ops___Assign_dealloc,
    .tp_traverse = (traverseproc)ops___Assign_traverse,
    .tp_clear = (inquiry)ops___Assign_clear,
    .tp_getset = ops___Assign_getseters,
    .tp_methods = ops___Assign_methods,
    .tp_init = ops___Assign_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___AssignObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Assign_template = &CPyType_ops___Assign_template_;

static PyObject *
ops___Assign_setup(PyTypeObject *type)
{
    mypyc___ir___ops___AssignObject *self;
    self = (mypyc___ir___ops___AssignObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Assign_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___Assign_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Assign(PyObject *cpy_r_dest, PyObject *cpy_r_src, CPyTagged cpy_r_line)
{
    PyObject *self = ops___Assign_setup(CPyType_ops___Assign);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Assign_____init__(self, cpy_r_dest, cpy_r_src, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Assign_get_error_kind(mypyc___ir___ops___AssignObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'Assign' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___Assign_set_error_kind(mypyc___ir___ops___AssignObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Assign' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___Assign_get_src(mypyc___ir___ops___AssignObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'Assign' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___Assign_set_src(mypyc___ir___ops___AssignObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Assign' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static int
ops___AssignMulti_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___AssignMulti_setup(PyTypeObject *type);
PyObject *CPyDef_ops___AssignMulti(PyObject *cpy_r_dest, PyObject *cpy_r_src, CPyTagged cpy_r_line);

static PyObject *
ops___AssignMulti_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___AssignMulti) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___AssignMulti_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___AssignMulti_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___AssignMulti_traverse(mypyc___ir___ops___AssignMultiObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    Py_VISIT(self->_dest);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    return 0;
}

static int
ops___AssignMulti_clear(mypyc___ir___ops___AssignMultiObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    Py_CLEAR(self->_dest);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    return 0;
}

static void
ops___AssignMulti_dealloc(mypyc___ir___ops___AssignMultiObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___AssignMulti_dealloc)
    ops___AssignMulti_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___AssignMulti_vtable[16];
static bool
CPyDef_ops___AssignMulti_trait_vtable_setup(void)
{
    CPyVTableItem ops___AssignMulti_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___AssignMulti_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___AssignMulti_____init__,
        (CPyVTableItem)CPyDef_ops___Op___can_raise,
        (CPyVTableItem)CPyDef_ops___AssignMulti___sources,
        (CPyVTableItem)CPyDef_ops___AssignMulti___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___AssignMulti___accept,
        (CPyVTableItem)CPyDef_ops___AssignMulti_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___AssignMulti_____init__,
        (CPyVTableItem)CPyDef_ops___AssignMulti_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___AssignMulti_____init__,
        (CPyVTableItem)CPyDef_ops___AssignMulti___sources,
        (CPyVTableItem)CPyDef_ops___AssignMulti___stolen,
        (CPyVTableItem)CPyDef_ops___AssignMulti___accept,
        (CPyVTableItem)CPyDef_ops___AssignMulti_____mypyc_defaults_setup,
    };
    memcpy(ops___AssignMulti_vtable, ops___AssignMulti_vtable_scratch, sizeof(ops___AssignMulti_vtable));
    return 1;
}

static PyObject *
ops___AssignMulti_get_error_kind(mypyc___ir___ops___AssignMultiObject *self, void *closure);
static int
ops___AssignMulti_set_error_kind(mypyc___ir___ops___AssignMultiObject *self, PyObject *value, void *closure);
static PyObject *
ops___AssignMulti_get_src(mypyc___ir___ops___AssignMultiObject *self, void *closure);
static int
ops___AssignMulti_set_src(mypyc___ir___ops___AssignMultiObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___AssignMulti_getseters[] = {
    {"error_kind",
     (getter)ops___AssignMulti_get_error_kind, (setter)ops___AssignMulti_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___AssignMulti_get_src, (setter)ops___AssignMulti_set_src,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___AssignMulti_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___AssignMulti_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___AssignMulti___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"stolen",
     (PyCFunction)CPyPy_ops___AssignMulti___stolen,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___AssignMulti___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___AssignMulti_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___AssignMulti_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "AssignMulti",
    .tp_new = ops___AssignMulti_new,
    .tp_dealloc = (destructor)ops___AssignMulti_dealloc,
    .tp_traverse = (traverseproc)ops___AssignMulti_traverse,
    .tp_clear = (inquiry)ops___AssignMulti_clear,
    .tp_getset = ops___AssignMulti_getseters,
    .tp_methods = ops___AssignMulti_methods,
    .tp_init = ops___AssignMulti_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___AssignMultiObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___AssignMulti_template = &CPyType_ops___AssignMulti_template_;

static PyObject *
ops___AssignMulti_setup(PyTypeObject *type)
{
    mypyc___ir___ops___AssignMultiObject *self;
    self = (mypyc___ir___ops___AssignMultiObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___AssignMulti_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___AssignMulti_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___AssignMulti(PyObject *cpy_r_dest, PyObject *cpy_r_src, CPyTagged cpy_r_line)
{
    PyObject *self = ops___AssignMulti_setup(CPyType_ops___AssignMulti);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___AssignMulti_____init__(self, cpy_r_dest, cpy_r_src, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___AssignMulti_get_error_kind(mypyc___ir___ops___AssignMultiObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'AssignMulti' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___AssignMulti_set_error_kind(mypyc___ir___ops___AssignMultiObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'AssignMulti' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___AssignMulti_get_src(mypyc___ir___ops___AssignMultiObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'AssignMulti' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___AssignMulti_set_src(mypyc___ir___ops___AssignMultiObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'AssignMulti' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyList_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("list", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static PyObject *ops___ControlOp_setup(PyTypeObject *type);
PyObject *CPyDef_ops___ControlOp(CPyTagged cpy_r_line);

static PyObject *
ops___ControlOp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___ControlOp) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___ControlOp_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Op_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___ControlOp_traverse(mypyc___ir___ops___ControlOpObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    return 0;
}

static int
ops___ControlOp_clear(mypyc___ir___ops___ControlOpObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    return 0;
}

static void
ops___ControlOp_dealloc(mypyc___ir___ops___ControlOpObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___ControlOp_dealloc)
    ops___ControlOp_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___ControlOp_vtable[12];
static bool
CPyDef_ops___ControlOp_trait_vtable_setup(void)
{
    CPyVTableItem ops___ControlOp_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___ControlOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Op_____init__,
        (CPyVTableItem)CPyDef_ops___Op___can_raise,
        (CPyVTableItem)CPyDef_ops___Op___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Op___accept,
        (CPyVTableItem)CPyDef_ops___ControlOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___ControlOp___targets,
        (CPyVTableItem)CPyDef_ops___ControlOp___set_target,
        (CPyVTableItem)CPyDef_ops___ControlOp_____mypyc_defaults_setup,
    };
    memcpy(ops___ControlOp_vtable, ops___ControlOp_vtable_scratch, sizeof(ops___ControlOp_vtable));
    return 1;
}


static PyGetSetDef ops___ControlOp_getseters[] = {
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___ControlOp_methods[] = {
    {"targets",
     (PyCFunction)CPyPy_ops___ControlOp___targets,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"set_target",
     (PyCFunction)CPyPy_ops___ControlOp___set_target,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___ControlOp_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___ControlOp_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "ControlOp",
    .tp_new = ops___ControlOp_new,
    .tp_dealloc = (destructor)ops___ControlOp_dealloc,
    .tp_traverse = (traverseproc)ops___ControlOp_traverse,
    .tp_clear = (inquiry)ops___ControlOp_clear,
    .tp_getset = ops___ControlOp_getseters,
    .tp_methods = ops___ControlOp_methods,
    .tp_basicsize = sizeof(mypyc___ir___ops___ControlOpObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___ControlOp_template = &CPyType_ops___ControlOp_template_;

static PyObject *
ops___ControlOp_setup(PyTypeObject *type)
{
    mypyc___ir___ops___ControlOpObject *self;
    self = (mypyc___ir___ops___ControlOpObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___ControlOp_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    if (CPyDef_ops___ControlOp_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___ControlOp(CPyTagged cpy_r_line)
{
    PyObject *self = ops___ControlOp_setup(CPyType_ops___ControlOp);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Op_____init__(self, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}


static int
ops___Goto_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Goto_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Goto(PyObject *cpy_r_label, CPyTagged cpy_r_line);

static PyObject *
ops___Goto_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Goto) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Goto_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Goto_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Goto_traverse(mypyc___ir___ops___GotoObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_label);
    return 0;
}

static int
ops___Goto_clear(mypyc___ir___ops___GotoObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_label);
    return 0;
}

static void
ops___Goto_dealloc(mypyc___ir___ops___GotoObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Goto_dealloc)
    ops___Goto_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Goto_vtable[19];
static bool
CPyDef_ops___Goto_trait_vtable_setup(void)
{
    CPyVTableItem ops___Goto_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Goto_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Goto_____init__,
        (CPyVTableItem)CPyDef_ops___Op___can_raise,
        (CPyVTableItem)CPyDef_ops___Goto___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Goto___accept,
        (CPyVTableItem)CPyDef_ops___Goto_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Goto___targets,
        (CPyVTableItem)CPyDef_ops___Goto___set_target,
        (CPyVTableItem)CPyDef_ops___Goto_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Goto_____init__,
        (CPyVTableItem)CPyDef_ops___Goto___targets,
        (CPyVTableItem)CPyDef_ops___Goto___set_target,
        (CPyVTableItem)CPyDef_ops___Goto_____repr__,
        (CPyVTableItem)CPyDef_ops___Goto___sources,
        (CPyVTableItem)CPyDef_ops___Goto___accept,
        (CPyVTableItem)CPyDef_ops___Goto_____mypyc_defaults_setup,
    };
    memcpy(ops___Goto_vtable, ops___Goto_vtable_scratch, sizeof(ops___Goto_vtable));
    return 1;
}

static PyObject *
ops___Goto_get_error_kind(mypyc___ir___ops___GotoObject *self, void *closure);
static int
ops___Goto_set_error_kind(mypyc___ir___ops___GotoObject *self, PyObject *value, void *closure);
static PyObject *
ops___Goto_get_label(mypyc___ir___ops___GotoObject *self, void *closure);
static int
ops___Goto_set_label(mypyc___ir___ops___GotoObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Goto_getseters[] = {
    {"error_kind",
     (getter)ops___Goto_get_error_kind, (setter)ops___Goto_set_error_kind,
     NULL, NULL},
    {"label",
     (getter)ops___Goto_get_label, (setter)ops___Goto_set_label,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Goto_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Goto_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"targets",
     (PyCFunction)CPyPy_ops___Goto___targets,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"set_target",
     (PyCFunction)CPyPy_ops___Goto___set_target,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__repr__",
     (PyCFunction)CPyPy_ops___Goto_____repr__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Goto___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Goto___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Goto_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Goto_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Goto",
    .tp_new = ops___Goto_new,
    .tp_dealloc = (destructor)ops___Goto_dealloc,
    .tp_traverse = (traverseproc)ops___Goto_traverse,
    .tp_clear = (inquiry)ops___Goto_clear,
    .tp_getset = ops___Goto_getseters,
    .tp_methods = ops___Goto_methods,
    .tp_init = ops___Goto_init,
    .tp_repr = CPyDef_ops___Goto_____repr__,
    .tp_basicsize = sizeof(mypyc___ir___ops___GotoObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Goto_template = &CPyType_ops___Goto_template_;

static PyObject *
ops___Goto_setup(PyTypeObject *type)
{
    mypyc___ir___ops___GotoObject *self;
    self = (mypyc___ir___ops___GotoObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Goto_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___Goto_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Goto(PyObject *cpy_r_label, CPyTagged cpy_r_line)
{
    PyObject *self = ops___Goto_setup(CPyType_ops___Goto);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Goto_____init__(self, cpy_r_label, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Goto_get_error_kind(mypyc___ir___ops___GotoObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'Goto' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___Goto_set_error_kind(mypyc___ir___ops___GotoObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Goto' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___Goto_get_label(mypyc___ir___ops___GotoObject *self, void *closure)
{
    if (unlikely(self->_label == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'label' of 'Goto' undefined");
        return NULL;
    }
    CPy_INCREF(self->_label);
    PyObject *retval = self->_label;
    return retval;
}

static int
ops___Goto_set_label(mypyc___ir___ops___GotoObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Goto' object attribute 'label' cannot be deleted");
        return -1;
    }
    if (self->_label != NULL) {
        CPy_DECREF(self->_label);
    }
    PyObject *tmp;
    if (likely(Py_TYPE(value) == CPyType_ops___BasicBlock))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_label = tmp;
    return 0;
}

static int
ops___Branch_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Branch_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Branch(PyObject *cpy_r_value, PyObject *cpy_r_true_label, PyObject *cpy_r_false_label, CPyTagged cpy_r_op, CPyTagged cpy_r_line, char cpy_r_rare);

static PyObject *
ops___Branch_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Branch) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Branch_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Branch_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Branch_traverse(mypyc___ir___ops___BranchObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    if (CPyTagged_CheckLong(self->_BOOL)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_BOOL));
    }
    if (CPyTagged_CheckLong(self->_IS_ERROR)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_IS_ERROR));
    }
    Py_VISIT(self->_value);
    Py_VISIT(self->_true);
    Py_VISIT(self->_false);
    if (CPyTagged_CheckLong(self->_op)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_op));
    }
    Py_VISIT(self->_traceback_entry);
    return 0;
}

static int
ops___Branch_clear(mypyc___ir___ops___BranchObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_BOOL)) {
        CPyTagged __tmp = self->_BOOL;
        self->_BOOL = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_IS_ERROR)) {
        CPyTagged __tmp = self->_IS_ERROR;
        self->_IS_ERROR = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_value);
    Py_CLEAR(self->_true);
    Py_CLEAR(self->_false);
    if (CPyTagged_CheckLong(self->_op)) {
        CPyTagged __tmp = self->_op;
        self->_op = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_traceback_entry);
    return 0;
}

static void
ops___Branch_dealloc(mypyc___ir___ops___BranchObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Branch_dealloc)
    ops___Branch_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Branch_vtable[19];
static bool
CPyDef_ops___Branch_trait_vtable_setup(void)
{
    CPyVTableItem ops___Branch_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Branch_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Branch_____init__,
        (CPyVTableItem)CPyDef_ops___Op___can_raise,
        (CPyVTableItem)CPyDef_ops___Branch___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Branch___accept,
        (CPyVTableItem)CPyDef_ops___Branch_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Branch___targets,
        (CPyVTableItem)CPyDef_ops___Branch___set_target,
        (CPyVTableItem)CPyDef_ops___Branch_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Branch_____init__,
        (CPyVTableItem)CPyDef_ops___Branch___targets,
        (CPyVTableItem)CPyDef_ops___Branch___set_target,
        (CPyVTableItem)CPyDef_ops___Branch___sources,
        (CPyVTableItem)CPyDef_ops___Branch___invert,
        (CPyVTableItem)CPyDef_ops___Branch___accept,
        (CPyVTableItem)CPyDef_ops___Branch_____mypyc_defaults_setup,
    };
    memcpy(ops___Branch_vtable, ops___Branch_vtable_scratch, sizeof(ops___Branch_vtable));
    return 1;
}

static PyObject *
ops___Branch_get_error_kind(mypyc___ir___ops___BranchObject *self, void *closure);
static int
ops___Branch_set_error_kind(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure);
static PyObject *
ops___Branch_get_BOOL(mypyc___ir___ops___BranchObject *self, void *closure);
static int
ops___Branch_set_BOOL(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure);
static PyObject *
ops___Branch_get_IS_ERROR(mypyc___ir___ops___BranchObject *self, void *closure);
static int
ops___Branch_set_IS_ERROR(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure);
static PyObject *
ops___Branch_get_value(mypyc___ir___ops___BranchObject *self, void *closure);
static int
ops___Branch_set_value(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure);
static PyObject *
ops___Branch_get_true(mypyc___ir___ops___BranchObject *self, void *closure);
static int
ops___Branch_set_true(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure);
static PyObject *
ops___Branch_get_false(mypyc___ir___ops___BranchObject *self, void *closure);
static int
ops___Branch_set_false(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure);
static PyObject *
ops___Branch_get_op(mypyc___ir___ops___BranchObject *self, void *closure);
static int
ops___Branch_set_op(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure);
static PyObject *
ops___Branch_get_negated(mypyc___ir___ops___BranchObject *self, void *closure);
static int
ops___Branch_set_negated(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure);
static PyObject *
ops___Branch_get_traceback_entry(mypyc___ir___ops___BranchObject *self, void *closure);
static int
ops___Branch_set_traceback_entry(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure);
static PyObject *
ops___Branch_get_rare(mypyc___ir___ops___BranchObject *self, void *closure);
static int
ops___Branch_set_rare(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Branch_getseters[] = {
    {"error_kind",
     (getter)ops___Branch_get_error_kind, (setter)ops___Branch_set_error_kind,
     NULL, NULL},
    {"BOOL",
     (getter)ops___Branch_get_BOOL, (setter)ops___Branch_set_BOOL,
     NULL, NULL},
    {"IS_ERROR",
     (getter)ops___Branch_get_IS_ERROR, (setter)ops___Branch_set_IS_ERROR,
     NULL, NULL},
    {"value",
     (getter)ops___Branch_get_value, (setter)ops___Branch_set_value,
     NULL, NULL},
    {"true",
     (getter)ops___Branch_get_true, (setter)ops___Branch_set_true,
     NULL, NULL},
    {"false",
     (getter)ops___Branch_get_false, (setter)ops___Branch_set_false,
     NULL, NULL},
    {"op",
     (getter)ops___Branch_get_op, (setter)ops___Branch_set_op,
     NULL, NULL},
    {"negated",
     (getter)ops___Branch_get_negated, (setter)ops___Branch_set_negated,
     NULL, NULL},
    {"traceback_entry",
     (getter)ops___Branch_get_traceback_entry, (setter)ops___Branch_set_traceback_entry,
     NULL, NULL},
    {"rare",
     (getter)ops___Branch_get_rare, (setter)ops___Branch_set_rare,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Branch_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Branch_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"targets",
     (PyCFunction)CPyPy_ops___Branch___targets,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"set_target",
     (PyCFunction)CPyPy_ops___Branch___set_target,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Branch___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"invert",
     (PyCFunction)CPyPy_ops___Branch___invert,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Branch___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Branch_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Branch_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Branch",
    .tp_new = ops___Branch_new,
    .tp_dealloc = (destructor)ops___Branch_dealloc,
    .tp_traverse = (traverseproc)ops___Branch_traverse,
    .tp_clear = (inquiry)ops___Branch_clear,
    .tp_getset = ops___Branch_getseters,
    .tp_methods = ops___Branch_methods,
    .tp_init = ops___Branch_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___BranchObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Branch_template = &CPyType_ops___Branch_template_;

static PyObject *
ops___Branch_setup(PyTypeObject *type)
{
    mypyc___ir___ops___BranchObject *self;
    self = (mypyc___ir___ops___BranchObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Branch_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_BOOL = CPY_INT_TAG;
    self->_IS_ERROR = CPY_INT_TAG;
    self->_op = CPY_INT_TAG;
    self->_negated = 2;
    self->_rare = 2;
    if (CPyDef_ops___Branch_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Branch(PyObject *cpy_r_value, PyObject *cpy_r_true_label, PyObject *cpy_r_false_label, CPyTagged cpy_r_op, CPyTagged cpy_r_line, char cpy_r_rare)
{
    PyObject *self = ops___Branch_setup(CPyType_ops___Branch);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Branch_____init__(self, cpy_r_value, cpy_r_true_label, cpy_r_false_label, cpy_r_op, cpy_r_line, cpy_r_rare);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Branch_get_error_kind(mypyc___ir___ops___BranchObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'Branch' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___Branch_set_error_kind(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Branch' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___Branch_get_BOOL(mypyc___ir___ops___BranchObject *self, void *closure)
{
    if (unlikely(self->_BOOL == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'BOOL' of 'Branch' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_BOOL);
    PyObject *retval = CPyTagged_StealAsObject(self->_BOOL);
    return retval;
}

static int
ops___Branch_set_BOOL(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Branch' object attribute 'BOOL' cannot be deleted");
        return -1;
    }
    if (self->_BOOL != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_BOOL);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_BOOL = tmp;
    return 0;
}

static PyObject *
ops___Branch_get_IS_ERROR(mypyc___ir___ops___BranchObject *self, void *closure)
{
    if (unlikely(self->_IS_ERROR == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'IS_ERROR' of 'Branch' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_IS_ERROR);
    PyObject *retval = CPyTagged_StealAsObject(self->_IS_ERROR);
    return retval;
}

static int
ops___Branch_set_IS_ERROR(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Branch' object attribute 'IS_ERROR' cannot be deleted");
        return -1;
    }
    if (self->_IS_ERROR != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_IS_ERROR);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_IS_ERROR = tmp;
    return 0;
}

static PyObject *
ops___Branch_get_value(mypyc___ir___ops___BranchObject *self, void *closure)
{
    if (unlikely(self->_value == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'value' of 'Branch' undefined");
        return NULL;
    }
    CPy_INCREF(self->_value);
    PyObject *retval = self->_value;
    return retval;
}

static int
ops___Branch_set_value(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Branch' object attribute 'value' cannot be deleted");
        return -1;
    }
    if (self->_value != NULL) {
        CPy_DECREF(self->_value);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_value = tmp;
    return 0;
}

static PyObject *
ops___Branch_get_true(mypyc___ir___ops___BranchObject *self, void *closure)
{
    if (unlikely(self->_true == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'true' of 'Branch' undefined");
        return NULL;
    }
    CPy_INCREF(self->_true);
    PyObject *retval = self->_true;
    return retval;
}

static int
ops___Branch_set_true(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Branch' object attribute 'true' cannot be deleted");
        return -1;
    }
    if (self->_true != NULL) {
        CPy_DECREF(self->_true);
    }
    PyObject *tmp;
    if (likely(Py_TYPE(value) == CPyType_ops___BasicBlock))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_true = tmp;
    return 0;
}

static PyObject *
ops___Branch_get_false(mypyc___ir___ops___BranchObject *self, void *closure)
{
    if (unlikely(self->_false == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'false' of 'Branch' undefined");
        return NULL;
    }
    CPy_INCREF(self->_false);
    PyObject *retval = self->_false;
    return retval;
}

static int
ops___Branch_set_false(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Branch' object attribute 'false' cannot be deleted");
        return -1;
    }
    if (self->_false != NULL) {
        CPy_DECREF(self->_false);
    }
    PyObject *tmp;
    if (likely(Py_TYPE(value) == CPyType_ops___BasicBlock))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_false = tmp;
    return 0;
}

static PyObject *
ops___Branch_get_op(mypyc___ir___ops___BranchObject *self, void *closure)
{
    if (unlikely(self->_op == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'op' of 'Branch' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_op);
    PyObject *retval = CPyTagged_StealAsObject(self->_op);
    return retval;
}

static int
ops___Branch_set_op(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Branch' object attribute 'op' cannot be deleted");
        return -1;
    }
    if (self->_op != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_op);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_op = tmp;
    return 0;
}

static PyObject *
ops___Branch_get_negated(mypyc___ir___ops___BranchObject *self, void *closure)
{
    PyObject *retval = self->_negated ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___Branch_set_negated(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Branch' object attribute 'negated' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_negated = tmp;
    return 0;
}

static PyObject *
ops___Branch_get_traceback_entry(mypyc___ir___ops___BranchObject *self, void *closure)
{
    if (unlikely(self->_traceback_entry == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'traceback_entry' of 'Branch' undefined");
        return NULL;
    }
    CPy_INCREF(self->_traceback_entry);
    PyObject *retval = self->_traceback_entry;
    return retval;
}

static int
ops___Branch_set_traceback_entry(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Branch' object attribute 'traceback_entry' cannot be deleted");
        return -1;
    }
    if (self->_traceback_entry != NULL) {
        CPy_DECREF(self->_traceback_entry);
    }
    PyObject *tmp;
    if (unlikely(!(PyTuple_Check(value) && PyTuple_GET_SIZE(value) == 2))) {
        tmp = NULL;
        goto __LL9857;
    }
    if (likely(PyUnicode_Check(PyTuple_GET_ITEM(value, 0))))
        tmp = PyTuple_GET_ITEM(value, 0);
    else {
        tmp = NULL;
    }
    if (tmp == NULL) goto __LL9857;
    if (likely(PyLong_Check(PyTuple_GET_ITEM(value, 1))))
        tmp = PyTuple_GET_ITEM(value, 1);
    else {
        tmp = NULL;
    }
    if (tmp == NULL) goto __LL9857;
    tmp = value;
__LL9857: ;
    if (tmp != NULL) goto __LL9856;
    if (value == Py_None)
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9856;
    CPy_TypeError("tuple[str, int] or None", value); 
    tmp = NULL;
__LL9856: ;
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_traceback_entry = tmp;
    return 0;
}

static PyObject *
ops___Branch_get_rare(mypyc___ir___ops___BranchObject *self, void *closure)
{
    PyObject *retval = self->_rare ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___Branch_set_rare(mypyc___ir___ops___BranchObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Branch' object attribute 'rare' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_rare = tmp;
    return 0;
}

static int
ops___Return_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Return_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Return(PyObject *cpy_r_value, CPyTagged cpy_r_line);

static PyObject *
ops___Return_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Return) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Return_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Return_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Return_traverse(mypyc___ir___ops___ReturnObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_value);
    return 0;
}

static int
ops___Return_clear(mypyc___ir___ops___ReturnObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_value);
    return 0;
}

static void
ops___Return_dealloc(mypyc___ir___ops___ReturnObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Return_dealloc)
    ops___Return_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Return_vtable[17];
static bool
CPyDef_ops___Return_trait_vtable_setup(void)
{
    CPyVTableItem ops___Return_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Return_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Return_____init__,
        (CPyVTableItem)CPyDef_ops___Op___can_raise,
        (CPyVTableItem)CPyDef_ops___Return___sources,
        (CPyVTableItem)CPyDef_ops___Return___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Return___accept,
        (CPyVTableItem)CPyDef_ops___Return_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___ControlOp___targets,
        (CPyVTableItem)CPyDef_ops___ControlOp___set_target,
        (CPyVTableItem)CPyDef_ops___Return_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Return_____init__,
        (CPyVTableItem)CPyDef_ops___Return___sources,
        (CPyVTableItem)CPyDef_ops___Return___stolen,
        (CPyVTableItem)CPyDef_ops___Return___accept,
        (CPyVTableItem)CPyDef_ops___Return_____mypyc_defaults_setup,
    };
    memcpy(ops___Return_vtable, ops___Return_vtable_scratch, sizeof(ops___Return_vtable));
    return 1;
}

static PyObject *
ops___Return_get_error_kind(mypyc___ir___ops___ReturnObject *self, void *closure);
static int
ops___Return_set_error_kind(mypyc___ir___ops___ReturnObject *self, PyObject *value, void *closure);
static PyObject *
ops___Return_get_value(mypyc___ir___ops___ReturnObject *self, void *closure);
static int
ops___Return_set_value(mypyc___ir___ops___ReturnObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Return_getseters[] = {
    {"error_kind",
     (getter)ops___Return_get_error_kind, (setter)ops___Return_set_error_kind,
     NULL, NULL},
    {"value",
     (getter)ops___Return_get_value, (setter)ops___Return_set_value,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Return_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Return_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Return___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"stolen",
     (PyCFunction)CPyPy_ops___Return___stolen,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Return___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Return_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Return_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Return",
    .tp_new = ops___Return_new,
    .tp_dealloc = (destructor)ops___Return_dealloc,
    .tp_traverse = (traverseproc)ops___Return_traverse,
    .tp_clear = (inquiry)ops___Return_clear,
    .tp_getset = ops___Return_getseters,
    .tp_methods = ops___Return_methods,
    .tp_init = ops___Return_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___ReturnObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Return_template = &CPyType_ops___Return_template_;

static PyObject *
ops___Return_setup(PyTypeObject *type)
{
    mypyc___ir___ops___ReturnObject *self;
    self = (mypyc___ir___ops___ReturnObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Return_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___Return_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Return(PyObject *cpy_r_value, CPyTagged cpy_r_line)
{
    PyObject *self = ops___Return_setup(CPyType_ops___Return);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Return_____init__(self, cpy_r_value, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Return_get_error_kind(mypyc___ir___ops___ReturnObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'Return' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___Return_set_error_kind(mypyc___ir___ops___ReturnObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Return' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___Return_get_value(mypyc___ir___ops___ReturnObject *self, void *closure)
{
    if (unlikely(self->_value == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'value' of 'Return' undefined");
        return NULL;
    }
    CPy_INCREF(self->_value);
    PyObject *retval = self->_value;
    return retval;
}

static int
ops___Return_set_value(mypyc___ir___ops___ReturnObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Return' object attribute 'value' cannot be deleted");
        return -1;
    }
    if (self->_value != NULL) {
        CPy_DECREF(self->_value);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_value = tmp;
    return 0;
}

static int
ops___Unreachable_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Unreachable_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Unreachable(CPyTagged cpy_r_line);

static PyObject *
ops___Unreachable_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Unreachable) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Unreachable_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Unreachable_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Unreachable_traverse(mypyc___ir___ops___UnreachableObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    return 0;
}

static int
ops___Unreachable_clear(mypyc___ir___ops___UnreachableObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    return 0;
}

static void
ops___Unreachable_dealloc(mypyc___ir___ops___UnreachableObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Unreachable_dealloc)
    ops___Unreachable_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Unreachable_vtable[16];
static bool
CPyDef_ops___Unreachable_trait_vtable_setup(void)
{
    CPyVTableItem ops___Unreachable_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Unreachable_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Unreachable_____init__,
        (CPyVTableItem)CPyDef_ops___Op___can_raise,
        (CPyVTableItem)CPyDef_ops___Unreachable___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Unreachable___accept,
        (CPyVTableItem)CPyDef_ops___Unreachable_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___ControlOp___targets,
        (CPyVTableItem)CPyDef_ops___ControlOp___set_target,
        (CPyVTableItem)CPyDef_ops___Unreachable_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Unreachable_____init__,
        (CPyVTableItem)CPyDef_ops___Unreachable___sources,
        (CPyVTableItem)CPyDef_ops___Unreachable___accept,
        (CPyVTableItem)CPyDef_ops___Unreachable_____mypyc_defaults_setup,
    };
    memcpy(ops___Unreachable_vtable, ops___Unreachable_vtable_scratch, sizeof(ops___Unreachable_vtable));
    return 1;
}

static PyObject *
ops___Unreachable_get_error_kind(mypyc___ir___ops___UnreachableObject *self, void *closure);
static int
ops___Unreachable_set_error_kind(mypyc___ir___ops___UnreachableObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Unreachable_getseters[] = {
    {"error_kind",
     (getter)ops___Unreachable_get_error_kind, (setter)ops___Unreachable_set_error_kind,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Unreachable_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Unreachable_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Unreachable___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Unreachable___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Unreachable_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Unreachable_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Unreachable",
    .tp_new = ops___Unreachable_new,
    .tp_dealloc = (destructor)ops___Unreachable_dealloc,
    .tp_traverse = (traverseproc)ops___Unreachable_traverse,
    .tp_clear = (inquiry)ops___Unreachable_clear,
    .tp_getset = ops___Unreachable_getseters,
    .tp_methods = ops___Unreachable_methods,
    .tp_init = ops___Unreachable_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___UnreachableObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Unreachable_template = &CPyType_ops___Unreachable_template_;

static PyObject *
ops___Unreachable_setup(PyTypeObject *type)
{
    mypyc___ir___ops___UnreachableObject *self;
    self = (mypyc___ir___ops___UnreachableObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Unreachable_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___Unreachable_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Unreachable(CPyTagged cpy_r_line)
{
    PyObject *self = ops___Unreachable_setup(CPyType_ops___Unreachable);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Unreachable_____init__(self, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Unreachable_get_error_kind(mypyc___ir___ops___UnreachableObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'Unreachable' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___Unreachable_set_error_kind(mypyc___ir___ops___UnreachableObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Unreachable' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static int
ops___RegisterOp_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___RegisterOp_setup(PyTypeObject *type);
PyObject *CPyDef_ops___RegisterOp(CPyTagged cpy_r_line);

static PyObject *
ops___RegisterOp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___RegisterOp) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___RegisterOp_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___RegisterOp_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___RegisterOp_traverse(mypyc___ir___ops___RegisterOpObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    return 0;
}

static int
ops___RegisterOp_clear(mypyc___ir___ops___RegisterOpObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    return 0;
}

static void
ops___RegisterOp_dealloc(mypyc___ir___ops___RegisterOpObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___RegisterOp_dealloc)
    ops___RegisterOp_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___RegisterOp_vtable[12];
static bool
CPyDef_ops___RegisterOp_trait_vtable_setup(void)
{
    CPyVTableItem ops___RegisterOp_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___RegisterOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___RegisterOp_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Op___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Op___accept,
        (CPyVTableItem)CPyDef_ops___RegisterOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___RegisterOp_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___RegisterOp_____mypyc_defaults_setup,
    };
    memcpy(ops___RegisterOp_vtable, ops___RegisterOp_vtable_scratch, sizeof(ops___RegisterOp_vtable));
    return 1;
}

static PyObject *
ops___RegisterOp_get_error_kind(mypyc___ir___ops___RegisterOpObject *self, void *closure);
static int
ops___RegisterOp_set_error_kind(mypyc___ir___ops___RegisterOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___RegisterOp_get__type(mypyc___ir___ops___RegisterOpObject *self, void *closure);
static int
ops___RegisterOp_set__type(mypyc___ir___ops___RegisterOpObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___RegisterOp_getseters[] = {
    {"error_kind",
     (getter)ops___RegisterOp_get_error_kind, (setter)ops___RegisterOp_set_error_kind,
     NULL, NULL},
    {"_type",
     (getter)ops___RegisterOp_get__type, (setter)ops___RegisterOp_set__type,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___RegisterOp_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___RegisterOp_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"can_raise",
     (PyCFunction)CPyPy_ops___RegisterOp___can_raise,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___RegisterOp_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___RegisterOp_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "RegisterOp",
    .tp_new = ops___RegisterOp_new,
    .tp_dealloc = (destructor)ops___RegisterOp_dealloc,
    .tp_traverse = (traverseproc)ops___RegisterOp_traverse,
    .tp_clear = (inquiry)ops___RegisterOp_clear,
    .tp_getset = ops___RegisterOp_getseters,
    .tp_methods = ops___RegisterOp_methods,
    .tp_init = ops___RegisterOp_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___RegisterOpObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___RegisterOp_template = &CPyType_ops___RegisterOp_template_;

static PyObject *
ops___RegisterOp_setup(PyTypeObject *type)
{
    mypyc___ir___ops___RegisterOpObject *self;
    self = (mypyc___ir___ops___RegisterOpObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___RegisterOp_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___RegisterOp_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___RegisterOp(CPyTagged cpy_r_line)
{
    PyObject *self = ops___RegisterOp_setup(CPyType_ops___RegisterOp);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___RegisterOp_____init__(self, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___RegisterOp_get_error_kind(mypyc___ir___ops___RegisterOpObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'RegisterOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___RegisterOp_set_error_kind(mypyc___ir___ops___RegisterOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RegisterOp' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___RegisterOp_get__type(mypyc___ir___ops___RegisterOpObject *self, void *closure)
{
    if (unlikely(self->__type == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute '_type' of 'RegisterOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->__type);
    PyObject *retval = self->__type;
    return retval;
}

static int
ops___RegisterOp_set__type(mypyc___ir___ops___RegisterOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RegisterOp' object attribute '_type' cannot be deleted");
        return -1;
    }
    if (self->__type != NULL) {
        CPy_DECREF(self->__type);
    }
    PyObject *tmp;
    if (PyObject_TypeCheck(value, CPyType_rtypes___RType))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9858;
    if (value == Py_None)
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9858;
    CPy_TypeError("mypyc.ir.rtypes.RType or None", value); 
    tmp = NULL;
__LL9858: ;
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->__type = tmp;
    return 0;
}

static int
ops___IncRef_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___IncRef_setup(PyTypeObject *type);
PyObject *CPyDef_ops___IncRef(PyObject *cpy_r_src, CPyTagged cpy_r_line);

static PyObject *
ops___IncRef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___IncRef) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___IncRef_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___IncRef_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___IncRef_traverse(mypyc___ir___ops___IncRefObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    return 0;
}

static int
ops___IncRef_clear(mypyc___ir___ops___IncRefObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    return 0;
}

static void
ops___IncRef_dealloc(mypyc___ir___ops___IncRefObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___IncRef_dealloc)
    ops___IncRef_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___IncRef_vtable[16];
static bool
CPyDef_ops___IncRef_trait_vtable_setup(void)
{
    CPyVTableItem ops___IncRef_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___IncRef_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___IncRef_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___IncRef___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___IncRef___accept,
        (CPyVTableItem)CPyDef_ops___IncRef_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___IncRef_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___IncRef_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___IncRef_____init__,
        (CPyVTableItem)CPyDef_ops___IncRef___sources,
        (CPyVTableItem)CPyDef_ops___IncRef___accept,
        (CPyVTableItem)CPyDef_ops___IncRef_____mypyc_defaults_setup,
    };
    memcpy(ops___IncRef_vtable, ops___IncRef_vtable_scratch, sizeof(ops___IncRef_vtable));
    return 1;
}

static PyObject *
ops___IncRef_get_error_kind(mypyc___ir___ops___IncRefObject *self, void *closure);
static int
ops___IncRef_set_error_kind(mypyc___ir___ops___IncRefObject *self, PyObject *value, void *closure);
static PyObject *
ops___IncRef_get_src(mypyc___ir___ops___IncRefObject *self, void *closure);
static int
ops___IncRef_set_src(mypyc___ir___ops___IncRefObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___IncRef_getseters[] = {
    {"error_kind",
     (getter)ops___IncRef_get_error_kind, (setter)ops___IncRef_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___IncRef_get_src, (setter)ops___IncRef_set_src,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___IncRef_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___IncRef_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___IncRef___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___IncRef___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___IncRef_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___IncRef_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "IncRef",
    .tp_new = ops___IncRef_new,
    .tp_dealloc = (destructor)ops___IncRef_dealloc,
    .tp_traverse = (traverseproc)ops___IncRef_traverse,
    .tp_clear = (inquiry)ops___IncRef_clear,
    .tp_getset = ops___IncRef_getseters,
    .tp_methods = ops___IncRef_methods,
    .tp_init = ops___IncRef_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___IncRefObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___IncRef_template = &CPyType_ops___IncRef_template_;

static PyObject *
ops___IncRef_setup(PyTypeObject *type)
{
    mypyc___ir___ops___IncRefObject *self;
    self = (mypyc___ir___ops___IncRefObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___IncRef_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___IncRef_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___IncRef(PyObject *cpy_r_src, CPyTagged cpy_r_line)
{
    PyObject *self = ops___IncRef_setup(CPyType_ops___IncRef);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___IncRef_____init__(self, cpy_r_src, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___IncRef_get_error_kind(mypyc___ir___ops___IncRefObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'IncRef' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___IncRef_set_error_kind(mypyc___ir___ops___IncRefObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IncRef' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___IncRef_get_src(mypyc___ir___ops___IncRefObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'IncRef' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___IncRef_set_src(mypyc___ir___ops___IncRefObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IncRef' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static int
ops___DecRef_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___DecRef_setup(PyTypeObject *type);
PyObject *CPyDef_ops___DecRef(PyObject *cpy_r_src, char cpy_r_is_xdec, CPyTagged cpy_r_line);

static PyObject *
ops___DecRef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___DecRef) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___DecRef_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___DecRef_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___DecRef_traverse(mypyc___ir___ops___DecRefObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    return 0;
}

static int
ops___DecRef_clear(mypyc___ir___ops___DecRefObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    return 0;
}

static void
ops___DecRef_dealloc(mypyc___ir___ops___DecRefObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___DecRef_dealloc)
    ops___DecRef_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___DecRef_vtable[17];
static bool
CPyDef_ops___DecRef_trait_vtable_setup(void)
{
    CPyVTableItem ops___DecRef_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___DecRef_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___DecRef_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___DecRef___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___DecRef___accept,
        (CPyVTableItem)CPyDef_ops___DecRef_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___DecRef_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___DecRef_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___DecRef_____init__,
        (CPyVTableItem)CPyDef_ops___DecRef_____repr__,
        (CPyVTableItem)CPyDef_ops___DecRef___sources,
        (CPyVTableItem)CPyDef_ops___DecRef___accept,
        (CPyVTableItem)CPyDef_ops___DecRef_____mypyc_defaults_setup,
    };
    memcpy(ops___DecRef_vtable, ops___DecRef_vtable_scratch, sizeof(ops___DecRef_vtable));
    return 1;
}

static PyObject *
ops___DecRef_get_error_kind(mypyc___ir___ops___DecRefObject *self, void *closure);
static int
ops___DecRef_set_error_kind(mypyc___ir___ops___DecRefObject *self, PyObject *value, void *closure);
static PyObject *
ops___DecRef_get_src(mypyc___ir___ops___DecRefObject *self, void *closure);
static int
ops___DecRef_set_src(mypyc___ir___ops___DecRefObject *self, PyObject *value, void *closure);
static PyObject *
ops___DecRef_get_is_xdec(mypyc___ir___ops___DecRefObject *self, void *closure);
static int
ops___DecRef_set_is_xdec(mypyc___ir___ops___DecRefObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___DecRef_getseters[] = {
    {"error_kind",
     (getter)ops___DecRef_get_error_kind, (setter)ops___DecRef_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___DecRef_get_src, (setter)ops___DecRef_set_src,
     NULL, NULL},
    {"is_xdec",
     (getter)ops___DecRef_get_is_xdec, (setter)ops___DecRef_set_is_xdec,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___DecRef_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___DecRef_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__repr__",
     (PyCFunction)CPyPy_ops___DecRef_____repr__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___DecRef___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___DecRef___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___DecRef_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___DecRef_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "DecRef",
    .tp_new = ops___DecRef_new,
    .tp_dealloc = (destructor)ops___DecRef_dealloc,
    .tp_traverse = (traverseproc)ops___DecRef_traverse,
    .tp_clear = (inquiry)ops___DecRef_clear,
    .tp_getset = ops___DecRef_getseters,
    .tp_methods = ops___DecRef_methods,
    .tp_init = ops___DecRef_init,
    .tp_repr = CPyDef_ops___DecRef_____repr__,
    .tp_basicsize = sizeof(mypyc___ir___ops___DecRefObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___DecRef_template = &CPyType_ops___DecRef_template_;

static PyObject *
ops___DecRef_setup(PyTypeObject *type)
{
    mypyc___ir___ops___DecRefObject *self;
    self = (mypyc___ir___ops___DecRefObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___DecRef_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_is_xdec = 2;
    if (CPyDef_ops___DecRef_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___DecRef(PyObject *cpy_r_src, char cpy_r_is_xdec, CPyTagged cpy_r_line)
{
    PyObject *self = ops___DecRef_setup(CPyType_ops___DecRef);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___DecRef_____init__(self, cpy_r_src, cpy_r_is_xdec, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___DecRef_get_error_kind(mypyc___ir___ops___DecRefObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'DecRef' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___DecRef_set_error_kind(mypyc___ir___ops___DecRefObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'DecRef' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___DecRef_get_src(mypyc___ir___ops___DecRefObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'DecRef' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___DecRef_set_src(mypyc___ir___ops___DecRefObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'DecRef' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static PyObject *
ops___DecRef_get_is_xdec(mypyc___ir___ops___DecRefObject *self, void *closure)
{
    PyObject *retval = self->_is_xdec ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___DecRef_set_is_xdec(mypyc___ir___ops___DecRefObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'DecRef' object attribute 'is_xdec' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_is_xdec = tmp;
    return 0;
}

static int
ops___Call_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Call_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Call(PyObject *cpy_r_fn, PyObject *cpy_r_args, CPyTagged cpy_r_line);

static PyObject *
ops___Call_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Call) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Call_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Call_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Call_traverse(mypyc___ir___ops___CallObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    Py_VISIT(self->_fn);
    Py_VISIT(self->_args);
    return 0;
}

static int
ops___Call_clear(mypyc___ir___ops___CallObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    Py_CLEAR(self->_fn);
    Py_CLEAR(self->_args);
    return 0;
}

static void
ops___Call_dealloc(mypyc___ir___ops___CallObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Call_dealloc)
    ops___Call_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Call_vtable[16];
static bool
CPyDef_ops___Call_trait_vtable_setup(void)
{
    CPyVTableItem ops___Call_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Call_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Call_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Call___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Call___accept,
        (CPyVTableItem)CPyDef_ops___Call_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Call_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Call_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Call_____init__,
        (CPyVTableItem)CPyDef_ops___Call___sources,
        (CPyVTableItem)CPyDef_ops___Call___accept,
        (CPyVTableItem)CPyDef_ops___Call_____mypyc_defaults_setup,
    };
    memcpy(ops___Call_vtable, ops___Call_vtable_scratch, sizeof(ops___Call_vtable));
    return 1;
}

static PyObject *
ops___Call_get_fn(mypyc___ir___ops___CallObject *self, void *closure);
static int
ops___Call_set_fn(mypyc___ir___ops___CallObject *self, PyObject *value, void *closure);
static PyObject *
ops___Call_get_args(mypyc___ir___ops___CallObject *self, void *closure);
static int
ops___Call_set_args(mypyc___ir___ops___CallObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Call_getseters[] = {
    {"fn",
     (getter)ops___Call_get_fn, (setter)ops___Call_set_fn,
     NULL, NULL},
    {"args",
     (getter)ops___Call_get_args, (setter)ops___Call_set_args,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Call_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Call_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Call___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Call___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Call_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Call_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Call",
    .tp_new = ops___Call_new,
    .tp_dealloc = (destructor)ops___Call_dealloc,
    .tp_traverse = (traverseproc)ops___Call_traverse,
    .tp_clear = (inquiry)ops___Call_clear,
    .tp_getset = ops___Call_getseters,
    .tp_methods = ops___Call_methods,
    .tp_init = ops___Call_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___CallObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Call_template = &CPyType_ops___Call_template_;

static PyObject *
ops___Call_setup(PyTypeObject *type)
{
    mypyc___ir___ops___CallObject *self;
    self = (mypyc___ir___ops___CallObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Call_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___Call_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Call(PyObject *cpy_r_fn, PyObject *cpy_r_args, CPyTagged cpy_r_line)
{
    PyObject *self = ops___Call_setup(CPyType_ops___Call);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Call_____init__(self, cpy_r_fn, cpy_r_args, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Call_get_fn(mypyc___ir___ops___CallObject *self, void *closure)
{
    if (unlikely(self->_fn == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'fn' of 'Call' undefined");
        return NULL;
    }
    CPy_INCREF(self->_fn);
    PyObject *retval = self->_fn;
    return retval;
}

static int
ops___Call_set_fn(mypyc___ir___ops___CallObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Call' object attribute 'fn' cannot be deleted");
        return -1;
    }
    if (self->_fn != NULL) {
        CPy_DECREF(self->_fn);
    }
    PyObject *tmp;
    if (likely(Py_TYPE(value) == CPyType_func_ir___FuncDecl))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.func_ir.FuncDecl", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_fn = tmp;
    return 0;
}

static PyObject *
ops___Call_get_args(mypyc___ir___ops___CallObject *self, void *closure)
{
    if (unlikely(self->_args == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'args' of 'Call' undefined");
        return NULL;
    }
    CPy_INCREF(self->_args);
    PyObject *retval = self->_args;
    return retval;
}

static int
ops___Call_set_args(mypyc___ir___ops___CallObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Call' object attribute 'args' cannot be deleted");
        return -1;
    }
    if (self->_args != NULL) {
        CPy_DECREF(self->_args);
    }
    PyObject *tmp;
    if (likely(PyList_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("list", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_args = tmp;
    return 0;
}

static int
ops___MethodCall_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___MethodCall_setup(PyTypeObject *type);
PyObject *CPyDef_ops___MethodCall(PyObject *cpy_r_obj, PyObject *cpy_r_method, PyObject *cpy_r_args, CPyTagged cpy_r_line);

static PyObject *
ops___MethodCall_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___MethodCall) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___MethodCall_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___MethodCall_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___MethodCall_traverse(mypyc___ir___ops___MethodCallObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    Py_VISIT(self->_obj);
    Py_VISIT(self->_method);
    Py_VISIT(self->_args);
    Py_VISIT(self->_receiver_type);
    return 0;
}

static int
ops___MethodCall_clear(mypyc___ir___ops___MethodCallObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    Py_CLEAR(self->_obj);
    Py_CLEAR(self->_method);
    Py_CLEAR(self->_args);
    Py_CLEAR(self->_receiver_type);
    return 0;
}

static void
ops___MethodCall_dealloc(mypyc___ir___ops___MethodCallObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___MethodCall_dealloc)
    ops___MethodCall_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___MethodCall_vtable[16];
static bool
CPyDef_ops___MethodCall_trait_vtable_setup(void)
{
    CPyVTableItem ops___MethodCall_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___MethodCall_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___MethodCall_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___MethodCall___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___MethodCall___accept,
        (CPyVTableItem)CPyDef_ops___MethodCall_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___MethodCall_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___MethodCall_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___MethodCall_____init__,
        (CPyVTableItem)CPyDef_ops___MethodCall___sources,
        (CPyVTableItem)CPyDef_ops___MethodCall___accept,
        (CPyVTableItem)CPyDef_ops___MethodCall_____mypyc_defaults_setup,
    };
    memcpy(ops___MethodCall_vtable, ops___MethodCall_vtable_scratch, sizeof(ops___MethodCall_vtable));
    return 1;
}

static PyObject *
ops___MethodCall_get_obj(mypyc___ir___ops___MethodCallObject *self, void *closure);
static int
ops___MethodCall_set_obj(mypyc___ir___ops___MethodCallObject *self, PyObject *value, void *closure);
static PyObject *
ops___MethodCall_get_method(mypyc___ir___ops___MethodCallObject *self, void *closure);
static int
ops___MethodCall_set_method(mypyc___ir___ops___MethodCallObject *self, PyObject *value, void *closure);
static PyObject *
ops___MethodCall_get_args(mypyc___ir___ops___MethodCallObject *self, void *closure);
static int
ops___MethodCall_set_args(mypyc___ir___ops___MethodCallObject *self, PyObject *value, void *closure);
static PyObject *
ops___MethodCall_get_receiver_type(mypyc___ir___ops___MethodCallObject *self, void *closure);
static int
ops___MethodCall_set_receiver_type(mypyc___ir___ops___MethodCallObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___MethodCall_getseters[] = {
    {"obj",
     (getter)ops___MethodCall_get_obj, (setter)ops___MethodCall_set_obj,
     NULL, NULL},
    {"method",
     (getter)ops___MethodCall_get_method, (setter)ops___MethodCall_set_method,
     NULL, NULL},
    {"args",
     (getter)ops___MethodCall_get_args, (setter)ops___MethodCall_set_args,
     NULL, NULL},
    {"receiver_type",
     (getter)ops___MethodCall_get_receiver_type, (setter)ops___MethodCall_set_receiver_type,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___MethodCall_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___MethodCall_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___MethodCall___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___MethodCall___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___MethodCall_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___MethodCall_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "MethodCall",
    .tp_new = ops___MethodCall_new,
    .tp_dealloc = (destructor)ops___MethodCall_dealloc,
    .tp_traverse = (traverseproc)ops___MethodCall_traverse,
    .tp_clear = (inquiry)ops___MethodCall_clear,
    .tp_getset = ops___MethodCall_getseters,
    .tp_methods = ops___MethodCall_methods,
    .tp_init = ops___MethodCall_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___MethodCallObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___MethodCall_template = &CPyType_ops___MethodCall_template_;

static PyObject *
ops___MethodCall_setup(PyTypeObject *type)
{
    mypyc___ir___ops___MethodCallObject *self;
    self = (mypyc___ir___ops___MethodCallObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___MethodCall_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___MethodCall_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___MethodCall(PyObject *cpy_r_obj, PyObject *cpy_r_method, PyObject *cpy_r_args, CPyTagged cpy_r_line)
{
    PyObject *self = ops___MethodCall_setup(CPyType_ops___MethodCall);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___MethodCall_____init__(self, cpy_r_obj, cpy_r_method, cpy_r_args, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___MethodCall_get_obj(mypyc___ir___ops___MethodCallObject *self, void *closure)
{
    if (unlikely(self->_obj == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'obj' of 'MethodCall' undefined");
        return NULL;
    }
    CPy_INCREF(self->_obj);
    PyObject *retval = self->_obj;
    return retval;
}

static int
ops___MethodCall_set_obj(mypyc___ir___ops___MethodCallObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'MethodCall' object attribute 'obj' cannot be deleted");
        return -1;
    }
    if (self->_obj != NULL) {
        CPy_DECREF(self->_obj);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_obj = tmp;
    return 0;
}

static PyObject *
ops___MethodCall_get_method(mypyc___ir___ops___MethodCallObject *self, void *closure)
{
    if (unlikely(self->_method == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'method' of 'MethodCall' undefined");
        return NULL;
    }
    CPy_INCREF(self->_method);
    PyObject *retval = self->_method;
    return retval;
}

static int
ops___MethodCall_set_method(mypyc___ir___ops___MethodCallObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'MethodCall' object attribute 'method' cannot be deleted");
        return -1;
    }
    if (self->_method != NULL) {
        CPy_DECREF(self->_method);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_method = tmp;
    return 0;
}

static PyObject *
ops___MethodCall_get_args(mypyc___ir___ops___MethodCallObject *self, void *closure)
{
    if (unlikely(self->_args == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'args' of 'MethodCall' undefined");
        return NULL;
    }
    CPy_INCREF(self->_args);
    PyObject *retval = self->_args;
    return retval;
}

static int
ops___MethodCall_set_args(mypyc___ir___ops___MethodCallObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'MethodCall' object attribute 'args' cannot be deleted");
        return -1;
    }
    if (self->_args != NULL) {
        CPy_DECREF(self->_args);
    }
    PyObject *tmp;
    if (likely(PyList_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("list", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_args = tmp;
    return 0;
}

static PyObject *
ops___MethodCall_get_receiver_type(mypyc___ir___ops___MethodCallObject *self, void *closure)
{
    if (unlikely(self->_receiver_type == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'receiver_type' of 'MethodCall' undefined");
        return NULL;
    }
    CPy_INCREF(self->_receiver_type);
    PyObject *retval = self->_receiver_type;
    return retval;
}

static int
ops___MethodCall_set_receiver_type(mypyc___ir___ops___MethodCallObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'MethodCall' object attribute 'receiver_type' cannot be deleted");
        return -1;
    }
    if (self->_receiver_type != NULL) {
        CPy_DECREF(self->_receiver_type);
    }
    PyObject *tmp;
    if (likely(Py_TYPE(value) == CPyType_rtypes___RInstance))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RInstance", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_receiver_type = tmp;
    return 0;
}

static int
ops___LoadErrorValue_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___LoadErrorValue_setup(PyTypeObject *type);
PyObject *CPyDef_ops___LoadErrorValue(PyObject *cpy_r_rtype, CPyTagged cpy_r_line, char cpy_r_is_borrowed, char cpy_r_undefines);

static PyObject *
ops___LoadErrorValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___LoadErrorValue) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___LoadErrorValue_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___LoadErrorValue_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___LoadErrorValue_traverse(mypyc___ir___ops___LoadErrorValueObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    return 0;
}

static int
ops___LoadErrorValue_clear(mypyc___ir___ops___LoadErrorValueObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    return 0;
}

static void
ops___LoadErrorValue_dealloc(mypyc___ir___ops___LoadErrorValueObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___LoadErrorValue_dealloc)
    ops___LoadErrorValue_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___LoadErrorValue_vtable[16];
static bool
CPyDef_ops___LoadErrorValue_trait_vtable_setup(void)
{
    CPyVTableItem ops___LoadErrorValue_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___LoadErrorValue_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadErrorValue_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadErrorValue___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___LoadErrorValue___accept,
        (CPyVTableItem)CPyDef_ops___LoadErrorValue_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadErrorValue_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadErrorValue_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadErrorValue_____init__,
        (CPyVTableItem)CPyDef_ops___LoadErrorValue___sources,
        (CPyVTableItem)CPyDef_ops___LoadErrorValue___accept,
        (CPyVTableItem)CPyDef_ops___LoadErrorValue_____mypyc_defaults_setup,
    };
    memcpy(ops___LoadErrorValue_vtable, ops___LoadErrorValue_vtable_scratch, sizeof(ops___LoadErrorValue_vtable));
    return 1;
}

static PyObject *
ops___LoadErrorValue_get_error_kind(mypyc___ir___ops___LoadErrorValueObject *self, void *closure);
static int
ops___LoadErrorValue_set_error_kind(mypyc___ir___ops___LoadErrorValueObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadErrorValue_get_undefines(mypyc___ir___ops___LoadErrorValueObject *self, void *closure);
static int
ops___LoadErrorValue_set_undefines(mypyc___ir___ops___LoadErrorValueObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___LoadErrorValue_getseters[] = {
    {"error_kind",
     (getter)ops___LoadErrorValue_get_error_kind, (setter)ops___LoadErrorValue_set_error_kind,
     NULL, NULL},
    {"undefines",
     (getter)ops___LoadErrorValue_get_undefines, (setter)ops___LoadErrorValue_set_undefines,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___LoadErrorValue_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___LoadErrorValue_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___LoadErrorValue___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___LoadErrorValue___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___LoadErrorValue_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___LoadErrorValue_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "LoadErrorValue",
    .tp_new = ops___LoadErrorValue_new,
    .tp_dealloc = (destructor)ops___LoadErrorValue_dealloc,
    .tp_traverse = (traverseproc)ops___LoadErrorValue_traverse,
    .tp_clear = (inquiry)ops___LoadErrorValue_clear,
    .tp_getset = ops___LoadErrorValue_getseters,
    .tp_methods = ops___LoadErrorValue_methods,
    .tp_init = ops___LoadErrorValue_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___LoadErrorValueObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___LoadErrorValue_template = &CPyType_ops___LoadErrorValue_template_;

static PyObject *
ops___LoadErrorValue_setup(PyTypeObject *type)
{
    mypyc___ir___ops___LoadErrorValueObject *self;
    self = (mypyc___ir___ops___LoadErrorValueObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___LoadErrorValue_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_undefines = 2;
    if (CPyDef_ops___LoadErrorValue_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___LoadErrorValue(PyObject *cpy_r_rtype, CPyTagged cpy_r_line, char cpy_r_is_borrowed, char cpy_r_undefines)
{
    PyObject *self = ops___LoadErrorValue_setup(CPyType_ops___LoadErrorValue);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___LoadErrorValue_____init__(self, cpy_r_rtype, cpy_r_line, cpy_r_is_borrowed, cpy_r_undefines);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___LoadErrorValue_get_error_kind(mypyc___ir___ops___LoadErrorValueObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'LoadErrorValue' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___LoadErrorValue_set_error_kind(mypyc___ir___ops___LoadErrorValueObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadErrorValue' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___LoadErrorValue_get_undefines(mypyc___ir___ops___LoadErrorValueObject *self, void *closure)
{
    PyObject *retval = self->_undefines ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___LoadErrorValue_set_undefines(mypyc___ir___ops___LoadErrorValueObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadErrorValue' object attribute 'undefines' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_undefines = tmp;
    return 0;
}

static int
ops___LoadLiteral_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___LoadLiteral_setup(PyTypeObject *type);
PyObject *CPyDef_ops___LoadLiteral(PyObject *cpy_r_value, PyObject *cpy_r_rtype);

static PyObject *
ops___LoadLiteral_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___LoadLiteral) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___LoadLiteral_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___LoadLiteral_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___LoadLiteral_traverse(mypyc___ir___ops___LoadLiteralObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_value);
    return 0;
}

static int
ops___LoadLiteral_clear(mypyc___ir___ops___LoadLiteralObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_value);
    return 0;
}

static void
ops___LoadLiteral_dealloc(mypyc___ir___ops___LoadLiteralObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___LoadLiteral_dealloc)
    ops___LoadLiteral_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___LoadLiteral_vtable[16];
static bool
CPyDef_ops___LoadLiteral_trait_vtable_setup(void)
{
    CPyVTableItem ops___LoadLiteral_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___LoadLiteral_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadLiteral_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadLiteral___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___LoadLiteral___accept,
        (CPyVTableItem)CPyDef_ops___LoadLiteral_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadLiteral_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadLiteral_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadLiteral_____init__,
        (CPyVTableItem)CPyDef_ops___LoadLiteral___sources,
        (CPyVTableItem)CPyDef_ops___LoadLiteral___accept,
        (CPyVTableItem)CPyDef_ops___LoadLiteral_____mypyc_defaults_setup,
    };
    memcpy(ops___LoadLiteral_vtable, ops___LoadLiteral_vtable_scratch, sizeof(ops___LoadLiteral_vtable));
    return 1;
}

static PyObject *
ops___LoadLiteral_get_error_kind(mypyc___ir___ops___LoadLiteralObject *self, void *closure);
static int
ops___LoadLiteral_set_error_kind(mypyc___ir___ops___LoadLiteralObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadLiteral_get_is_borrowed(mypyc___ir___ops___LoadLiteralObject *self, void *closure);
static int
ops___LoadLiteral_set_is_borrowed(mypyc___ir___ops___LoadLiteralObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadLiteral_get_value(mypyc___ir___ops___LoadLiteralObject *self, void *closure);
static int
ops___LoadLiteral_set_value(mypyc___ir___ops___LoadLiteralObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___LoadLiteral_getseters[] = {
    {"error_kind",
     (getter)ops___LoadLiteral_get_error_kind, (setter)ops___LoadLiteral_set_error_kind,
     NULL, NULL},
    {"is_borrowed",
     (getter)ops___LoadLiteral_get_is_borrowed, (setter)ops___LoadLiteral_set_is_borrowed,
     NULL, NULL},
    {"value",
     (getter)ops___LoadLiteral_get_value, (setter)ops___LoadLiteral_set_value,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___LoadLiteral_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___LoadLiteral_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___LoadLiteral___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___LoadLiteral___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___LoadLiteral_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___LoadLiteral_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "LoadLiteral",
    .tp_new = ops___LoadLiteral_new,
    .tp_dealloc = (destructor)ops___LoadLiteral_dealloc,
    .tp_traverse = (traverseproc)ops___LoadLiteral_traverse,
    .tp_clear = (inquiry)ops___LoadLiteral_clear,
    .tp_getset = ops___LoadLiteral_getseters,
    .tp_methods = ops___LoadLiteral_methods,
    .tp_init = ops___LoadLiteral_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___LoadLiteralObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___LoadLiteral_template = &CPyType_ops___LoadLiteral_template_;

static PyObject *
ops___LoadLiteral_setup(PyTypeObject *type)
{
    mypyc___ir___ops___LoadLiteralObject *self;
    self = (mypyc___ir___ops___LoadLiteralObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___LoadLiteral_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_is_borrowed = 2;
    if (CPyDef_ops___LoadLiteral_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___LoadLiteral(PyObject *cpy_r_value, PyObject *cpy_r_rtype)
{
    PyObject *self = ops___LoadLiteral_setup(CPyType_ops___LoadLiteral);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___LoadLiteral_____init__(self, cpy_r_value, cpy_r_rtype);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___LoadLiteral_get_error_kind(mypyc___ir___ops___LoadLiteralObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'LoadLiteral' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___LoadLiteral_set_error_kind(mypyc___ir___ops___LoadLiteralObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadLiteral' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___LoadLiteral_get_is_borrowed(mypyc___ir___ops___LoadLiteralObject *self, void *closure)
{
    PyObject *retval = self->_is_borrowed ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___LoadLiteral_set_is_borrowed(mypyc___ir___ops___LoadLiteralObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadLiteral' object attribute 'is_borrowed' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_is_borrowed = tmp;
    return 0;
}

static PyObject *
ops___LoadLiteral_get_value(mypyc___ir___ops___LoadLiteralObject *self, void *closure)
{
    if (unlikely(self->_value == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'value' of 'LoadLiteral' undefined");
        return NULL;
    }
    CPy_INCREF(self->_value);
    PyObject *retval = self->_value;
    return retval;
}

static int
ops___LoadLiteral_set_value(mypyc___ir___ops___LoadLiteralObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadLiteral' object attribute 'value' cannot be deleted");
        return -1;
    }
    if (self->_value != NULL) {
        CPy_DECREF(self->_value);
    }
    PyObject *tmp;
    if (PyUnicode_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9859;
    if (PyBytes_Check(value) || PyByteArray_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9859;
    if (PyLong_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9859;
    if (PyBool_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9859;
    if (CPyFloat_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9859;
    tmp = value;
    if (tmp != NULL) goto __LL9859;
    if (PyTuple_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9859;
    if (value == Py_None)
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9859;
    CPy_TypeError("union[str, bytes, int, bool, float, object, tuple, None]", value); 
    tmp = NULL;
__LL9859: ;
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_value = tmp;
    return 0;
}

static int
ops___GetAttr_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___GetAttr_setup(PyTypeObject *type);
PyObject *CPyDef_ops___GetAttr(PyObject *cpy_r_obj, PyObject *cpy_r_attr, CPyTagged cpy_r_line, char cpy_r_borrow);

static PyObject *
ops___GetAttr_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___GetAttr) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___GetAttr_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___GetAttr_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___GetAttr_traverse(mypyc___ir___ops___GetAttrObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_obj);
    Py_VISIT(self->_attr);
    Py_VISIT(self->_class_type);
    return 0;
}

static int
ops___GetAttr_clear(mypyc___ir___ops___GetAttrObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_obj);
    Py_CLEAR(self->_attr);
    Py_CLEAR(self->_class_type);
    return 0;
}

static void
ops___GetAttr_dealloc(mypyc___ir___ops___GetAttrObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___GetAttr_dealloc)
    ops___GetAttr_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___GetAttr_vtable[16];
static bool
CPyDef_ops___GetAttr_trait_vtable_setup(void)
{
    CPyVTableItem ops___GetAttr_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___GetAttr_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___GetAttr_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___GetAttr___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___GetAttr___accept,
        (CPyVTableItem)CPyDef_ops___GetAttr_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___GetAttr_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___GetAttr_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___GetAttr_____init__,
        (CPyVTableItem)CPyDef_ops___GetAttr___sources,
        (CPyVTableItem)CPyDef_ops___GetAttr___accept,
        (CPyVTableItem)CPyDef_ops___GetAttr_____mypyc_defaults_setup,
    };
    memcpy(ops___GetAttr_vtable, ops___GetAttr_vtable_scratch, sizeof(ops___GetAttr_vtable));
    return 1;
}

static PyObject *
ops___GetAttr_get_error_kind(mypyc___ir___ops___GetAttrObject *self, void *closure);
static int
ops___GetAttr_set_error_kind(mypyc___ir___ops___GetAttrObject *self, PyObject *value, void *closure);
static PyObject *
ops___GetAttr_get_obj(mypyc___ir___ops___GetAttrObject *self, void *closure);
static int
ops___GetAttr_set_obj(mypyc___ir___ops___GetAttrObject *self, PyObject *value, void *closure);
static PyObject *
ops___GetAttr_get_attr(mypyc___ir___ops___GetAttrObject *self, void *closure);
static int
ops___GetAttr_set_attr(mypyc___ir___ops___GetAttrObject *self, PyObject *value, void *closure);
static PyObject *
ops___GetAttr_get_class_type(mypyc___ir___ops___GetAttrObject *self, void *closure);
static int
ops___GetAttr_set_class_type(mypyc___ir___ops___GetAttrObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___GetAttr_getseters[] = {
    {"error_kind",
     (getter)ops___GetAttr_get_error_kind, (setter)ops___GetAttr_set_error_kind,
     NULL, NULL},
    {"obj",
     (getter)ops___GetAttr_get_obj, (setter)ops___GetAttr_set_obj,
     NULL, NULL},
    {"attr",
     (getter)ops___GetAttr_get_attr, (setter)ops___GetAttr_set_attr,
     NULL, NULL},
    {"class_type",
     (getter)ops___GetAttr_get_class_type, (setter)ops___GetAttr_set_class_type,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___GetAttr_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___GetAttr_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___GetAttr___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___GetAttr___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___GetAttr_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___GetAttr_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "GetAttr",
    .tp_new = ops___GetAttr_new,
    .tp_dealloc = (destructor)ops___GetAttr_dealloc,
    .tp_traverse = (traverseproc)ops___GetAttr_traverse,
    .tp_clear = (inquiry)ops___GetAttr_clear,
    .tp_getset = ops___GetAttr_getseters,
    .tp_methods = ops___GetAttr_methods,
    .tp_init = ops___GetAttr_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___GetAttrObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___GetAttr_template = &CPyType_ops___GetAttr_template_;

static PyObject *
ops___GetAttr_setup(PyTypeObject *type)
{
    mypyc___ir___ops___GetAttrObject *self;
    self = (mypyc___ir___ops___GetAttrObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___GetAttr_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___GetAttr_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___GetAttr(PyObject *cpy_r_obj, PyObject *cpy_r_attr, CPyTagged cpy_r_line, char cpy_r_borrow)
{
    PyObject *self = ops___GetAttr_setup(CPyType_ops___GetAttr);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___GetAttr_____init__(self, cpy_r_obj, cpy_r_attr, cpy_r_line, cpy_r_borrow);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___GetAttr_get_error_kind(mypyc___ir___ops___GetAttrObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'GetAttr' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___GetAttr_set_error_kind(mypyc___ir___ops___GetAttrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'GetAttr' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___GetAttr_get_obj(mypyc___ir___ops___GetAttrObject *self, void *closure)
{
    if (unlikely(self->_obj == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'obj' of 'GetAttr' undefined");
        return NULL;
    }
    CPy_INCREF(self->_obj);
    PyObject *retval = self->_obj;
    return retval;
}

static int
ops___GetAttr_set_obj(mypyc___ir___ops___GetAttrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'GetAttr' object attribute 'obj' cannot be deleted");
        return -1;
    }
    if (self->_obj != NULL) {
        CPy_DECREF(self->_obj);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_obj = tmp;
    return 0;
}

static PyObject *
ops___GetAttr_get_attr(mypyc___ir___ops___GetAttrObject *self, void *closure)
{
    if (unlikely(self->_attr == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'attr' of 'GetAttr' undefined");
        return NULL;
    }
    CPy_INCREF(self->_attr);
    PyObject *retval = self->_attr;
    return retval;
}

static int
ops___GetAttr_set_attr(mypyc___ir___ops___GetAttrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'GetAttr' object attribute 'attr' cannot be deleted");
        return -1;
    }
    if (self->_attr != NULL) {
        CPy_DECREF(self->_attr);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_attr = tmp;
    return 0;
}

static PyObject *
ops___GetAttr_get_class_type(mypyc___ir___ops___GetAttrObject *self, void *closure)
{
    if (unlikely(self->_class_type == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'class_type' of 'GetAttr' undefined");
        return NULL;
    }
    CPy_INCREF(self->_class_type);
    PyObject *retval = self->_class_type;
    return retval;
}

static int
ops___GetAttr_set_class_type(mypyc___ir___ops___GetAttrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'GetAttr' object attribute 'class_type' cannot be deleted");
        return -1;
    }
    if (self->_class_type != NULL) {
        CPy_DECREF(self->_class_type);
    }
    PyObject *tmp;
    if (likely(Py_TYPE(value) == CPyType_rtypes___RInstance))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RInstance", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_class_type = tmp;
    return 0;
}

static int
ops___SetAttr_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___SetAttr_setup(PyTypeObject *type);
PyObject *CPyDef_ops___SetAttr(PyObject *cpy_r_obj, PyObject *cpy_r_attr, PyObject *cpy_r_src, CPyTagged cpy_r_line);

static PyObject *
ops___SetAttr_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___SetAttr) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___SetAttr_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___SetAttr_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___SetAttr_traverse(mypyc___ir___ops___SetAttrObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_obj);
    Py_VISIT(self->_attr);
    Py_VISIT(self->_src);
    Py_VISIT(self->_class_type);
    return 0;
}

static int
ops___SetAttr_clear(mypyc___ir___ops___SetAttrObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_obj);
    Py_CLEAR(self->_attr);
    Py_CLEAR(self->_src);
    Py_CLEAR(self->_class_type);
    return 0;
}

static void
ops___SetAttr_dealloc(mypyc___ir___ops___SetAttrObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___SetAttr_dealloc)
    ops___SetAttr_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___SetAttr_vtable[18];
static bool
CPyDef_ops___SetAttr_trait_vtable_setup(void)
{
    CPyVTableItem ops___SetAttr_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___SetAttr_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___SetAttr_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___SetAttr___sources,
        (CPyVTableItem)CPyDef_ops___SetAttr___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___SetAttr___accept,
        (CPyVTableItem)CPyDef_ops___SetAttr_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___SetAttr_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___SetAttr_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___SetAttr_____init__,
        (CPyVTableItem)CPyDef_ops___SetAttr___mark_as_initializer,
        (CPyVTableItem)CPyDef_ops___SetAttr___sources,
        (CPyVTableItem)CPyDef_ops___SetAttr___stolen,
        (CPyVTableItem)CPyDef_ops___SetAttr___accept,
        (CPyVTableItem)CPyDef_ops___SetAttr_____mypyc_defaults_setup,
    };
    memcpy(ops___SetAttr_vtable, ops___SetAttr_vtable_scratch, sizeof(ops___SetAttr_vtable));
    return 1;
}

static PyObject *
ops___SetAttr_get_error_kind(mypyc___ir___ops___SetAttrObject *self, void *closure);
static int
ops___SetAttr_set_error_kind(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure);
static PyObject *
ops___SetAttr_get_obj(mypyc___ir___ops___SetAttrObject *self, void *closure);
static int
ops___SetAttr_set_obj(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure);
static PyObject *
ops___SetAttr_get_attr(mypyc___ir___ops___SetAttrObject *self, void *closure);
static int
ops___SetAttr_set_attr(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure);
static PyObject *
ops___SetAttr_get_src(mypyc___ir___ops___SetAttrObject *self, void *closure);
static int
ops___SetAttr_set_src(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure);
static PyObject *
ops___SetAttr_get_class_type(mypyc___ir___ops___SetAttrObject *self, void *closure);
static int
ops___SetAttr_set_class_type(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure);
static PyObject *
ops___SetAttr_get_is_init(mypyc___ir___ops___SetAttrObject *self, void *closure);
static int
ops___SetAttr_set_is_init(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___SetAttr_getseters[] = {
    {"error_kind",
     (getter)ops___SetAttr_get_error_kind, (setter)ops___SetAttr_set_error_kind,
     NULL, NULL},
    {"obj",
     (getter)ops___SetAttr_get_obj, (setter)ops___SetAttr_set_obj,
     NULL, NULL},
    {"attr",
     (getter)ops___SetAttr_get_attr, (setter)ops___SetAttr_set_attr,
     NULL, NULL},
    {"src",
     (getter)ops___SetAttr_get_src, (setter)ops___SetAttr_set_src,
     NULL, NULL},
    {"class_type",
     (getter)ops___SetAttr_get_class_type, (setter)ops___SetAttr_set_class_type,
     NULL, NULL},
    {"is_init",
     (getter)ops___SetAttr_get_is_init, (setter)ops___SetAttr_set_is_init,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___SetAttr_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___SetAttr_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"mark_as_initializer",
     (PyCFunction)CPyPy_ops___SetAttr___mark_as_initializer,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___SetAttr___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"stolen",
     (PyCFunction)CPyPy_ops___SetAttr___stolen,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___SetAttr___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___SetAttr_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___SetAttr_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "SetAttr",
    .tp_new = ops___SetAttr_new,
    .tp_dealloc = (destructor)ops___SetAttr_dealloc,
    .tp_traverse = (traverseproc)ops___SetAttr_traverse,
    .tp_clear = (inquiry)ops___SetAttr_clear,
    .tp_getset = ops___SetAttr_getseters,
    .tp_methods = ops___SetAttr_methods,
    .tp_init = ops___SetAttr_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___SetAttrObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___SetAttr_template = &CPyType_ops___SetAttr_template_;

static PyObject *
ops___SetAttr_setup(PyTypeObject *type)
{
    mypyc___ir___ops___SetAttrObject *self;
    self = (mypyc___ir___ops___SetAttrObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___SetAttr_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_is_init = 2;
    if (CPyDef_ops___SetAttr_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___SetAttr(PyObject *cpy_r_obj, PyObject *cpy_r_attr, PyObject *cpy_r_src, CPyTagged cpy_r_line)
{
    PyObject *self = ops___SetAttr_setup(CPyType_ops___SetAttr);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___SetAttr_____init__(self, cpy_r_obj, cpy_r_attr, cpy_r_src, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___SetAttr_get_error_kind(mypyc___ir___ops___SetAttrObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'SetAttr' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___SetAttr_set_error_kind(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'SetAttr' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___SetAttr_get_obj(mypyc___ir___ops___SetAttrObject *self, void *closure)
{
    if (unlikely(self->_obj == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'obj' of 'SetAttr' undefined");
        return NULL;
    }
    CPy_INCREF(self->_obj);
    PyObject *retval = self->_obj;
    return retval;
}

static int
ops___SetAttr_set_obj(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'SetAttr' object attribute 'obj' cannot be deleted");
        return -1;
    }
    if (self->_obj != NULL) {
        CPy_DECREF(self->_obj);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_obj = tmp;
    return 0;
}

static PyObject *
ops___SetAttr_get_attr(mypyc___ir___ops___SetAttrObject *self, void *closure)
{
    if (unlikely(self->_attr == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'attr' of 'SetAttr' undefined");
        return NULL;
    }
    CPy_INCREF(self->_attr);
    PyObject *retval = self->_attr;
    return retval;
}

static int
ops___SetAttr_set_attr(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'SetAttr' object attribute 'attr' cannot be deleted");
        return -1;
    }
    if (self->_attr != NULL) {
        CPy_DECREF(self->_attr);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_attr = tmp;
    return 0;
}

static PyObject *
ops___SetAttr_get_src(mypyc___ir___ops___SetAttrObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'SetAttr' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___SetAttr_set_src(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'SetAttr' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static PyObject *
ops___SetAttr_get_class_type(mypyc___ir___ops___SetAttrObject *self, void *closure)
{
    if (unlikely(self->_class_type == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'class_type' of 'SetAttr' undefined");
        return NULL;
    }
    CPy_INCREF(self->_class_type);
    PyObject *retval = self->_class_type;
    return retval;
}

static int
ops___SetAttr_set_class_type(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'SetAttr' object attribute 'class_type' cannot be deleted");
        return -1;
    }
    if (self->_class_type != NULL) {
        CPy_DECREF(self->_class_type);
    }
    PyObject *tmp;
    if (likely(Py_TYPE(value) == CPyType_rtypes___RInstance))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RInstance", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_class_type = tmp;
    return 0;
}

static PyObject *
ops___SetAttr_get_is_init(mypyc___ir___ops___SetAttrObject *self, void *closure)
{
    PyObject *retval = self->_is_init ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___SetAttr_set_is_init(mypyc___ir___ops___SetAttrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'SetAttr' object attribute 'is_init' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_is_init = tmp;
    return 0;
}

static int
ops___LoadStatic_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___LoadStatic_setup(PyTypeObject *type);
PyObject *CPyDef_ops___LoadStatic(PyObject *cpy_r_type, PyObject *cpy_r_identifier, PyObject *cpy_r_module_name, PyObject *cpy_r_namespace, CPyTagged cpy_r_line, PyObject *cpy_r_ann);

static PyObject *
ops___LoadStatic_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___LoadStatic) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___LoadStatic_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___LoadStatic_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___LoadStatic_traverse(mypyc___ir___ops___LoadStaticObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_identifier);
    Py_VISIT(self->_module_name);
    Py_VISIT(self->_namespace);
    Py_VISIT(self->_ann);
    return 0;
}

static int
ops___LoadStatic_clear(mypyc___ir___ops___LoadStaticObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_identifier);
    Py_CLEAR(self->_module_name);
    Py_CLEAR(self->_namespace);
    Py_CLEAR(self->_ann);
    return 0;
}

static void
ops___LoadStatic_dealloc(mypyc___ir___ops___LoadStaticObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___LoadStatic_dealloc)
    ops___LoadStatic_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___LoadStatic_vtable[16];
static bool
CPyDef_ops___LoadStatic_trait_vtable_setup(void)
{
    CPyVTableItem ops___LoadStatic_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___LoadStatic_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadStatic_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadStatic___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___LoadStatic___accept,
        (CPyVTableItem)CPyDef_ops___LoadStatic_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadStatic_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadStatic_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadStatic_____init__,
        (CPyVTableItem)CPyDef_ops___LoadStatic___sources,
        (CPyVTableItem)CPyDef_ops___LoadStatic___accept,
        (CPyVTableItem)CPyDef_ops___LoadStatic_____mypyc_defaults_setup,
    };
    memcpy(ops___LoadStatic_vtable, ops___LoadStatic_vtable_scratch, sizeof(ops___LoadStatic_vtable));
    return 1;
}

static PyObject *
ops___LoadStatic_get_error_kind(mypyc___ir___ops___LoadStaticObject *self, void *closure);
static int
ops___LoadStatic_set_error_kind(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadStatic_get_is_borrowed(mypyc___ir___ops___LoadStaticObject *self, void *closure);
static int
ops___LoadStatic_set_is_borrowed(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadStatic_get_identifier(mypyc___ir___ops___LoadStaticObject *self, void *closure);
static int
ops___LoadStatic_set_identifier(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadStatic_get_module_name(mypyc___ir___ops___LoadStaticObject *self, void *closure);
static int
ops___LoadStatic_set_module_name(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadStatic_get_namespace(mypyc___ir___ops___LoadStaticObject *self, void *closure);
static int
ops___LoadStatic_set_namespace(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadStatic_get_ann(mypyc___ir___ops___LoadStaticObject *self, void *closure);
static int
ops___LoadStatic_set_ann(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___LoadStatic_getseters[] = {
    {"error_kind",
     (getter)ops___LoadStatic_get_error_kind, (setter)ops___LoadStatic_set_error_kind,
     NULL, NULL},
    {"is_borrowed",
     (getter)ops___LoadStatic_get_is_borrowed, (setter)ops___LoadStatic_set_is_borrowed,
     NULL, NULL},
    {"identifier",
     (getter)ops___LoadStatic_get_identifier, (setter)ops___LoadStatic_set_identifier,
     NULL, NULL},
    {"module_name",
     (getter)ops___LoadStatic_get_module_name, (setter)ops___LoadStatic_set_module_name,
     NULL, NULL},
    {"namespace",
     (getter)ops___LoadStatic_get_namespace, (setter)ops___LoadStatic_set_namespace,
     NULL, NULL},
    {"ann",
     (getter)ops___LoadStatic_get_ann, (setter)ops___LoadStatic_set_ann,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___LoadStatic_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___LoadStatic_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___LoadStatic___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___LoadStatic___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___LoadStatic_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___LoadStatic_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "LoadStatic",
    .tp_new = ops___LoadStatic_new,
    .tp_dealloc = (destructor)ops___LoadStatic_dealloc,
    .tp_traverse = (traverseproc)ops___LoadStatic_traverse,
    .tp_clear = (inquiry)ops___LoadStatic_clear,
    .tp_getset = ops___LoadStatic_getseters,
    .tp_methods = ops___LoadStatic_methods,
    .tp_init = ops___LoadStatic_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___LoadStaticObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___LoadStatic_template = &CPyType_ops___LoadStatic_template_;

static PyObject *
ops___LoadStatic_setup(PyTypeObject *type)
{
    mypyc___ir___ops___LoadStaticObject *self;
    self = (mypyc___ir___ops___LoadStaticObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___LoadStatic_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_is_borrowed = 2;
    if (CPyDef_ops___LoadStatic_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___LoadStatic(PyObject *cpy_r_type, PyObject *cpy_r_identifier, PyObject *cpy_r_module_name, PyObject *cpy_r_namespace, CPyTagged cpy_r_line, PyObject *cpy_r_ann)
{
    PyObject *self = ops___LoadStatic_setup(CPyType_ops___LoadStatic);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___LoadStatic_____init__(self, cpy_r_type, cpy_r_identifier, cpy_r_module_name, cpy_r_namespace, cpy_r_line, cpy_r_ann);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___LoadStatic_get_error_kind(mypyc___ir___ops___LoadStaticObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'LoadStatic' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___LoadStatic_set_error_kind(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadStatic' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___LoadStatic_get_is_borrowed(mypyc___ir___ops___LoadStaticObject *self, void *closure)
{
    PyObject *retval = self->_is_borrowed ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___LoadStatic_set_is_borrowed(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadStatic' object attribute 'is_borrowed' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_is_borrowed = tmp;
    return 0;
}

static PyObject *
ops___LoadStatic_get_identifier(mypyc___ir___ops___LoadStaticObject *self, void *closure)
{
    if (unlikely(self->_identifier == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'identifier' of 'LoadStatic' undefined");
        return NULL;
    }
    CPy_INCREF(self->_identifier);
    PyObject *retval = self->_identifier;
    return retval;
}

static int
ops___LoadStatic_set_identifier(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadStatic' object attribute 'identifier' cannot be deleted");
        return -1;
    }
    if (self->_identifier != NULL) {
        CPy_DECREF(self->_identifier);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_identifier = tmp;
    return 0;
}

static PyObject *
ops___LoadStatic_get_module_name(mypyc___ir___ops___LoadStaticObject *self, void *closure)
{
    if (unlikely(self->_module_name == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'module_name' of 'LoadStatic' undefined");
        return NULL;
    }
    CPy_INCREF(self->_module_name);
    PyObject *retval = self->_module_name;
    return retval;
}

static int
ops___LoadStatic_set_module_name(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadStatic' object attribute 'module_name' cannot be deleted");
        return -1;
    }
    if (self->_module_name != NULL) {
        CPy_DECREF(self->_module_name);
    }
    PyObject *tmp;
    if (PyUnicode_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9860;
    if (value == Py_None)
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9860;
    CPy_TypeError("str or None", value); 
    tmp = NULL;
__LL9860: ;
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_module_name = tmp;
    return 0;
}

static PyObject *
ops___LoadStatic_get_namespace(mypyc___ir___ops___LoadStaticObject *self, void *closure)
{
    if (unlikely(self->_namespace == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'namespace' of 'LoadStatic' undefined");
        return NULL;
    }
    CPy_INCREF(self->_namespace);
    PyObject *retval = self->_namespace;
    return retval;
}

static int
ops___LoadStatic_set_namespace(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadStatic' object attribute 'namespace' cannot be deleted");
        return -1;
    }
    if (self->_namespace != NULL) {
        CPy_DECREF(self->_namespace);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_namespace = tmp;
    return 0;
}

static PyObject *
ops___LoadStatic_get_ann(mypyc___ir___ops___LoadStaticObject *self, void *closure)
{
    if (unlikely(self->_ann == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'ann' of 'LoadStatic' undefined");
        return NULL;
    }
    CPy_INCREF(self->_ann);
    PyObject *retval = self->_ann;
    return retval;
}

static int
ops___LoadStatic_set_ann(mypyc___ir___ops___LoadStaticObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadStatic' object attribute 'ann' cannot be deleted");
        return -1;
    }
    if (self->_ann != NULL) {
        CPy_DECREF(self->_ann);
    }
    PyObject *tmp = value;
    CPy_INCREF(tmp);
    self->_ann = tmp;
    return 0;
}

static int
ops___InitStatic_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___InitStatic_setup(PyTypeObject *type);
PyObject *CPyDef_ops___InitStatic(PyObject *cpy_r_value, PyObject *cpy_r_identifier, PyObject *cpy_r_module_name, PyObject *cpy_r_namespace, CPyTagged cpy_r_line);

static PyObject *
ops___InitStatic_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___InitStatic) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___InitStatic_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___InitStatic_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___InitStatic_traverse(mypyc___ir___ops___InitStaticObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_identifier);
    Py_VISIT(self->_module_name);
    Py_VISIT(self->_namespace);
    Py_VISIT(self->_value);
    return 0;
}

static int
ops___InitStatic_clear(mypyc___ir___ops___InitStaticObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_identifier);
    Py_CLEAR(self->_module_name);
    Py_CLEAR(self->_namespace);
    Py_CLEAR(self->_value);
    return 0;
}

static void
ops___InitStatic_dealloc(mypyc___ir___ops___InitStaticObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___InitStatic_dealloc)
    ops___InitStatic_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___InitStatic_vtable[16];
static bool
CPyDef_ops___InitStatic_trait_vtable_setup(void)
{
    CPyVTableItem ops___InitStatic_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___InitStatic_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___InitStatic_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___InitStatic___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___InitStatic___accept,
        (CPyVTableItem)CPyDef_ops___InitStatic_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___InitStatic_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___InitStatic_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___InitStatic_____init__,
        (CPyVTableItem)CPyDef_ops___InitStatic___sources,
        (CPyVTableItem)CPyDef_ops___InitStatic___accept,
        (CPyVTableItem)CPyDef_ops___InitStatic_____mypyc_defaults_setup,
    };
    memcpy(ops___InitStatic_vtable, ops___InitStatic_vtable_scratch, sizeof(ops___InitStatic_vtable));
    return 1;
}

static PyObject *
ops___InitStatic_get_error_kind(mypyc___ir___ops___InitStaticObject *self, void *closure);
static int
ops___InitStatic_set_error_kind(mypyc___ir___ops___InitStaticObject *self, PyObject *value, void *closure);
static PyObject *
ops___InitStatic_get_identifier(mypyc___ir___ops___InitStaticObject *self, void *closure);
static int
ops___InitStatic_set_identifier(mypyc___ir___ops___InitStaticObject *self, PyObject *value, void *closure);
static PyObject *
ops___InitStatic_get_module_name(mypyc___ir___ops___InitStaticObject *self, void *closure);
static int
ops___InitStatic_set_module_name(mypyc___ir___ops___InitStaticObject *self, PyObject *value, void *closure);
static PyObject *
ops___InitStatic_get_namespace(mypyc___ir___ops___InitStaticObject *self, void *closure);
static int
ops___InitStatic_set_namespace(mypyc___ir___ops___InitStaticObject *self, PyObject *value, void *closure);
static PyObject *
ops___InitStatic_get_value(mypyc___ir___ops___InitStaticObject *self, void *closure);
static int
ops___InitStatic_set_value(mypyc___ir___ops___InitStaticObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___InitStatic_getseters[] = {
    {"error_kind",
     (getter)ops___InitStatic_get_error_kind, (setter)ops___InitStatic_set_error_kind,
     NULL, NULL},
    {"identifier",
     (getter)ops___InitStatic_get_identifier, (setter)ops___InitStatic_set_identifier,
     NULL, NULL},
    {"module_name",
     (getter)ops___InitStatic_get_module_name, (setter)ops___InitStatic_set_module_name,
     NULL, NULL},
    {"namespace",
     (getter)ops___InitStatic_get_namespace, (setter)ops___InitStatic_set_namespace,
     NULL, NULL},
    {"value",
     (getter)ops___InitStatic_get_value, (setter)ops___InitStatic_set_value,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___InitStatic_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___InitStatic_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___InitStatic___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___InitStatic___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___InitStatic_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___InitStatic_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "InitStatic",
    .tp_new = ops___InitStatic_new,
    .tp_dealloc = (destructor)ops___InitStatic_dealloc,
    .tp_traverse = (traverseproc)ops___InitStatic_traverse,
    .tp_clear = (inquiry)ops___InitStatic_clear,
    .tp_getset = ops___InitStatic_getseters,
    .tp_methods = ops___InitStatic_methods,
    .tp_init = ops___InitStatic_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___InitStaticObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___InitStatic_template = &CPyType_ops___InitStatic_template_;

static PyObject *
ops___InitStatic_setup(PyTypeObject *type)
{
    mypyc___ir___ops___InitStaticObject *self;
    self = (mypyc___ir___ops___InitStaticObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___InitStatic_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___InitStatic_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___InitStatic(PyObject *cpy_r_value, PyObject *cpy_r_identifier, PyObject *cpy_r_module_name, PyObject *cpy_r_namespace, CPyTagged cpy_r_line)
{
    PyObject *self = ops___InitStatic_setup(CPyType_ops___InitStatic);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___InitStatic_____init__(self, cpy_r_value, cpy_r_identifier, cpy_r_module_name, cpy_r_namespace, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___InitStatic_get_error_kind(mypyc___ir___ops___InitStaticObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'InitStatic' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___InitStatic_set_error_kind(mypyc___ir___ops___InitStaticObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'InitStatic' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___InitStatic_get_identifier(mypyc___ir___ops___InitStaticObject *self, void *closure)
{
    if (unlikely(self->_identifier == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'identifier' of 'InitStatic' undefined");
        return NULL;
    }
    CPy_INCREF(self->_identifier);
    PyObject *retval = self->_identifier;
    return retval;
}

static int
ops___InitStatic_set_identifier(mypyc___ir___ops___InitStaticObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'InitStatic' object attribute 'identifier' cannot be deleted");
        return -1;
    }
    if (self->_identifier != NULL) {
        CPy_DECREF(self->_identifier);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_identifier = tmp;
    return 0;
}

static PyObject *
ops___InitStatic_get_module_name(mypyc___ir___ops___InitStaticObject *self, void *closure)
{
    if (unlikely(self->_module_name == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'module_name' of 'InitStatic' undefined");
        return NULL;
    }
    CPy_INCREF(self->_module_name);
    PyObject *retval = self->_module_name;
    return retval;
}

static int
ops___InitStatic_set_module_name(mypyc___ir___ops___InitStaticObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'InitStatic' object attribute 'module_name' cannot be deleted");
        return -1;
    }
    if (self->_module_name != NULL) {
        CPy_DECREF(self->_module_name);
    }
    PyObject *tmp;
    if (PyUnicode_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9861;
    if (value == Py_None)
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9861;
    CPy_TypeError("str or None", value); 
    tmp = NULL;
__LL9861: ;
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_module_name = tmp;
    return 0;
}

static PyObject *
ops___InitStatic_get_namespace(mypyc___ir___ops___InitStaticObject *self, void *closure)
{
    if (unlikely(self->_namespace == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'namespace' of 'InitStatic' undefined");
        return NULL;
    }
    CPy_INCREF(self->_namespace);
    PyObject *retval = self->_namespace;
    return retval;
}

static int
ops___InitStatic_set_namespace(mypyc___ir___ops___InitStaticObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'InitStatic' object attribute 'namespace' cannot be deleted");
        return -1;
    }
    if (self->_namespace != NULL) {
        CPy_DECREF(self->_namespace);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_namespace = tmp;
    return 0;
}

static PyObject *
ops___InitStatic_get_value(mypyc___ir___ops___InitStaticObject *self, void *closure)
{
    if (unlikely(self->_value == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'value' of 'InitStatic' undefined");
        return NULL;
    }
    CPy_INCREF(self->_value);
    PyObject *retval = self->_value;
    return retval;
}

static int
ops___InitStatic_set_value(mypyc___ir___ops___InitStaticObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'InitStatic' object attribute 'value' cannot be deleted");
        return -1;
    }
    if (self->_value != NULL) {
        CPy_DECREF(self->_value);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_value = tmp;
    return 0;
}

static int
ops___TupleSet_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___TupleSet_setup(PyTypeObject *type);
PyObject *CPyDef_ops___TupleSet(PyObject *cpy_r_items, CPyTagged cpy_r_line);

static PyObject *
ops___TupleSet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___TupleSet) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___TupleSet_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___TupleSet_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___TupleSet_traverse(mypyc___ir___ops___TupleSetObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_items);
    Py_VISIT(self->_tuple_type);
    return 0;
}

static int
ops___TupleSet_clear(mypyc___ir___ops___TupleSetObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_items);
    Py_CLEAR(self->_tuple_type);
    return 0;
}

static void
ops___TupleSet_dealloc(mypyc___ir___ops___TupleSetObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___TupleSet_dealloc)
    ops___TupleSet_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___TupleSet_vtable[16];
static bool
CPyDef_ops___TupleSet_trait_vtable_setup(void)
{
    CPyVTableItem ops___TupleSet_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___TupleSet_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___TupleSet_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___TupleSet___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___TupleSet___accept,
        (CPyVTableItem)CPyDef_ops___TupleSet_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___TupleSet_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___TupleSet_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___TupleSet_____init__,
        (CPyVTableItem)CPyDef_ops___TupleSet___sources,
        (CPyVTableItem)CPyDef_ops___TupleSet___accept,
        (CPyVTableItem)CPyDef_ops___TupleSet_____mypyc_defaults_setup,
    };
    memcpy(ops___TupleSet_vtable, ops___TupleSet_vtable_scratch, sizeof(ops___TupleSet_vtable));
    return 1;
}

static PyObject *
ops___TupleSet_get_error_kind(mypyc___ir___ops___TupleSetObject *self, void *closure);
static int
ops___TupleSet_set_error_kind(mypyc___ir___ops___TupleSetObject *self, PyObject *value, void *closure);
static PyObject *
ops___TupleSet_get_items(mypyc___ir___ops___TupleSetObject *self, void *closure);
static int
ops___TupleSet_set_items(mypyc___ir___ops___TupleSetObject *self, PyObject *value, void *closure);
static PyObject *
ops___TupleSet_get_tuple_type(mypyc___ir___ops___TupleSetObject *self, void *closure);
static int
ops___TupleSet_set_tuple_type(mypyc___ir___ops___TupleSetObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___TupleSet_getseters[] = {
    {"error_kind",
     (getter)ops___TupleSet_get_error_kind, (setter)ops___TupleSet_set_error_kind,
     NULL, NULL},
    {"items",
     (getter)ops___TupleSet_get_items, (setter)ops___TupleSet_set_items,
     NULL, NULL},
    {"tuple_type",
     (getter)ops___TupleSet_get_tuple_type, (setter)ops___TupleSet_set_tuple_type,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___TupleSet_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___TupleSet_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___TupleSet___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___TupleSet___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___TupleSet_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___TupleSet_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "TupleSet",
    .tp_new = ops___TupleSet_new,
    .tp_dealloc = (destructor)ops___TupleSet_dealloc,
    .tp_traverse = (traverseproc)ops___TupleSet_traverse,
    .tp_clear = (inquiry)ops___TupleSet_clear,
    .tp_getset = ops___TupleSet_getseters,
    .tp_methods = ops___TupleSet_methods,
    .tp_init = ops___TupleSet_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___TupleSetObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___TupleSet_template = &CPyType_ops___TupleSet_template_;

static PyObject *
ops___TupleSet_setup(PyTypeObject *type)
{
    mypyc___ir___ops___TupleSetObject *self;
    self = (mypyc___ir___ops___TupleSetObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___TupleSet_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___TupleSet_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___TupleSet(PyObject *cpy_r_items, CPyTagged cpy_r_line)
{
    PyObject *self = ops___TupleSet_setup(CPyType_ops___TupleSet);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___TupleSet_____init__(self, cpy_r_items, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___TupleSet_get_error_kind(mypyc___ir___ops___TupleSetObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'TupleSet' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___TupleSet_set_error_kind(mypyc___ir___ops___TupleSetObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'TupleSet' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___TupleSet_get_items(mypyc___ir___ops___TupleSetObject *self, void *closure)
{
    if (unlikely(self->_items == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'items' of 'TupleSet' undefined");
        return NULL;
    }
    CPy_INCREF(self->_items);
    PyObject *retval = self->_items;
    return retval;
}

static int
ops___TupleSet_set_items(mypyc___ir___ops___TupleSetObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'TupleSet' object attribute 'items' cannot be deleted");
        return -1;
    }
    if (self->_items != NULL) {
        CPy_DECREF(self->_items);
    }
    PyObject *tmp;
    if (likely(PyList_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("list", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_items = tmp;
    return 0;
}

static PyObject *
ops___TupleSet_get_tuple_type(mypyc___ir___ops___TupleSetObject *self, void *closure)
{
    if (unlikely(self->_tuple_type == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'tuple_type' of 'TupleSet' undefined");
        return NULL;
    }
    CPy_INCREF(self->_tuple_type);
    PyObject *retval = self->_tuple_type;
    return retval;
}

static int
ops___TupleSet_set_tuple_type(mypyc___ir___ops___TupleSetObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'TupleSet' object attribute 'tuple_type' cannot be deleted");
        return -1;
    }
    if (self->_tuple_type != NULL) {
        CPy_DECREF(self->_tuple_type);
    }
    PyObject *tmp;
    if (likely(Py_TYPE(value) == CPyType_rtypes___RTuple))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RTuple", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_tuple_type = tmp;
    return 0;
}

static int
ops___TupleGet_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___TupleGet_setup(PyTypeObject *type);
PyObject *CPyDef_ops___TupleGet(PyObject *cpy_r_src, CPyTagged cpy_r_index, CPyTagged cpy_r_line);

static PyObject *
ops___TupleGet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___TupleGet) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___TupleGet_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___TupleGet_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___TupleGet_traverse(mypyc___ir___ops___TupleGetObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    if (CPyTagged_CheckLong(self->_index)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_index));
    }
    return 0;
}

static int
ops___TupleGet_clear(mypyc___ir___ops___TupleGetObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    if (CPyTagged_CheckLong(self->_index)) {
        CPyTagged __tmp = self->_index;
        self->_index = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    return 0;
}

static void
ops___TupleGet_dealloc(mypyc___ir___ops___TupleGetObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___TupleGet_dealloc)
    ops___TupleGet_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___TupleGet_vtable[16];
static bool
CPyDef_ops___TupleGet_trait_vtable_setup(void)
{
    CPyVTableItem ops___TupleGet_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___TupleGet_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___TupleGet_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___TupleGet___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___TupleGet___accept,
        (CPyVTableItem)CPyDef_ops___TupleGet_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___TupleGet_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___TupleGet_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___TupleGet_____init__,
        (CPyVTableItem)CPyDef_ops___TupleGet___sources,
        (CPyVTableItem)CPyDef_ops___TupleGet___accept,
        (CPyVTableItem)CPyDef_ops___TupleGet_____mypyc_defaults_setup,
    };
    memcpy(ops___TupleGet_vtable, ops___TupleGet_vtable_scratch, sizeof(ops___TupleGet_vtable));
    return 1;
}

static PyObject *
ops___TupleGet_get_error_kind(mypyc___ir___ops___TupleGetObject *self, void *closure);
static int
ops___TupleGet_set_error_kind(mypyc___ir___ops___TupleGetObject *self, PyObject *value, void *closure);
static PyObject *
ops___TupleGet_get_src(mypyc___ir___ops___TupleGetObject *self, void *closure);
static int
ops___TupleGet_set_src(mypyc___ir___ops___TupleGetObject *self, PyObject *value, void *closure);
static PyObject *
ops___TupleGet_get_index(mypyc___ir___ops___TupleGetObject *self, void *closure);
static int
ops___TupleGet_set_index(mypyc___ir___ops___TupleGetObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___TupleGet_getseters[] = {
    {"error_kind",
     (getter)ops___TupleGet_get_error_kind, (setter)ops___TupleGet_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___TupleGet_get_src, (setter)ops___TupleGet_set_src,
     NULL, NULL},
    {"index",
     (getter)ops___TupleGet_get_index, (setter)ops___TupleGet_set_index,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___TupleGet_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___TupleGet_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___TupleGet___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___TupleGet___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___TupleGet_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___TupleGet_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "TupleGet",
    .tp_new = ops___TupleGet_new,
    .tp_dealloc = (destructor)ops___TupleGet_dealloc,
    .tp_traverse = (traverseproc)ops___TupleGet_traverse,
    .tp_clear = (inquiry)ops___TupleGet_clear,
    .tp_getset = ops___TupleGet_getseters,
    .tp_methods = ops___TupleGet_methods,
    .tp_init = ops___TupleGet_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___TupleGetObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___TupleGet_template = &CPyType_ops___TupleGet_template_;

static PyObject *
ops___TupleGet_setup(PyTypeObject *type)
{
    mypyc___ir___ops___TupleGetObject *self;
    self = (mypyc___ir___ops___TupleGetObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___TupleGet_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_index = CPY_INT_TAG;
    if (CPyDef_ops___TupleGet_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___TupleGet(PyObject *cpy_r_src, CPyTagged cpy_r_index, CPyTagged cpy_r_line)
{
    PyObject *self = ops___TupleGet_setup(CPyType_ops___TupleGet);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___TupleGet_____init__(self, cpy_r_src, cpy_r_index, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___TupleGet_get_error_kind(mypyc___ir___ops___TupleGetObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'TupleGet' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___TupleGet_set_error_kind(mypyc___ir___ops___TupleGetObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'TupleGet' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___TupleGet_get_src(mypyc___ir___ops___TupleGetObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'TupleGet' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___TupleGet_set_src(mypyc___ir___ops___TupleGetObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'TupleGet' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static PyObject *
ops___TupleGet_get_index(mypyc___ir___ops___TupleGetObject *self, void *closure)
{
    if (unlikely(self->_index == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'index' of 'TupleGet' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_index);
    PyObject *retval = CPyTagged_StealAsObject(self->_index);
    return retval;
}

static int
ops___TupleGet_set_index(mypyc___ir___ops___TupleGetObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'TupleGet' object attribute 'index' cannot be deleted");
        return -1;
    }
    if (self->_index != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_index);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_index = tmp;
    return 0;
}

static int
ops___Cast_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Cast_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Cast(PyObject *cpy_r_src, PyObject *cpy_r_typ, CPyTagged cpy_r_line, char cpy_r_borrow);

static PyObject *
ops___Cast_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Cast) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Cast_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Cast_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Cast_traverse(mypyc___ir___ops___CastObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    return 0;
}

static int
ops___Cast_clear(mypyc___ir___ops___CastObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    return 0;
}

static void
ops___Cast_dealloc(mypyc___ir___ops___CastObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Cast_dealloc)
    ops___Cast_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Cast_vtable[17];
static bool
CPyDef_ops___Cast_trait_vtable_setup(void)
{
    CPyVTableItem ops___Cast_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Cast_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Cast_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Cast___sources,
        (CPyVTableItem)CPyDef_ops___Cast___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Cast___accept,
        (CPyVTableItem)CPyDef_ops___Cast_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Cast_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Cast_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Cast_____init__,
        (CPyVTableItem)CPyDef_ops___Cast___sources,
        (CPyVTableItem)CPyDef_ops___Cast___stolen,
        (CPyVTableItem)CPyDef_ops___Cast___accept,
        (CPyVTableItem)CPyDef_ops___Cast_____mypyc_defaults_setup,
    };
    memcpy(ops___Cast_vtable, ops___Cast_vtable_scratch, sizeof(ops___Cast_vtable));
    return 1;
}

static PyObject *
ops___Cast_get_error_kind(mypyc___ir___ops___CastObject *self, void *closure);
static int
ops___Cast_set_error_kind(mypyc___ir___ops___CastObject *self, PyObject *value, void *closure);
static PyObject *
ops___Cast_get_src(mypyc___ir___ops___CastObject *self, void *closure);
static int
ops___Cast_set_src(mypyc___ir___ops___CastObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Cast_getseters[] = {
    {"error_kind",
     (getter)ops___Cast_get_error_kind, (setter)ops___Cast_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___Cast_get_src, (setter)ops___Cast_set_src,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Cast_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Cast_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Cast___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"stolen",
     (PyCFunction)CPyPy_ops___Cast___stolen,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Cast___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Cast_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Cast_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Cast",
    .tp_new = ops___Cast_new,
    .tp_dealloc = (destructor)ops___Cast_dealloc,
    .tp_traverse = (traverseproc)ops___Cast_traverse,
    .tp_clear = (inquiry)ops___Cast_clear,
    .tp_getset = ops___Cast_getseters,
    .tp_methods = ops___Cast_methods,
    .tp_init = ops___Cast_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___CastObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Cast_template = &CPyType_ops___Cast_template_;

static PyObject *
ops___Cast_setup(PyTypeObject *type)
{
    mypyc___ir___ops___CastObject *self;
    self = (mypyc___ir___ops___CastObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Cast_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___Cast_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Cast(PyObject *cpy_r_src, PyObject *cpy_r_typ, CPyTagged cpy_r_line, char cpy_r_borrow)
{
    PyObject *self = ops___Cast_setup(CPyType_ops___Cast);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Cast_____init__(self, cpy_r_src, cpy_r_typ, cpy_r_line, cpy_r_borrow);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Cast_get_error_kind(mypyc___ir___ops___CastObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'Cast' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___Cast_set_error_kind(mypyc___ir___ops___CastObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Cast' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___Cast_get_src(mypyc___ir___ops___CastObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'Cast' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___Cast_set_src(mypyc___ir___ops___CastObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Cast' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static int
ops___Box_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Box_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Box(PyObject *cpy_r_src, CPyTagged cpy_r_line);

static PyObject *
ops___Box_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Box) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Box_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Box_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Box_traverse(mypyc___ir___ops___BoxObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    return 0;
}

static int
ops___Box_clear(mypyc___ir___ops___BoxObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    return 0;
}

static void
ops___Box_dealloc(mypyc___ir___ops___BoxObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Box_dealloc)
    ops___Box_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Box_vtable[17];
static bool
CPyDef_ops___Box_trait_vtable_setup(void)
{
    CPyVTableItem ops___Box_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Box_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Box_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Box___sources,
        (CPyVTableItem)CPyDef_ops___Box___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Box___accept,
        (CPyVTableItem)CPyDef_ops___Box_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Box_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Box_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Box_____init__,
        (CPyVTableItem)CPyDef_ops___Box___sources,
        (CPyVTableItem)CPyDef_ops___Box___stolen,
        (CPyVTableItem)CPyDef_ops___Box___accept,
        (CPyVTableItem)CPyDef_ops___Box_____mypyc_defaults_setup,
    };
    memcpy(ops___Box_vtable, ops___Box_vtable_scratch, sizeof(ops___Box_vtable));
    return 1;
}

static PyObject *
ops___Box_get_error_kind(mypyc___ir___ops___BoxObject *self, void *closure);
static int
ops___Box_set_error_kind(mypyc___ir___ops___BoxObject *self, PyObject *value, void *closure);
static PyObject *
ops___Box_get_src(mypyc___ir___ops___BoxObject *self, void *closure);
static int
ops___Box_set_src(mypyc___ir___ops___BoxObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Box_getseters[] = {
    {"error_kind",
     (getter)ops___Box_get_error_kind, (setter)ops___Box_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___Box_get_src, (setter)ops___Box_set_src,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Box_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Box_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Box___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"stolen",
     (PyCFunction)CPyPy_ops___Box___stolen,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Box___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Box_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Box_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Box",
    .tp_new = ops___Box_new,
    .tp_dealloc = (destructor)ops___Box_dealloc,
    .tp_traverse = (traverseproc)ops___Box_traverse,
    .tp_clear = (inquiry)ops___Box_clear,
    .tp_getset = ops___Box_getseters,
    .tp_methods = ops___Box_methods,
    .tp_init = ops___Box_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___BoxObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Box_template = &CPyType_ops___Box_template_;

static PyObject *
ops___Box_setup(PyTypeObject *type)
{
    mypyc___ir___ops___BoxObject *self;
    self = (mypyc___ir___ops___BoxObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Box_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___Box_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Box(PyObject *cpy_r_src, CPyTagged cpy_r_line)
{
    PyObject *self = ops___Box_setup(CPyType_ops___Box);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Box_____init__(self, cpy_r_src, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Box_get_error_kind(mypyc___ir___ops___BoxObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'Box' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___Box_set_error_kind(mypyc___ir___ops___BoxObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Box' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___Box_get_src(mypyc___ir___ops___BoxObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'Box' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___Box_set_src(mypyc___ir___ops___BoxObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Box' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static int
ops___Unbox_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Unbox_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Unbox(PyObject *cpy_r_src, PyObject *cpy_r_typ, CPyTagged cpy_r_line);

static PyObject *
ops___Unbox_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Unbox) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Unbox_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Unbox_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Unbox_traverse(mypyc___ir___ops___UnboxObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    Py_VISIT(self->_src);
    return 0;
}

static int
ops___Unbox_clear(mypyc___ir___ops___UnboxObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    Py_CLEAR(self->_src);
    return 0;
}

static void
ops___Unbox_dealloc(mypyc___ir___ops___UnboxObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Unbox_dealloc)
    ops___Unbox_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Unbox_vtable[16];
static bool
CPyDef_ops___Unbox_trait_vtable_setup(void)
{
    CPyVTableItem ops___Unbox_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Unbox_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Unbox_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Unbox___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Unbox___accept,
        (CPyVTableItem)CPyDef_ops___Unbox_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Unbox_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Unbox_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Unbox_____init__,
        (CPyVTableItem)CPyDef_ops___Unbox___sources,
        (CPyVTableItem)CPyDef_ops___Unbox___accept,
        (CPyVTableItem)CPyDef_ops___Unbox_____mypyc_defaults_setup,
    };
    memcpy(ops___Unbox_vtable, ops___Unbox_vtable_scratch, sizeof(ops___Unbox_vtable));
    return 1;
}

static PyObject *
ops___Unbox_get_src(mypyc___ir___ops___UnboxObject *self, void *closure);
static int
ops___Unbox_set_src(mypyc___ir___ops___UnboxObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Unbox_getseters[] = {
    {"src",
     (getter)ops___Unbox_get_src, (setter)ops___Unbox_set_src,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Unbox_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Unbox_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Unbox___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Unbox___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Unbox_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Unbox_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Unbox",
    .tp_new = ops___Unbox_new,
    .tp_dealloc = (destructor)ops___Unbox_dealloc,
    .tp_traverse = (traverseproc)ops___Unbox_traverse,
    .tp_clear = (inquiry)ops___Unbox_clear,
    .tp_getset = ops___Unbox_getseters,
    .tp_methods = ops___Unbox_methods,
    .tp_init = ops___Unbox_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___UnboxObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Unbox_template = &CPyType_ops___Unbox_template_;

static PyObject *
ops___Unbox_setup(PyTypeObject *type)
{
    mypyc___ir___ops___UnboxObject *self;
    self = (mypyc___ir___ops___UnboxObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Unbox_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___Unbox_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Unbox(PyObject *cpy_r_src, PyObject *cpy_r_typ, CPyTagged cpy_r_line)
{
    PyObject *self = ops___Unbox_setup(CPyType_ops___Unbox);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Unbox_____init__(self, cpy_r_src, cpy_r_typ, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Unbox_get_src(mypyc___ir___ops___UnboxObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'Unbox' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___Unbox_set_src(mypyc___ir___ops___UnboxObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Unbox' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static int
ops___RaiseStandardError_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___RaiseStandardError_setup(PyTypeObject *type);
PyObject *CPyDef_ops___RaiseStandardError(PyObject *cpy_r_class_name, PyObject *cpy_r_value, CPyTagged cpy_r_line);

static PyObject *
ops___RaiseStandardError_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___RaiseStandardError) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___RaiseStandardError_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___RaiseStandardError_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___RaiseStandardError_traverse(mypyc___ir___ops___RaiseStandardErrorObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_VALUE_ERROR);
    Py_VISIT(self->_ASSERTION_ERROR);
    Py_VISIT(self->_STOP_ITERATION);
    Py_VISIT(self->_UNBOUND_LOCAL_ERROR);
    Py_VISIT(self->_RUNTIME_ERROR);
    Py_VISIT(self->_NAME_ERROR);
    Py_VISIT(self->_ZERO_DIVISION_ERROR);
    Py_VISIT(self->_class_name);
    Py_VISIT(self->_value);
    return 0;
}

static int
ops___RaiseStandardError_clear(mypyc___ir___ops___RaiseStandardErrorObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_VALUE_ERROR);
    Py_CLEAR(self->_ASSERTION_ERROR);
    Py_CLEAR(self->_STOP_ITERATION);
    Py_CLEAR(self->_UNBOUND_LOCAL_ERROR);
    Py_CLEAR(self->_RUNTIME_ERROR);
    Py_CLEAR(self->_NAME_ERROR);
    Py_CLEAR(self->_ZERO_DIVISION_ERROR);
    Py_CLEAR(self->_class_name);
    Py_CLEAR(self->_value);
    return 0;
}

static void
ops___RaiseStandardError_dealloc(mypyc___ir___ops___RaiseStandardErrorObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___RaiseStandardError_dealloc)
    ops___RaiseStandardError_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___RaiseStandardError_vtable[16];
static bool
CPyDef_ops___RaiseStandardError_trait_vtable_setup(void)
{
    CPyVTableItem ops___RaiseStandardError_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___RaiseStandardError_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___RaiseStandardError_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___RaiseStandardError___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___RaiseStandardError___accept,
        (CPyVTableItem)CPyDef_ops___RaiseStandardError_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___RaiseStandardError_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___RaiseStandardError_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___RaiseStandardError_____init__,
        (CPyVTableItem)CPyDef_ops___RaiseStandardError___sources,
        (CPyVTableItem)CPyDef_ops___RaiseStandardError___accept,
        (CPyVTableItem)CPyDef_ops___RaiseStandardError_____mypyc_defaults_setup,
    };
    memcpy(ops___RaiseStandardError_vtable, ops___RaiseStandardError_vtable_scratch, sizeof(ops___RaiseStandardError_vtable));
    return 1;
}

static PyObject *
ops___RaiseStandardError_get_error_kind(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure);
static int
ops___RaiseStandardError_set_error_kind(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure);
static PyObject *
ops___RaiseStandardError_get_VALUE_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure);
static int
ops___RaiseStandardError_set_VALUE_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure);
static PyObject *
ops___RaiseStandardError_get_ASSERTION_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure);
static int
ops___RaiseStandardError_set_ASSERTION_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure);
static PyObject *
ops___RaiseStandardError_get_STOP_ITERATION(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure);
static int
ops___RaiseStandardError_set_STOP_ITERATION(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure);
static PyObject *
ops___RaiseStandardError_get_UNBOUND_LOCAL_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure);
static int
ops___RaiseStandardError_set_UNBOUND_LOCAL_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure);
static PyObject *
ops___RaiseStandardError_get_RUNTIME_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure);
static int
ops___RaiseStandardError_set_RUNTIME_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure);
static PyObject *
ops___RaiseStandardError_get_NAME_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure);
static int
ops___RaiseStandardError_set_NAME_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure);
static PyObject *
ops___RaiseStandardError_get_ZERO_DIVISION_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure);
static int
ops___RaiseStandardError_set_ZERO_DIVISION_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure);
static PyObject *
ops___RaiseStandardError_get_class_name(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure);
static int
ops___RaiseStandardError_set_class_name(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure);
static PyObject *
ops___RaiseStandardError_get_value(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure);
static int
ops___RaiseStandardError_set_value(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___RaiseStandardError_getseters[] = {
    {"error_kind",
     (getter)ops___RaiseStandardError_get_error_kind, (setter)ops___RaiseStandardError_set_error_kind,
     NULL, NULL},
    {"VALUE_ERROR",
     (getter)ops___RaiseStandardError_get_VALUE_ERROR, (setter)ops___RaiseStandardError_set_VALUE_ERROR,
     NULL, NULL},
    {"ASSERTION_ERROR",
     (getter)ops___RaiseStandardError_get_ASSERTION_ERROR, (setter)ops___RaiseStandardError_set_ASSERTION_ERROR,
     NULL, NULL},
    {"STOP_ITERATION",
     (getter)ops___RaiseStandardError_get_STOP_ITERATION, (setter)ops___RaiseStandardError_set_STOP_ITERATION,
     NULL, NULL},
    {"UNBOUND_LOCAL_ERROR",
     (getter)ops___RaiseStandardError_get_UNBOUND_LOCAL_ERROR, (setter)ops___RaiseStandardError_set_UNBOUND_LOCAL_ERROR,
     NULL, NULL},
    {"RUNTIME_ERROR",
     (getter)ops___RaiseStandardError_get_RUNTIME_ERROR, (setter)ops___RaiseStandardError_set_RUNTIME_ERROR,
     NULL, NULL},
    {"NAME_ERROR",
     (getter)ops___RaiseStandardError_get_NAME_ERROR, (setter)ops___RaiseStandardError_set_NAME_ERROR,
     NULL, NULL},
    {"ZERO_DIVISION_ERROR",
     (getter)ops___RaiseStandardError_get_ZERO_DIVISION_ERROR, (setter)ops___RaiseStandardError_set_ZERO_DIVISION_ERROR,
     NULL, NULL},
    {"class_name",
     (getter)ops___RaiseStandardError_get_class_name, (setter)ops___RaiseStandardError_set_class_name,
     NULL, NULL},
    {"value",
     (getter)ops___RaiseStandardError_get_value, (setter)ops___RaiseStandardError_set_value,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___RaiseStandardError_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___RaiseStandardError_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___RaiseStandardError___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___RaiseStandardError___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___RaiseStandardError_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___RaiseStandardError_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "RaiseStandardError",
    .tp_new = ops___RaiseStandardError_new,
    .tp_dealloc = (destructor)ops___RaiseStandardError_dealloc,
    .tp_traverse = (traverseproc)ops___RaiseStandardError_traverse,
    .tp_clear = (inquiry)ops___RaiseStandardError_clear,
    .tp_getset = ops___RaiseStandardError_getseters,
    .tp_methods = ops___RaiseStandardError_methods,
    .tp_init = ops___RaiseStandardError_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___RaiseStandardErrorObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___RaiseStandardError_template = &CPyType_ops___RaiseStandardError_template_;

static PyObject *
ops___RaiseStandardError_setup(PyTypeObject *type)
{
    mypyc___ir___ops___RaiseStandardErrorObject *self;
    self = (mypyc___ir___ops___RaiseStandardErrorObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___RaiseStandardError_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___RaiseStandardError_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___RaiseStandardError(PyObject *cpy_r_class_name, PyObject *cpy_r_value, CPyTagged cpy_r_line)
{
    PyObject *self = ops___RaiseStandardError_setup(CPyType_ops___RaiseStandardError);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___RaiseStandardError_____init__(self, cpy_r_class_name, cpy_r_value, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___RaiseStandardError_get_error_kind(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'RaiseStandardError' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___RaiseStandardError_set_error_kind(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RaiseStandardError' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___RaiseStandardError_get_VALUE_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure)
{
    if (unlikely(self->_VALUE_ERROR == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'VALUE_ERROR' of 'RaiseStandardError' undefined");
        return NULL;
    }
    CPy_INCREF(self->_VALUE_ERROR);
    PyObject *retval = self->_VALUE_ERROR;
    return retval;
}

static int
ops___RaiseStandardError_set_VALUE_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RaiseStandardError' object attribute 'VALUE_ERROR' cannot be deleted");
        return -1;
    }
    if (self->_VALUE_ERROR != NULL) {
        CPy_DECREF(self->_VALUE_ERROR);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_VALUE_ERROR = tmp;
    return 0;
}

static PyObject *
ops___RaiseStandardError_get_ASSERTION_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure)
{
    if (unlikely(self->_ASSERTION_ERROR == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'ASSERTION_ERROR' of 'RaiseStandardError' undefined");
        return NULL;
    }
    CPy_INCREF(self->_ASSERTION_ERROR);
    PyObject *retval = self->_ASSERTION_ERROR;
    return retval;
}

static int
ops___RaiseStandardError_set_ASSERTION_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RaiseStandardError' object attribute 'ASSERTION_ERROR' cannot be deleted");
        return -1;
    }
    if (self->_ASSERTION_ERROR != NULL) {
        CPy_DECREF(self->_ASSERTION_ERROR);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_ASSERTION_ERROR = tmp;
    return 0;
}

static PyObject *
ops___RaiseStandardError_get_STOP_ITERATION(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure)
{
    if (unlikely(self->_STOP_ITERATION == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'STOP_ITERATION' of 'RaiseStandardError' undefined");
        return NULL;
    }
    CPy_INCREF(self->_STOP_ITERATION);
    PyObject *retval = self->_STOP_ITERATION;
    return retval;
}

static int
ops___RaiseStandardError_set_STOP_ITERATION(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RaiseStandardError' object attribute 'STOP_ITERATION' cannot be deleted");
        return -1;
    }
    if (self->_STOP_ITERATION != NULL) {
        CPy_DECREF(self->_STOP_ITERATION);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_STOP_ITERATION = tmp;
    return 0;
}

static PyObject *
ops___RaiseStandardError_get_UNBOUND_LOCAL_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure)
{
    if (unlikely(self->_UNBOUND_LOCAL_ERROR == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'UNBOUND_LOCAL_ERROR' of 'RaiseStandardError' undefined");
        return NULL;
    }
    CPy_INCREF(self->_UNBOUND_LOCAL_ERROR);
    PyObject *retval = self->_UNBOUND_LOCAL_ERROR;
    return retval;
}

static int
ops___RaiseStandardError_set_UNBOUND_LOCAL_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RaiseStandardError' object attribute 'UNBOUND_LOCAL_ERROR' cannot be deleted");
        return -1;
    }
    if (self->_UNBOUND_LOCAL_ERROR != NULL) {
        CPy_DECREF(self->_UNBOUND_LOCAL_ERROR);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_UNBOUND_LOCAL_ERROR = tmp;
    return 0;
}

static PyObject *
ops___RaiseStandardError_get_RUNTIME_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure)
{
    if (unlikely(self->_RUNTIME_ERROR == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'RUNTIME_ERROR' of 'RaiseStandardError' undefined");
        return NULL;
    }
    CPy_INCREF(self->_RUNTIME_ERROR);
    PyObject *retval = self->_RUNTIME_ERROR;
    return retval;
}

static int
ops___RaiseStandardError_set_RUNTIME_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RaiseStandardError' object attribute 'RUNTIME_ERROR' cannot be deleted");
        return -1;
    }
    if (self->_RUNTIME_ERROR != NULL) {
        CPy_DECREF(self->_RUNTIME_ERROR);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_RUNTIME_ERROR = tmp;
    return 0;
}

static PyObject *
ops___RaiseStandardError_get_NAME_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure)
{
    if (unlikely(self->_NAME_ERROR == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'NAME_ERROR' of 'RaiseStandardError' undefined");
        return NULL;
    }
    CPy_INCREF(self->_NAME_ERROR);
    PyObject *retval = self->_NAME_ERROR;
    return retval;
}

static int
ops___RaiseStandardError_set_NAME_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RaiseStandardError' object attribute 'NAME_ERROR' cannot be deleted");
        return -1;
    }
    if (self->_NAME_ERROR != NULL) {
        CPy_DECREF(self->_NAME_ERROR);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_NAME_ERROR = tmp;
    return 0;
}

static PyObject *
ops___RaiseStandardError_get_ZERO_DIVISION_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure)
{
    if (unlikely(self->_ZERO_DIVISION_ERROR == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'ZERO_DIVISION_ERROR' of 'RaiseStandardError' undefined");
        return NULL;
    }
    CPy_INCREF(self->_ZERO_DIVISION_ERROR);
    PyObject *retval = self->_ZERO_DIVISION_ERROR;
    return retval;
}

static int
ops___RaiseStandardError_set_ZERO_DIVISION_ERROR(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RaiseStandardError' object attribute 'ZERO_DIVISION_ERROR' cannot be deleted");
        return -1;
    }
    if (self->_ZERO_DIVISION_ERROR != NULL) {
        CPy_DECREF(self->_ZERO_DIVISION_ERROR);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_ZERO_DIVISION_ERROR = tmp;
    return 0;
}

static PyObject *
ops___RaiseStandardError_get_class_name(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure)
{
    if (unlikely(self->_class_name == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'class_name' of 'RaiseStandardError' undefined");
        return NULL;
    }
    CPy_INCREF(self->_class_name);
    PyObject *retval = self->_class_name;
    return retval;
}

static int
ops___RaiseStandardError_set_class_name(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RaiseStandardError' object attribute 'class_name' cannot be deleted");
        return -1;
    }
    if (self->_class_name != NULL) {
        CPy_DECREF(self->_class_name);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_class_name = tmp;
    return 0;
}

static PyObject *
ops___RaiseStandardError_get_value(mypyc___ir___ops___RaiseStandardErrorObject *self, void *closure)
{
    if (unlikely(self->_value == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'value' of 'RaiseStandardError' undefined");
        return NULL;
    }
    CPy_INCREF(self->_value);
    PyObject *retval = self->_value;
    return retval;
}

static int
ops___RaiseStandardError_set_value(mypyc___ir___ops___RaiseStandardErrorObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'RaiseStandardError' object attribute 'value' cannot be deleted");
        return -1;
    }
    if (self->_value != NULL) {
        CPy_DECREF(self->_value);
    }
    PyObject *tmp;
    if (PyUnicode_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9862;
    if (PyObject_TypeCheck(value, CPyType_ops___Value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9862;
    if (value == Py_None)
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9862;
    CPy_TypeError("union[str, mypyc.ir.ops.Value, None]", value); 
    tmp = NULL;
__LL9862: ;
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_value = tmp;
    return 0;
}

static int
ops___CallC_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___CallC_setup(PyTypeObject *type);
PyObject *CPyDef_ops___CallC(PyObject *cpy_r_function_name, PyObject *cpy_r_args, PyObject *cpy_r_ret_type, PyObject *cpy_r_steals, char cpy_r_is_borrowed, CPyTagged cpy_r_error_kind, CPyTagged cpy_r_line, CPyTagged cpy_r_var_arg_idx);

static PyObject *
ops___CallC_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___CallC) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___CallC_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___CallC_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___CallC_traverse(mypyc___ir___ops___CallCObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    Py_VISIT(self->_function_name);
    Py_VISIT(self->_args);
    Py_VISIT(self->_steals);
    if (CPyTagged_CheckLong(self->_var_arg_idx)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_var_arg_idx));
    }
    return 0;
}

static int
ops___CallC_clear(mypyc___ir___ops___CallCObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    Py_CLEAR(self->_function_name);
    Py_CLEAR(self->_args);
    Py_CLEAR(self->_steals);
    if (CPyTagged_CheckLong(self->_var_arg_idx)) {
        CPyTagged __tmp = self->_var_arg_idx;
        self->_var_arg_idx = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    return 0;
}

static void
ops___CallC_dealloc(mypyc___ir___ops___CallCObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___CallC_dealloc)
    ops___CallC_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___CallC_vtable[17];
static bool
CPyDef_ops___CallC_trait_vtable_setup(void)
{
    CPyVTableItem ops___CallC_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___CallC_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___CallC_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___CallC___sources,
        (CPyVTableItem)CPyDef_ops___CallC___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___CallC___accept,
        (CPyVTableItem)CPyDef_ops___CallC_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___CallC_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___CallC_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___CallC_____init__,
        (CPyVTableItem)CPyDef_ops___CallC___sources,
        (CPyVTableItem)CPyDef_ops___CallC___stolen,
        (CPyVTableItem)CPyDef_ops___CallC___accept,
        (CPyVTableItem)CPyDef_ops___CallC_____mypyc_defaults_setup,
    };
    memcpy(ops___CallC_vtable, ops___CallC_vtable_scratch, sizeof(ops___CallC_vtable));
    return 1;
}

static PyObject *
ops___CallC_get_function_name(mypyc___ir___ops___CallCObject *self, void *closure);
static int
ops___CallC_set_function_name(mypyc___ir___ops___CallCObject *self, PyObject *value, void *closure);
static PyObject *
ops___CallC_get_args(mypyc___ir___ops___CallCObject *self, void *closure);
static int
ops___CallC_set_args(mypyc___ir___ops___CallCObject *self, PyObject *value, void *closure);
static PyObject *
ops___CallC_get_steals(mypyc___ir___ops___CallCObject *self, void *closure);
static int
ops___CallC_set_steals(mypyc___ir___ops___CallCObject *self, PyObject *value, void *closure);
static PyObject *
ops___CallC_get_var_arg_idx(mypyc___ir___ops___CallCObject *self, void *closure);
static int
ops___CallC_set_var_arg_idx(mypyc___ir___ops___CallCObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___CallC_getseters[] = {
    {"function_name",
     (getter)ops___CallC_get_function_name, (setter)ops___CallC_set_function_name,
     NULL, NULL},
    {"args",
     (getter)ops___CallC_get_args, (setter)ops___CallC_set_args,
     NULL, NULL},
    {"steals",
     (getter)ops___CallC_get_steals, (setter)ops___CallC_set_steals,
     NULL, NULL},
    {"var_arg_idx",
     (getter)ops___CallC_get_var_arg_idx, (setter)ops___CallC_set_var_arg_idx,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___CallC_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___CallC_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___CallC___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"stolen",
     (PyCFunction)CPyPy_ops___CallC___stolen,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___CallC___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___CallC_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___CallC_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "CallC",
    .tp_new = ops___CallC_new,
    .tp_dealloc = (destructor)ops___CallC_dealloc,
    .tp_traverse = (traverseproc)ops___CallC_traverse,
    .tp_clear = (inquiry)ops___CallC_clear,
    .tp_getset = ops___CallC_getseters,
    .tp_methods = ops___CallC_methods,
    .tp_init = ops___CallC_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___CallCObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___CallC_template = &CPyType_ops___CallC_template_;

static PyObject *
ops___CallC_setup(PyTypeObject *type)
{
    mypyc___ir___ops___CallCObject *self;
    self = (mypyc___ir___ops___CallCObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___CallC_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_var_arg_idx = CPY_INT_TAG;
    if (CPyDef_ops___CallC_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___CallC(PyObject *cpy_r_function_name, PyObject *cpy_r_args, PyObject *cpy_r_ret_type, PyObject *cpy_r_steals, char cpy_r_is_borrowed, CPyTagged cpy_r_error_kind, CPyTagged cpy_r_line, CPyTagged cpy_r_var_arg_idx)
{
    PyObject *self = ops___CallC_setup(CPyType_ops___CallC);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___CallC_____init__(self, cpy_r_function_name, cpy_r_args, cpy_r_ret_type, cpy_r_steals, cpy_r_is_borrowed, cpy_r_error_kind, cpy_r_line, cpy_r_var_arg_idx);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___CallC_get_function_name(mypyc___ir___ops___CallCObject *self, void *closure)
{
    if (unlikely(self->_function_name == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'function_name' of 'CallC' undefined");
        return NULL;
    }
    CPy_INCREF(self->_function_name);
    PyObject *retval = self->_function_name;
    return retval;
}

static int
ops___CallC_set_function_name(mypyc___ir___ops___CallCObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'CallC' object attribute 'function_name' cannot be deleted");
        return -1;
    }
    if (self->_function_name != NULL) {
        CPy_DECREF(self->_function_name);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_function_name = tmp;
    return 0;
}

static PyObject *
ops___CallC_get_args(mypyc___ir___ops___CallCObject *self, void *closure)
{
    if (unlikely(self->_args == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'args' of 'CallC' undefined");
        return NULL;
    }
    CPy_INCREF(self->_args);
    PyObject *retval = self->_args;
    return retval;
}

static int
ops___CallC_set_args(mypyc___ir___ops___CallCObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'CallC' object attribute 'args' cannot be deleted");
        return -1;
    }
    if (self->_args != NULL) {
        CPy_DECREF(self->_args);
    }
    PyObject *tmp;
    if (likely(PyList_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("list", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_args = tmp;
    return 0;
}

static PyObject *
ops___CallC_get_steals(mypyc___ir___ops___CallCObject *self, void *closure)
{
    if (unlikely(self->_steals == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'steals' of 'CallC' undefined");
        return NULL;
    }
    CPy_INCREF(self->_steals);
    PyObject *retval = self->_steals;
    return retval;
}

static int
ops___CallC_set_steals(mypyc___ir___ops___CallCObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'CallC' object attribute 'steals' cannot be deleted");
        return -1;
    }
    if (self->_steals != NULL) {
        CPy_DECREF(self->_steals);
    }
    PyObject *tmp;
    if (PyBool_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9863;
    if (PyList_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9863;
    CPy_TypeError("union[bool, list]", value); 
    tmp = NULL;
__LL9863: ;
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_steals = tmp;
    return 0;
}

static PyObject *
ops___CallC_get_var_arg_idx(mypyc___ir___ops___CallCObject *self, void *closure)
{
    if (unlikely(self->_var_arg_idx == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'var_arg_idx' of 'CallC' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_var_arg_idx);
    PyObject *retval = CPyTagged_StealAsObject(self->_var_arg_idx);
    return retval;
}

static int
ops___CallC_set_var_arg_idx(mypyc___ir___ops___CallCObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'CallC' object attribute 'var_arg_idx' cannot be deleted");
        return -1;
    }
    if (self->_var_arg_idx != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_var_arg_idx);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_var_arg_idx = tmp;
    return 0;
}

static int
ops___Truncate_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Truncate_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Truncate(PyObject *cpy_r_src, PyObject *cpy_r_dst_type, CPyTagged cpy_r_line);

static PyObject *
ops___Truncate_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Truncate) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Truncate_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Truncate_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Truncate_traverse(mypyc___ir___ops___TruncateObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    Py_VISIT(self->_src_type);
    return 0;
}

static int
ops___Truncate_clear(mypyc___ir___ops___TruncateObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    Py_CLEAR(self->_src_type);
    return 0;
}

static void
ops___Truncate_dealloc(mypyc___ir___ops___TruncateObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Truncate_dealloc)
    ops___Truncate_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Truncate_vtable[17];
static bool
CPyDef_ops___Truncate_trait_vtable_setup(void)
{
    CPyVTableItem ops___Truncate_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Truncate_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Truncate_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Truncate___sources,
        (CPyVTableItem)CPyDef_ops___Truncate___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Truncate___accept,
        (CPyVTableItem)CPyDef_ops___Truncate_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Truncate_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Truncate_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Truncate_____init__,
        (CPyVTableItem)CPyDef_ops___Truncate___sources,
        (CPyVTableItem)CPyDef_ops___Truncate___stolen,
        (CPyVTableItem)CPyDef_ops___Truncate___accept,
        (CPyVTableItem)CPyDef_ops___Truncate_____mypyc_defaults_setup,
    };
    memcpy(ops___Truncate_vtable, ops___Truncate_vtable_scratch, sizeof(ops___Truncate_vtable));
    return 1;
}

static PyObject *
ops___Truncate_get_error_kind(mypyc___ir___ops___TruncateObject *self, void *closure);
static int
ops___Truncate_set_error_kind(mypyc___ir___ops___TruncateObject *self, PyObject *value, void *closure);
static PyObject *
ops___Truncate_get_src(mypyc___ir___ops___TruncateObject *self, void *closure);
static int
ops___Truncate_set_src(mypyc___ir___ops___TruncateObject *self, PyObject *value, void *closure);
static PyObject *
ops___Truncate_get_src_type(mypyc___ir___ops___TruncateObject *self, void *closure);
static int
ops___Truncate_set_src_type(mypyc___ir___ops___TruncateObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Truncate_getseters[] = {
    {"error_kind",
     (getter)ops___Truncate_get_error_kind, (setter)ops___Truncate_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___Truncate_get_src, (setter)ops___Truncate_set_src,
     NULL, NULL},
    {"src_type",
     (getter)ops___Truncate_get_src_type, (setter)ops___Truncate_set_src_type,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Truncate_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Truncate_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Truncate___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"stolen",
     (PyCFunction)CPyPy_ops___Truncate___stolen,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Truncate___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Truncate_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Truncate_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Truncate",
    .tp_new = ops___Truncate_new,
    .tp_dealloc = (destructor)ops___Truncate_dealloc,
    .tp_traverse = (traverseproc)ops___Truncate_traverse,
    .tp_clear = (inquiry)ops___Truncate_clear,
    .tp_getset = ops___Truncate_getseters,
    .tp_methods = ops___Truncate_methods,
    .tp_init = ops___Truncate_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___TruncateObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Truncate_template = &CPyType_ops___Truncate_template_;

static PyObject *
ops___Truncate_setup(PyTypeObject *type)
{
    mypyc___ir___ops___TruncateObject *self;
    self = (mypyc___ir___ops___TruncateObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Truncate_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___Truncate_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Truncate(PyObject *cpy_r_src, PyObject *cpy_r_dst_type, CPyTagged cpy_r_line)
{
    PyObject *self = ops___Truncate_setup(CPyType_ops___Truncate);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Truncate_____init__(self, cpy_r_src, cpy_r_dst_type, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Truncate_get_error_kind(mypyc___ir___ops___TruncateObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'Truncate' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___Truncate_set_error_kind(mypyc___ir___ops___TruncateObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Truncate' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___Truncate_get_src(mypyc___ir___ops___TruncateObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'Truncate' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___Truncate_set_src(mypyc___ir___ops___TruncateObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Truncate' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static PyObject *
ops___Truncate_get_src_type(mypyc___ir___ops___TruncateObject *self, void *closure)
{
    if (unlikely(self->_src_type == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src_type' of 'Truncate' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src_type);
    PyObject *retval = self->_src_type;
    return retval;
}

static int
ops___Truncate_set_src_type(mypyc___ir___ops___TruncateObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Truncate' object attribute 'src_type' cannot be deleted");
        return -1;
    }
    if (self->_src_type != NULL) {
        CPy_DECREF(self->_src_type);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_rtypes___RType)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src_type = tmp;
    return 0;
}

static int
ops___Extend_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___Extend_setup(PyTypeObject *type);
PyObject *CPyDef_ops___Extend(PyObject *cpy_r_src, PyObject *cpy_r_dst_type, char cpy_r_signed, CPyTagged cpy_r_line);

static PyObject *
ops___Extend_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___Extend) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___Extend_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___Extend_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___Extend_traverse(mypyc___ir___ops___ExtendObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    Py_VISIT(self->_src_type);
    return 0;
}

static int
ops___Extend_clear(mypyc___ir___ops___ExtendObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    Py_CLEAR(self->_src_type);
    return 0;
}

static void
ops___Extend_dealloc(mypyc___ir___ops___ExtendObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___Extend_dealloc)
    ops___Extend_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___Extend_vtable[17];
static bool
CPyDef_ops___Extend_trait_vtable_setup(void)
{
    CPyVTableItem ops___Extend_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___Extend_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Extend_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Extend___sources,
        (CPyVTableItem)CPyDef_ops___Extend___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___Extend___accept,
        (CPyVTableItem)CPyDef_ops___Extend_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Extend_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___Extend_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___Extend_____init__,
        (CPyVTableItem)CPyDef_ops___Extend___sources,
        (CPyVTableItem)CPyDef_ops___Extend___stolen,
        (CPyVTableItem)CPyDef_ops___Extend___accept,
        (CPyVTableItem)CPyDef_ops___Extend_____mypyc_defaults_setup,
    };
    memcpy(ops___Extend_vtable, ops___Extend_vtable_scratch, sizeof(ops___Extend_vtable));
    return 1;
}

static PyObject *
ops___Extend_get_error_kind(mypyc___ir___ops___ExtendObject *self, void *closure);
static int
ops___Extend_set_error_kind(mypyc___ir___ops___ExtendObject *self, PyObject *value, void *closure);
static PyObject *
ops___Extend_get_src(mypyc___ir___ops___ExtendObject *self, void *closure);
static int
ops___Extend_set_src(mypyc___ir___ops___ExtendObject *self, PyObject *value, void *closure);
static PyObject *
ops___Extend_get_src_type(mypyc___ir___ops___ExtendObject *self, void *closure);
static int
ops___Extend_set_src_type(mypyc___ir___ops___ExtendObject *self, PyObject *value, void *closure);
static PyObject *
ops___Extend_get_signed(mypyc___ir___ops___ExtendObject *self, void *closure);
static int
ops___Extend_set_signed(mypyc___ir___ops___ExtendObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___Extend_getseters[] = {
    {"error_kind",
     (getter)ops___Extend_get_error_kind, (setter)ops___Extend_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___Extend_get_src, (setter)ops___Extend_set_src,
     NULL, NULL},
    {"src_type",
     (getter)ops___Extend_get_src_type, (setter)ops___Extend_set_src_type,
     NULL, NULL},
    {"signed",
     (getter)ops___Extend_get_signed, (setter)ops___Extend_set_signed,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___Extend_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___Extend_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___Extend___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"stolen",
     (PyCFunction)CPyPy_ops___Extend___stolen,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___Extend___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___Extend_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___Extend_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "Extend",
    .tp_new = ops___Extend_new,
    .tp_dealloc = (destructor)ops___Extend_dealloc,
    .tp_traverse = (traverseproc)ops___Extend_traverse,
    .tp_clear = (inquiry)ops___Extend_clear,
    .tp_getset = ops___Extend_getseters,
    .tp_methods = ops___Extend_methods,
    .tp_init = ops___Extend_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___ExtendObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___Extend_template = &CPyType_ops___Extend_template_;

static PyObject *
ops___Extend_setup(PyTypeObject *type)
{
    mypyc___ir___ops___ExtendObject *self;
    self = (mypyc___ir___ops___ExtendObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___Extend_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_signed = 2;
    if (CPyDef_ops___Extend_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___Extend(PyObject *cpy_r_src, PyObject *cpy_r_dst_type, char cpy_r_signed, CPyTagged cpy_r_line)
{
    PyObject *self = ops___Extend_setup(CPyType_ops___Extend);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___Extend_____init__(self, cpy_r_src, cpy_r_dst_type, cpy_r_signed, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___Extend_get_error_kind(mypyc___ir___ops___ExtendObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'Extend' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___Extend_set_error_kind(mypyc___ir___ops___ExtendObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Extend' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___Extend_get_src(mypyc___ir___ops___ExtendObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'Extend' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___Extend_set_src(mypyc___ir___ops___ExtendObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Extend' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static PyObject *
ops___Extend_get_src_type(mypyc___ir___ops___ExtendObject *self, void *closure)
{
    if (unlikely(self->_src_type == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src_type' of 'Extend' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src_type);
    PyObject *retval = self->_src_type;
    return retval;
}

static int
ops___Extend_set_src_type(mypyc___ir___ops___ExtendObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Extend' object attribute 'src_type' cannot be deleted");
        return -1;
    }
    if (self->_src_type != NULL) {
        CPy_DECREF(self->_src_type);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_rtypes___RType)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src_type = tmp;
    return 0;
}

static PyObject *
ops___Extend_get_signed(mypyc___ir___ops___ExtendObject *self, void *closure)
{
    PyObject *retval = self->_signed ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___Extend_set_signed(mypyc___ir___ops___ExtendObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'Extend' object attribute 'signed' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_signed = tmp;
    return 0;
}

static int
ops___LoadGlobal_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___LoadGlobal_setup(PyTypeObject *type);
PyObject *CPyDef_ops___LoadGlobal(PyObject *cpy_r_type, PyObject *cpy_r_identifier, CPyTagged cpy_r_line, PyObject *cpy_r_ann);

static PyObject *
ops___LoadGlobal_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___LoadGlobal) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___LoadGlobal_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___LoadGlobal_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___LoadGlobal_traverse(mypyc___ir___ops___LoadGlobalObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_identifier);
    Py_VISIT(self->_ann);
    return 0;
}

static int
ops___LoadGlobal_clear(mypyc___ir___ops___LoadGlobalObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_identifier);
    Py_CLEAR(self->_ann);
    return 0;
}

static void
ops___LoadGlobal_dealloc(mypyc___ir___ops___LoadGlobalObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___LoadGlobal_dealloc)
    ops___LoadGlobal_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___LoadGlobal_vtable[16];
static bool
CPyDef_ops___LoadGlobal_trait_vtable_setup(void)
{
    CPyVTableItem ops___LoadGlobal_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___LoadGlobal_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadGlobal_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadGlobal___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___LoadGlobal___accept,
        (CPyVTableItem)CPyDef_ops___LoadGlobal_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadGlobal_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadGlobal_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadGlobal_____init__,
        (CPyVTableItem)CPyDef_ops___LoadGlobal___sources,
        (CPyVTableItem)CPyDef_ops___LoadGlobal___accept,
        (CPyVTableItem)CPyDef_ops___LoadGlobal_____mypyc_defaults_setup,
    };
    memcpy(ops___LoadGlobal_vtable, ops___LoadGlobal_vtable_scratch, sizeof(ops___LoadGlobal_vtable));
    return 1;
}

static PyObject *
ops___LoadGlobal_get_error_kind(mypyc___ir___ops___LoadGlobalObject *self, void *closure);
static int
ops___LoadGlobal_set_error_kind(mypyc___ir___ops___LoadGlobalObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadGlobal_get_is_borrowed(mypyc___ir___ops___LoadGlobalObject *self, void *closure);
static int
ops___LoadGlobal_set_is_borrowed(mypyc___ir___ops___LoadGlobalObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadGlobal_get_identifier(mypyc___ir___ops___LoadGlobalObject *self, void *closure);
static int
ops___LoadGlobal_set_identifier(mypyc___ir___ops___LoadGlobalObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadGlobal_get_ann(mypyc___ir___ops___LoadGlobalObject *self, void *closure);
static int
ops___LoadGlobal_set_ann(mypyc___ir___ops___LoadGlobalObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___LoadGlobal_getseters[] = {
    {"error_kind",
     (getter)ops___LoadGlobal_get_error_kind, (setter)ops___LoadGlobal_set_error_kind,
     NULL, NULL},
    {"is_borrowed",
     (getter)ops___LoadGlobal_get_is_borrowed, (setter)ops___LoadGlobal_set_is_borrowed,
     NULL, NULL},
    {"identifier",
     (getter)ops___LoadGlobal_get_identifier, (setter)ops___LoadGlobal_set_identifier,
     NULL, NULL},
    {"ann",
     (getter)ops___LoadGlobal_get_ann, (setter)ops___LoadGlobal_set_ann,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___LoadGlobal_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___LoadGlobal_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___LoadGlobal___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___LoadGlobal___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___LoadGlobal_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___LoadGlobal_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "LoadGlobal",
    .tp_new = ops___LoadGlobal_new,
    .tp_dealloc = (destructor)ops___LoadGlobal_dealloc,
    .tp_traverse = (traverseproc)ops___LoadGlobal_traverse,
    .tp_clear = (inquiry)ops___LoadGlobal_clear,
    .tp_getset = ops___LoadGlobal_getseters,
    .tp_methods = ops___LoadGlobal_methods,
    .tp_init = ops___LoadGlobal_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___LoadGlobalObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___LoadGlobal_template = &CPyType_ops___LoadGlobal_template_;

static PyObject *
ops___LoadGlobal_setup(PyTypeObject *type)
{
    mypyc___ir___ops___LoadGlobalObject *self;
    self = (mypyc___ir___ops___LoadGlobalObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___LoadGlobal_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_is_borrowed = 2;
    if (CPyDef_ops___LoadGlobal_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___LoadGlobal(PyObject *cpy_r_type, PyObject *cpy_r_identifier, CPyTagged cpy_r_line, PyObject *cpy_r_ann)
{
    PyObject *self = ops___LoadGlobal_setup(CPyType_ops___LoadGlobal);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___LoadGlobal_____init__(self, cpy_r_type, cpy_r_identifier, cpy_r_line, cpy_r_ann);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___LoadGlobal_get_error_kind(mypyc___ir___ops___LoadGlobalObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'LoadGlobal' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___LoadGlobal_set_error_kind(mypyc___ir___ops___LoadGlobalObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadGlobal' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___LoadGlobal_get_is_borrowed(mypyc___ir___ops___LoadGlobalObject *self, void *closure)
{
    PyObject *retval = self->_is_borrowed ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___LoadGlobal_set_is_borrowed(mypyc___ir___ops___LoadGlobalObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadGlobal' object attribute 'is_borrowed' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_is_borrowed = tmp;
    return 0;
}

static PyObject *
ops___LoadGlobal_get_identifier(mypyc___ir___ops___LoadGlobalObject *self, void *closure)
{
    if (unlikely(self->_identifier == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'identifier' of 'LoadGlobal' undefined");
        return NULL;
    }
    CPy_INCREF(self->_identifier);
    PyObject *retval = self->_identifier;
    return retval;
}

static int
ops___LoadGlobal_set_identifier(mypyc___ir___ops___LoadGlobalObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadGlobal' object attribute 'identifier' cannot be deleted");
        return -1;
    }
    if (self->_identifier != NULL) {
        CPy_DECREF(self->_identifier);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_identifier = tmp;
    return 0;
}

static PyObject *
ops___LoadGlobal_get_ann(mypyc___ir___ops___LoadGlobalObject *self, void *closure)
{
    if (unlikely(self->_ann == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'ann' of 'LoadGlobal' undefined");
        return NULL;
    }
    CPy_INCREF(self->_ann);
    PyObject *retval = self->_ann;
    return retval;
}

static int
ops___LoadGlobal_set_ann(mypyc___ir___ops___LoadGlobalObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadGlobal' object attribute 'ann' cannot be deleted");
        return -1;
    }
    if (self->_ann != NULL) {
        CPy_DECREF(self->_ann);
    }
    PyObject *tmp = value;
    CPy_INCREF(tmp);
    self->_ann = tmp;
    return 0;
}

static int
ops___IntOp_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___IntOp_setup(PyTypeObject *type);
PyObject *CPyDef_ops___IntOp(PyObject *cpy_r_type, PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line);

static PyObject *
ops___IntOp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___IntOp) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___IntOp_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___IntOp_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___IntOp_traverse(mypyc___ir___ops___IntOpObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    if (CPyTagged_CheckLong(self->_ADD)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_ADD));
    }
    if (CPyTagged_CheckLong(self->_SUB)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_SUB));
    }
    if (CPyTagged_CheckLong(self->_MUL)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_MUL));
    }
    if (CPyTagged_CheckLong(self->_DIV)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_DIV));
    }
    if (CPyTagged_CheckLong(self->_MOD)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_MOD));
    }
    if (CPyTagged_CheckLong(self->_AND)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_AND));
    }
    if (CPyTagged_CheckLong(self->_OR)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_OR));
    }
    if (CPyTagged_CheckLong(self->_XOR)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_XOR));
    }
    if (CPyTagged_CheckLong(self->_LEFT_SHIFT)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_LEFT_SHIFT));
    }
    if (CPyTagged_CheckLong(self->_RIGHT_SHIFT)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_RIGHT_SHIFT));
    }
    Py_VISIT(self->_op_str);
    Py_VISIT(self->_lhs);
    Py_VISIT(self->_rhs);
    if (CPyTagged_CheckLong(self->_op)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_op));
    }
    return 0;
}

static int
ops___IntOp_clear(mypyc___ir___ops___IntOpObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_ADD)) {
        CPyTagged __tmp = self->_ADD;
        self->_ADD = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_SUB)) {
        CPyTagged __tmp = self->_SUB;
        self->_SUB = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_MUL)) {
        CPyTagged __tmp = self->_MUL;
        self->_MUL = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_DIV)) {
        CPyTagged __tmp = self->_DIV;
        self->_DIV = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_MOD)) {
        CPyTagged __tmp = self->_MOD;
        self->_MOD = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_AND)) {
        CPyTagged __tmp = self->_AND;
        self->_AND = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_OR)) {
        CPyTagged __tmp = self->_OR;
        self->_OR = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_XOR)) {
        CPyTagged __tmp = self->_XOR;
        self->_XOR = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_LEFT_SHIFT)) {
        CPyTagged __tmp = self->_LEFT_SHIFT;
        self->_LEFT_SHIFT = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_RIGHT_SHIFT)) {
        CPyTagged __tmp = self->_RIGHT_SHIFT;
        self->_RIGHT_SHIFT = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_op_str);
    Py_CLEAR(self->_lhs);
    Py_CLEAR(self->_rhs);
    if (CPyTagged_CheckLong(self->_op)) {
        CPyTagged __tmp = self->_op;
        self->_op = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    return 0;
}

static void
ops___IntOp_dealloc(mypyc___ir___ops___IntOpObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___IntOp_dealloc)
    ops___IntOp_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___IntOp_vtable[16];
static bool
CPyDef_ops___IntOp_trait_vtable_setup(void)
{
    CPyVTableItem ops___IntOp_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___IntOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___IntOp_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___IntOp___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___IntOp___accept,
        (CPyVTableItem)CPyDef_ops___IntOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___IntOp_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___IntOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___IntOp_____init__,
        (CPyVTableItem)CPyDef_ops___IntOp___sources,
        (CPyVTableItem)CPyDef_ops___IntOp___accept,
        (CPyVTableItem)CPyDef_ops___IntOp_____mypyc_defaults_setup,
    };
    memcpy(ops___IntOp_vtable, ops___IntOp_vtable_scratch, sizeof(ops___IntOp_vtable));
    return 1;
}

static PyObject *
ops___IntOp_get_error_kind(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_error_kind(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_ADD(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_ADD(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_SUB(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_SUB(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_MUL(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_MUL(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_DIV(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_DIV(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_MOD(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_MOD(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_AND(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_AND(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_OR(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_OR(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_XOR(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_XOR(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_LEFT_SHIFT(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_LEFT_SHIFT(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_RIGHT_SHIFT(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_RIGHT_SHIFT(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_op_str(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_op_str(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_lhs(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_lhs(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_rhs(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_rhs(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___IntOp_get_op(mypyc___ir___ops___IntOpObject *self, void *closure);
static int
ops___IntOp_set_op(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___IntOp_getseters[] = {
    {"error_kind",
     (getter)ops___IntOp_get_error_kind, (setter)ops___IntOp_set_error_kind,
     NULL, NULL},
    {"ADD",
     (getter)ops___IntOp_get_ADD, (setter)ops___IntOp_set_ADD,
     NULL, NULL},
    {"SUB",
     (getter)ops___IntOp_get_SUB, (setter)ops___IntOp_set_SUB,
     NULL, NULL},
    {"MUL",
     (getter)ops___IntOp_get_MUL, (setter)ops___IntOp_set_MUL,
     NULL, NULL},
    {"DIV",
     (getter)ops___IntOp_get_DIV, (setter)ops___IntOp_set_DIV,
     NULL, NULL},
    {"MOD",
     (getter)ops___IntOp_get_MOD, (setter)ops___IntOp_set_MOD,
     NULL, NULL},
    {"AND",
     (getter)ops___IntOp_get_AND, (setter)ops___IntOp_set_AND,
     NULL, NULL},
    {"OR",
     (getter)ops___IntOp_get_OR, (setter)ops___IntOp_set_OR,
     NULL, NULL},
    {"XOR",
     (getter)ops___IntOp_get_XOR, (setter)ops___IntOp_set_XOR,
     NULL, NULL},
    {"LEFT_SHIFT",
     (getter)ops___IntOp_get_LEFT_SHIFT, (setter)ops___IntOp_set_LEFT_SHIFT,
     NULL, NULL},
    {"RIGHT_SHIFT",
     (getter)ops___IntOp_get_RIGHT_SHIFT, (setter)ops___IntOp_set_RIGHT_SHIFT,
     NULL, NULL},
    {"op_str",
     (getter)ops___IntOp_get_op_str, (setter)ops___IntOp_set_op_str,
     NULL, NULL},
    {"lhs",
     (getter)ops___IntOp_get_lhs, (setter)ops___IntOp_set_lhs,
     NULL, NULL},
    {"rhs",
     (getter)ops___IntOp_get_rhs, (setter)ops___IntOp_set_rhs,
     NULL, NULL},
    {"op",
     (getter)ops___IntOp_get_op, (setter)ops___IntOp_set_op,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___IntOp_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___IntOp_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___IntOp___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___IntOp___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___IntOp_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___IntOp_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "IntOp",
    .tp_new = ops___IntOp_new,
    .tp_dealloc = (destructor)ops___IntOp_dealloc,
    .tp_traverse = (traverseproc)ops___IntOp_traverse,
    .tp_clear = (inquiry)ops___IntOp_clear,
    .tp_getset = ops___IntOp_getseters,
    .tp_methods = ops___IntOp_methods,
    .tp_init = ops___IntOp_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___IntOpObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___IntOp_template = &CPyType_ops___IntOp_template_;

static PyObject *
ops___IntOp_setup(PyTypeObject *type)
{
    mypyc___ir___ops___IntOpObject *self;
    self = (mypyc___ir___ops___IntOpObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___IntOp_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_ADD = CPY_INT_TAG;
    self->_SUB = CPY_INT_TAG;
    self->_MUL = CPY_INT_TAG;
    self->_DIV = CPY_INT_TAG;
    self->_MOD = CPY_INT_TAG;
    self->_AND = CPY_INT_TAG;
    self->_OR = CPY_INT_TAG;
    self->_XOR = CPY_INT_TAG;
    self->_LEFT_SHIFT = CPY_INT_TAG;
    self->_RIGHT_SHIFT = CPY_INT_TAG;
    self->_op = CPY_INT_TAG;
    if (CPyDef_ops___IntOp_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___IntOp(PyObject *cpy_r_type, PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line)
{
    PyObject *self = ops___IntOp_setup(CPyType_ops___IntOp);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___IntOp_____init__(self, cpy_r_type, cpy_r_lhs, cpy_r_rhs, cpy_r_op, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___IntOp_get_error_kind(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___IntOp_set_error_kind(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_ADD(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_ADD == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'ADD' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_ADD);
    PyObject *retval = CPyTagged_StealAsObject(self->_ADD);
    return retval;
}

static int
ops___IntOp_set_ADD(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'ADD' cannot be deleted");
        return -1;
    }
    if (self->_ADD != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_ADD);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_ADD = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_SUB(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_SUB == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'SUB' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_SUB);
    PyObject *retval = CPyTagged_StealAsObject(self->_SUB);
    return retval;
}

static int
ops___IntOp_set_SUB(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'SUB' cannot be deleted");
        return -1;
    }
    if (self->_SUB != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_SUB);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_SUB = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_MUL(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_MUL == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'MUL' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_MUL);
    PyObject *retval = CPyTagged_StealAsObject(self->_MUL);
    return retval;
}

static int
ops___IntOp_set_MUL(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'MUL' cannot be deleted");
        return -1;
    }
    if (self->_MUL != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_MUL);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_MUL = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_DIV(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_DIV == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'DIV' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_DIV);
    PyObject *retval = CPyTagged_StealAsObject(self->_DIV);
    return retval;
}

static int
ops___IntOp_set_DIV(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'DIV' cannot be deleted");
        return -1;
    }
    if (self->_DIV != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_DIV);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_DIV = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_MOD(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_MOD == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'MOD' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_MOD);
    PyObject *retval = CPyTagged_StealAsObject(self->_MOD);
    return retval;
}

static int
ops___IntOp_set_MOD(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'MOD' cannot be deleted");
        return -1;
    }
    if (self->_MOD != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_MOD);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_MOD = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_AND(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_AND == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'AND' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_AND);
    PyObject *retval = CPyTagged_StealAsObject(self->_AND);
    return retval;
}

static int
ops___IntOp_set_AND(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'AND' cannot be deleted");
        return -1;
    }
    if (self->_AND != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_AND);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_AND = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_OR(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_OR == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'OR' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_OR);
    PyObject *retval = CPyTagged_StealAsObject(self->_OR);
    return retval;
}

static int
ops___IntOp_set_OR(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'OR' cannot be deleted");
        return -1;
    }
    if (self->_OR != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_OR);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_OR = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_XOR(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_XOR == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'XOR' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_XOR);
    PyObject *retval = CPyTagged_StealAsObject(self->_XOR);
    return retval;
}

static int
ops___IntOp_set_XOR(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'XOR' cannot be deleted");
        return -1;
    }
    if (self->_XOR != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_XOR);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_XOR = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_LEFT_SHIFT(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_LEFT_SHIFT == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'LEFT_SHIFT' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_LEFT_SHIFT);
    PyObject *retval = CPyTagged_StealAsObject(self->_LEFT_SHIFT);
    return retval;
}

static int
ops___IntOp_set_LEFT_SHIFT(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'LEFT_SHIFT' cannot be deleted");
        return -1;
    }
    if (self->_LEFT_SHIFT != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_LEFT_SHIFT);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_LEFT_SHIFT = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_RIGHT_SHIFT(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_RIGHT_SHIFT == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'RIGHT_SHIFT' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_RIGHT_SHIFT);
    PyObject *retval = CPyTagged_StealAsObject(self->_RIGHT_SHIFT);
    return retval;
}

static int
ops___IntOp_set_RIGHT_SHIFT(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'RIGHT_SHIFT' cannot be deleted");
        return -1;
    }
    if (self->_RIGHT_SHIFT != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_RIGHT_SHIFT);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_RIGHT_SHIFT = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_op_str(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_op_str == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'op_str' of 'IntOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_op_str);
    PyObject *retval = self->_op_str;
    return retval;
}

static int
ops___IntOp_set_op_str(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'op_str' cannot be deleted");
        return -1;
    }
    if (self->_op_str != NULL) {
        CPy_DECREF(self->_op_str);
    }
    PyObject *tmp;
    if (likely(PyDict_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("dict", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_op_str = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_lhs(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_lhs == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'lhs' of 'IntOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_lhs);
    PyObject *retval = self->_lhs;
    return retval;
}

static int
ops___IntOp_set_lhs(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'lhs' cannot be deleted");
        return -1;
    }
    if (self->_lhs != NULL) {
        CPy_DECREF(self->_lhs);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_lhs = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_rhs(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_rhs == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'rhs' of 'IntOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_rhs);
    PyObject *retval = self->_rhs;
    return retval;
}

static int
ops___IntOp_set_rhs(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'rhs' cannot be deleted");
        return -1;
    }
    if (self->_rhs != NULL) {
        CPy_DECREF(self->_rhs);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_rhs = tmp;
    return 0;
}

static PyObject *
ops___IntOp_get_op(mypyc___ir___ops___IntOpObject *self, void *closure)
{
    if (unlikely(self->_op == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'op' of 'IntOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_op);
    PyObject *retval = CPyTagged_StealAsObject(self->_op);
    return retval;
}

static int
ops___IntOp_set_op(mypyc___ir___ops___IntOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'IntOp' object attribute 'op' cannot be deleted");
        return -1;
    }
    if (self->_op != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_op);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_op = tmp;
    return 0;
}

static int
ops___ComparisonOp_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___ComparisonOp_setup(PyTypeObject *type);
PyObject *CPyDef_ops___ComparisonOp(PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line);

static PyObject *
ops___ComparisonOp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___ComparisonOp) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___ComparisonOp_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___ComparisonOp_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___ComparisonOp_traverse(mypyc___ir___ops___ComparisonOpObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    if (CPyTagged_CheckLong(self->_EQ)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_EQ));
    }
    if (CPyTagged_CheckLong(self->_NEQ)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_NEQ));
    }
    if (CPyTagged_CheckLong(self->_SLT)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_SLT));
    }
    if (CPyTagged_CheckLong(self->_SGT)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_SGT));
    }
    if (CPyTagged_CheckLong(self->_SLE)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_SLE));
    }
    if (CPyTagged_CheckLong(self->_SGE)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_SGE));
    }
    if (CPyTagged_CheckLong(self->_ULT)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_ULT));
    }
    if (CPyTagged_CheckLong(self->_UGT)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_UGT));
    }
    if (CPyTagged_CheckLong(self->_ULE)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_ULE));
    }
    if (CPyTagged_CheckLong(self->_UGE)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_UGE));
    }
    Py_VISIT(self->_op_str);
    Py_VISIT(self->_signed_ops);
    Py_VISIT(self->_unsigned_ops);
    Py_VISIT(self->_lhs);
    Py_VISIT(self->_rhs);
    if (CPyTagged_CheckLong(self->_op)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_op));
    }
    return 0;
}

static int
ops___ComparisonOp_clear(mypyc___ir___ops___ComparisonOpObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_EQ)) {
        CPyTagged __tmp = self->_EQ;
        self->_EQ = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_NEQ)) {
        CPyTagged __tmp = self->_NEQ;
        self->_NEQ = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_SLT)) {
        CPyTagged __tmp = self->_SLT;
        self->_SLT = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_SGT)) {
        CPyTagged __tmp = self->_SGT;
        self->_SGT = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_SLE)) {
        CPyTagged __tmp = self->_SLE;
        self->_SLE = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_SGE)) {
        CPyTagged __tmp = self->_SGE;
        self->_SGE = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_ULT)) {
        CPyTagged __tmp = self->_ULT;
        self->_ULT = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_UGT)) {
        CPyTagged __tmp = self->_UGT;
        self->_UGT = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_ULE)) {
        CPyTagged __tmp = self->_ULE;
        self->_ULE = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_UGE)) {
        CPyTagged __tmp = self->_UGE;
        self->_UGE = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_op_str);
    Py_CLEAR(self->_signed_ops);
    Py_CLEAR(self->_unsigned_ops);
    Py_CLEAR(self->_lhs);
    Py_CLEAR(self->_rhs);
    if (CPyTagged_CheckLong(self->_op)) {
        CPyTagged __tmp = self->_op;
        self->_op = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    return 0;
}

static void
ops___ComparisonOp_dealloc(mypyc___ir___ops___ComparisonOpObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___ComparisonOp_dealloc)
    ops___ComparisonOp_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___ComparisonOp_vtable[16];
static bool
CPyDef_ops___ComparisonOp_trait_vtable_setup(void)
{
    CPyVTableItem ops___ComparisonOp_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___ComparisonOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___ComparisonOp_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___ComparisonOp___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___ComparisonOp___accept,
        (CPyVTableItem)CPyDef_ops___ComparisonOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___ComparisonOp_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___ComparisonOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___ComparisonOp_____init__,
        (CPyVTableItem)CPyDef_ops___ComparisonOp___sources,
        (CPyVTableItem)CPyDef_ops___ComparisonOp___accept,
        (CPyVTableItem)CPyDef_ops___ComparisonOp_____mypyc_defaults_setup,
    };
    memcpy(ops___ComparisonOp_vtable, ops___ComparisonOp_vtable_scratch, sizeof(ops___ComparisonOp_vtable));
    return 1;
}

static PyObject *
ops___ComparisonOp_get_error_kind(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_error_kind(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_EQ(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_EQ(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_NEQ(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_NEQ(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_SLT(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_SLT(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_SGT(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_SGT(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_SLE(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_SLE(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_SGE(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_SGE(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_ULT(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_ULT(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_UGT(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_UGT(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_ULE(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_ULE(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_UGE(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_UGE(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_op_str(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_op_str(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_signed_ops(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_signed_ops(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_unsigned_ops(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_unsigned_ops(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_lhs(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_lhs(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_rhs(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_rhs(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___ComparisonOp_get_op(mypyc___ir___ops___ComparisonOpObject *self, void *closure);
static int
ops___ComparisonOp_set_op(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___ComparisonOp_getseters[] = {
    {"error_kind",
     (getter)ops___ComparisonOp_get_error_kind, (setter)ops___ComparisonOp_set_error_kind,
     NULL, NULL},
    {"EQ",
     (getter)ops___ComparisonOp_get_EQ, (setter)ops___ComparisonOp_set_EQ,
     NULL, NULL},
    {"NEQ",
     (getter)ops___ComparisonOp_get_NEQ, (setter)ops___ComparisonOp_set_NEQ,
     NULL, NULL},
    {"SLT",
     (getter)ops___ComparisonOp_get_SLT, (setter)ops___ComparisonOp_set_SLT,
     NULL, NULL},
    {"SGT",
     (getter)ops___ComparisonOp_get_SGT, (setter)ops___ComparisonOp_set_SGT,
     NULL, NULL},
    {"SLE",
     (getter)ops___ComparisonOp_get_SLE, (setter)ops___ComparisonOp_set_SLE,
     NULL, NULL},
    {"SGE",
     (getter)ops___ComparisonOp_get_SGE, (setter)ops___ComparisonOp_set_SGE,
     NULL, NULL},
    {"ULT",
     (getter)ops___ComparisonOp_get_ULT, (setter)ops___ComparisonOp_set_ULT,
     NULL, NULL},
    {"UGT",
     (getter)ops___ComparisonOp_get_UGT, (setter)ops___ComparisonOp_set_UGT,
     NULL, NULL},
    {"ULE",
     (getter)ops___ComparisonOp_get_ULE, (setter)ops___ComparisonOp_set_ULE,
     NULL, NULL},
    {"UGE",
     (getter)ops___ComparisonOp_get_UGE, (setter)ops___ComparisonOp_set_UGE,
     NULL, NULL},
    {"op_str",
     (getter)ops___ComparisonOp_get_op_str, (setter)ops___ComparisonOp_set_op_str,
     NULL, NULL},
    {"signed_ops",
     (getter)ops___ComparisonOp_get_signed_ops, (setter)ops___ComparisonOp_set_signed_ops,
     NULL, NULL},
    {"unsigned_ops",
     (getter)ops___ComparisonOp_get_unsigned_ops, (setter)ops___ComparisonOp_set_unsigned_ops,
     NULL, NULL},
    {"lhs",
     (getter)ops___ComparisonOp_get_lhs, (setter)ops___ComparisonOp_set_lhs,
     NULL, NULL},
    {"rhs",
     (getter)ops___ComparisonOp_get_rhs, (setter)ops___ComparisonOp_set_rhs,
     NULL, NULL},
    {"op",
     (getter)ops___ComparisonOp_get_op, (setter)ops___ComparisonOp_set_op,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___ComparisonOp_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___ComparisonOp_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___ComparisonOp___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___ComparisonOp___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___ComparisonOp_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___ComparisonOp_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "ComparisonOp",
    .tp_new = ops___ComparisonOp_new,
    .tp_dealloc = (destructor)ops___ComparisonOp_dealloc,
    .tp_traverse = (traverseproc)ops___ComparisonOp_traverse,
    .tp_clear = (inquiry)ops___ComparisonOp_clear,
    .tp_getset = ops___ComparisonOp_getseters,
    .tp_methods = ops___ComparisonOp_methods,
    .tp_init = ops___ComparisonOp_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___ComparisonOpObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___ComparisonOp_template = &CPyType_ops___ComparisonOp_template_;

static PyObject *
ops___ComparisonOp_setup(PyTypeObject *type)
{
    mypyc___ir___ops___ComparisonOpObject *self;
    self = (mypyc___ir___ops___ComparisonOpObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___ComparisonOp_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_EQ = CPY_INT_TAG;
    self->_NEQ = CPY_INT_TAG;
    self->_SLT = CPY_INT_TAG;
    self->_SGT = CPY_INT_TAG;
    self->_SLE = CPY_INT_TAG;
    self->_SGE = CPY_INT_TAG;
    self->_ULT = CPY_INT_TAG;
    self->_UGT = CPY_INT_TAG;
    self->_ULE = CPY_INT_TAG;
    self->_UGE = CPY_INT_TAG;
    self->_op = CPY_INT_TAG;
    if (CPyDef_ops___ComparisonOp_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___ComparisonOp(PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line)
{
    PyObject *self = ops___ComparisonOp_setup(CPyType_ops___ComparisonOp);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___ComparisonOp_____init__(self, cpy_r_lhs, cpy_r_rhs, cpy_r_op, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___ComparisonOp_get_error_kind(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___ComparisonOp_set_error_kind(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_EQ(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_EQ == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'EQ' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_EQ);
    PyObject *retval = CPyTagged_StealAsObject(self->_EQ);
    return retval;
}

static int
ops___ComparisonOp_set_EQ(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'EQ' cannot be deleted");
        return -1;
    }
    if (self->_EQ != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_EQ);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_EQ = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_NEQ(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_NEQ == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'NEQ' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_NEQ);
    PyObject *retval = CPyTagged_StealAsObject(self->_NEQ);
    return retval;
}

static int
ops___ComparisonOp_set_NEQ(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'NEQ' cannot be deleted");
        return -1;
    }
    if (self->_NEQ != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_NEQ);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_NEQ = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_SLT(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_SLT == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'SLT' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_SLT);
    PyObject *retval = CPyTagged_StealAsObject(self->_SLT);
    return retval;
}

static int
ops___ComparisonOp_set_SLT(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'SLT' cannot be deleted");
        return -1;
    }
    if (self->_SLT != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_SLT);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_SLT = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_SGT(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_SGT == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'SGT' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_SGT);
    PyObject *retval = CPyTagged_StealAsObject(self->_SGT);
    return retval;
}

static int
ops___ComparisonOp_set_SGT(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'SGT' cannot be deleted");
        return -1;
    }
    if (self->_SGT != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_SGT);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_SGT = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_SLE(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_SLE == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'SLE' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_SLE);
    PyObject *retval = CPyTagged_StealAsObject(self->_SLE);
    return retval;
}

static int
ops___ComparisonOp_set_SLE(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'SLE' cannot be deleted");
        return -1;
    }
    if (self->_SLE != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_SLE);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_SLE = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_SGE(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_SGE == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'SGE' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_SGE);
    PyObject *retval = CPyTagged_StealAsObject(self->_SGE);
    return retval;
}

static int
ops___ComparisonOp_set_SGE(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'SGE' cannot be deleted");
        return -1;
    }
    if (self->_SGE != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_SGE);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_SGE = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_ULT(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_ULT == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'ULT' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_ULT);
    PyObject *retval = CPyTagged_StealAsObject(self->_ULT);
    return retval;
}

static int
ops___ComparisonOp_set_ULT(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'ULT' cannot be deleted");
        return -1;
    }
    if (self->_ULT != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_ULT);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_ULT = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_UGT(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_UGT == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'UGT' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_UGT);
    PyObject *retval = CPyTagged_StealAsObject(self->_UGT);
    return retval;
}

static int
ops___ComparisonOp_set_UGT(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'UGT' cannot be deleted");
        return -1;
    }
    if (self->_UGT != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_UGT);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_UGT = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_ULE(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_ULE == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'ULE' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_ULE);
    PyObject *retval = CPyTagged_StealAsObject(self->_ULE);
    return retval;
}

static int
ops___ComparisonOp_set_ULE(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'ULE' cannot be deleted");
        return -1;
    }
    if (self->_ULE != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_ULE);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_ULE = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_UGE(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_UGE == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'UGE' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_UGE);
    PyObject *retval = CPyTagged_StealAsObject(self->_UGE);
    return retval;
}

static int
ops___ComparisonOp_set_UGE(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'UGE' cannot be deleted");
        return -1;
    }
    if (self->_UGE != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_UGE);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_UGE = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_op_str(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_op_str == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'op_str' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_op_str);
    PyObject *retval = self->_op_str;
    return retval;
}

static int
ops___ComparisonOp_set_op_str(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'op_str' cannot be deleted");
        return -1;
    }
    if (self->_op_str != NULL) {
        CPy_DECREF(self->_op_str);
    }
    PyObject *tmp;
    if (likely(PyDict_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("dict", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_op_str = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_signed_ops(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_signed_ops == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'signed_ops' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_signed_ops);
    PyObject *retval = self->_signed_ops;
    return retval;
}

static int
ops___ComparisonOp_set_signed_ops(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'signed_ops' cannot be deleted");
        return -1;
    }
    if (self->_signed_ops != NULL) {
        CPy_DECREF(self->_signed_ops);
    }
    PyObject *tmp;
    if (likely(PyDict_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("dict", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_signed_ops = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_unsigned_ops(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_unsigned_ops == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'unsigned_ops' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_unsigned_ops);
    PyObject *retval = self->_unsigned_ops;
    return retval;
}

static int
ops___ComparisonOp_set_unsigned_ops(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'unsigned_ops' cannot be deleted");
        return -1;
    }
    if (self->_unsigned_ops != NULL) {
        CPy_DECREF(self->_unsigned_ops);
    }
    PyObject *tmp;
    if (likely(PyDict_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("dict", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_unsigned_ops = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_lhs(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_lhs == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'lhs' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_lhs);
    PyObject *retval = self->_lhs;
    return retval;
}

static int
ops___ComparisonOp_set_lhs(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'lhs' cannot be deleted");
        return -1;
    }
    if (self->_lhs != NULL) {
        CPy_DECREF(self->_lhs);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_lhs = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_rhs(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_rhs == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'rhs' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_rhs);
    PyObject *retval = self->_rhs;
    return retval;
}

static int
ops___ComparisonOp_set_rhs(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'rhs' cannot be deleted");
        return -1;
    }
    if (self->_rhs != NULL) {
        CPy_DECREF(self->_rhs);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_rhs = tmp;
    return 0;
}

static PyObject *
ops___ComparisonOp_get_op(mypyc___ir___ops___ComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_op == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'op' of 'ComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_op);
    PyObject *retval = CPyTagged_StealAsObject(self->_op);
    return retval;
}

static int
ops___ComparisonOp_set_op(mypyc___ir___ops___ComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'ComparisonOp' object attribute 'op' cannot be deleted");
        return -1;
    }
    if (self->_op != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_op);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_op = tmp;
    return 0;
}

static int
ops___FloatOp_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___FloatOp_setup(PyTypeObject *type);
PyObject *CPyDef_ops___FloatOp(PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line);

static PyObject *
ops___FloatOp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___FloatOp) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___FloatOp_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___FloatOp_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___FloatOp_traverse(mypyc___ir___ops___FloatOpObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    if (CPyTagged_CheckLong(self->_ADD)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_ADD));
    }
    if (CPyTagged_CheckLong(self->_SUB)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_SUB));
    }
    if (CPyTagged_CheckLong(self->_MUL)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_MUL));
    }
    if (CPyTagged_CheckLong(self->_DIV)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_DIV));
    }
    if (CPyTagged_CheckLong(self->_MOD)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_MOD));
    }
    Py_VISIT(self->_op_str);
    Py_VISIT(self->_lhs);
    Py_VISIT(self->_rhs);
    if (CPyTagged_CheckLong(self->_op)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_op));
    }
    return 0;
}

static int
ops___FloatOp_clear(mypyc___ir___ops___FloatOpObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_ADD)) {
        CPyTagged __tmp = self->_ADD;
        self->_ADD = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_SUB)) {
        CPyTagged __tmp = self->_SUB;
        self->_SUB = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_MUL)) {
        CPyTagged __tmp = self->_MUL;
        self->_MUL = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_DIV)) {
        CPyTagged __tmp = self->_DIV;
        self->_DIV = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_MOD)) {
        CPyTagged __tmp = self->_MOD;
        self->_MOD = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_op_str);
    Py_CLEAR(self->_lhs);
    Py_CLEAR(self->_rhs);
    if (CPyTagged_CheckLong(self->_op)) {
        CPyTagged __tmp = self->_op;
        self->_op = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    return 0;
}

static void
ops___FloatOp_dealloc(mypyc___ir___ops___FloatOpObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___FloatOp_dealloc)
    ops___FloatOp_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___FloatOp_vtable[16];
static bool
CPyDef_ops___FloatOp_trait_vtable_setup(void)
{
    CPyVTableItem ops___FloatOp_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___FloatOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___FloatOp_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___FloatOp___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___FloatOp___accept,
        (CPyVTableItem)CPyDef_ops___FloatOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___FloatOp_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___FloatOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___FloatOp_____init__,
        (CPyVTableItem)CPyDef_ops___FloatOp___sources,
        (CPyVTableItem)CPyDef_ops___FloatOp___accept,
        (CPyVTableItem)CPyDef_ops___FloatOp_____mypyc_defaults_setup,
    };
    memcpy(ops___FloatOp_vtable, ops___FloatOp_vtable_scratch, sizeof(ops___FloatOp_vtable));
    return 1;
}

static PyObject *
ops___FloatOp_get_error_kind(mypyc___ir___ops___FloatOpObject *self, void *closure);
static int
ops___FloatOp_set_error_kind(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatOp_get_ADD(mypyc___ir___ops___FloatOpObject *self, void *closure);
static int
ops___FloatOp_set_ADD(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatOp_get_SUB(mypyc___ir___ops___FloatOpObject *self, void *closure);
static int
ops___FloatOp_set_SUB(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatOp_get_MUL(mypyc___ir___ops___FloatOpObject *self, void *closure);
static int
ops___FloatOp_set_MUL(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatOp_get_DIV(mypyc___ir___ops___FloatOpObject *self, void *closure);
static int
ops___FloatOp_set_DIV(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatOp_get_MOD(mypyc___ir___ops___FloatOpObject *self, void *closure);
static int
ops___FloatOp_set_MOD(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatOp_get_op_str(mypyc___ir___ops___FloatOpObject *self, void *closure);
static int
ops___FloatOp_set_op_str(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatOp_get_lhs(mypyc___ir___ops___FloatOpObject *self, void *closure);
static int
ops___FloatOp_set_lhs(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatOp_get_rhs(mypyc___ir___ops___FloatOpObject *self, void *closure);
static int
ops___FloatOp_set_rhs(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatOp_get_op(mypyc___ir___ops___FloatOpObject *self, void *closure);
static int
ops___FloatOp_set_op(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___FloatOp_getseters[] = {
    {"error_kind",
     (getter)ops___FloatOp_get_error_kind, (setter)ops___FloatOp_set_error_kind,
     NULL, NULL},
    {"ADD",
     (getter)ops___FloatOp_get_ADD, (setter)ops___FloatOp_set_ADD,
     NULL, NULL},
    {"SUB",
     (getter)ops___FloatOp_get_SUB, (setter)ops___FloatOp_set_SUB,
     NULL, NULL},
    {"MUL",
     (getter)ops___FloatOp_get_MUL, (setter)ops___FloatOp_set_MUL,
     NULL, NULL},
    {"DIV",
     (getter)ops___FloatOp_get_DIV, (setter)ops___FloatOp_set_DIV,
     NULL, NULL},
    {"MOD",
     (getter)ops___FloatOp_get_MOD, (setter)ops___FloatOp_set_MOD,
     NULL, NULL},
    {"op_str",
     (getter)ops___FloatOp_get_op_str, (setter)ops___FloatOp_set_op_str,
     NULL, NULL},
    {"lhs",
     (getter)ops___FloatOp_get_lhs, (setter)ops___FloatOp_set_lhs,
     NULL, NULL},
    {"rhs",
     (getter)ops___FloatOp_get_rhs, (setter)ops___FloatOp_set_rhs,
     NULL, NULL},
    {"op",
     (getter)ops___FloatOp_get_op, (setter)ops___FloatOp_set_op,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___FloatOp_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___FloatOp_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___FloatOp___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___FloatOp___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___FloatOp_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___FloatOp_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "FloatOp",
    .tp_new = ops___FloatOp_new,
    .tp_dealloc = (destructor)ops___FloatOp_dealloc,
    .tp_traverse = (traverseproc)ops___FloatOp_traverse,
    .tp_clear = (inquiry)ops___FloatOp_clear,
    .tp_getset = ops___FloatOp_getseters,
    .tp_methods = ops___FloatOp_methods,
    .tp_init = ops___FloatOp_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___FloatOpObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___FloatOp_template = &CPyType_ops___FloatOp_template_;

static PyObject *
ops___FloatOp_setup(PyTypeObject *type)
{
    mypyc___ir___ops___FloatOpObject *self;
    self = (mypyc___ir___ops___FloatOpObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___FloatOp_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_ADD = CPY_INT_TAG;
    self->_SUB = CPY_INT_TAG;
    self->_MUL = CPY_INT_TAG;
    self->_DIV = CPY_INT_TAG;
    self->_MOD = CPY_INT_TAG;
    self->_op = CPY_INT_TAG;
    if (CPyDef_ops___FloatOp_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___FloatOp(PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line)
{
    PyObject *self = ops___FloatOp_setup(CPyType_ops___FloatOp);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___FloatOp_____init__(self, cpy_r_lhs, cpy_r_rhs, cpy_r_op, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___FloatOp_get_error_kind(mypyc___ir___ops___FloatOpObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'FloatOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___FloatOp_set_error_kind(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatOp' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___FloatOp_get_ADD(mypyc___ir___ops___FloatOpObject *self, void *closure)
{
    if (unlikely(self->_ADD == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'ADD' of 'FloatOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_ADD);
    PyObject *retval = CPyTagged_StealAsObject(self->_ADD);
    return retval;
}

static int
ops___FloatOp_set_ADD(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatOp' object attribute 'ADD' cannot be deleted");
        return -1;
    }
    if (self->_ADD != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_ADD);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_ADD = tmp;
    return 0;
}

static PyObject *
ops___FloatOp_get_SUB(mypyc___ir___ops___FloatOpObject *self, void *closure)
{
    if (unlikely(self->_SUB == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'SUB' of 'FloatOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_SUB);
    PyObject *retval = CPyTagged_StealAsObject(self->_SUB);
    return retval;
}

static int
ops___FloatOp_set_SUB(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatOp' object attribute 'SUB' cannot be deleted");
        return -1;
    }
    if (self->_SUB != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_SUB);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_SUB = tmp;
    return 0;
}

static PyObject *
ops___FloatOp_get_MUL(mypyc___ir___ops___FloatOpObject *self, void *closure)
{
    if (unlikely(self->_MUL == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'MUL' of 'FloatOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_MUL);
    PyObject *retval = CPyTagged_StealAsObject(self->_MUL);
    return retval;
}

static int
ops___FloatOp_set_MUL(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatOp' object attribute 'MUL' cannot be deleted");
        return -1;
    }
    if (self->_MUL != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_MUL);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_MUL = tmp;
    return 0;
}

static PyObject *
ops___FloatOp_get_DIV(mypyc___ir___ops___FloatOpObject *self, void *closure)
{
    if (unlikely(self->_DIV == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'DIV' of 'FloatOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_DIV);
    PyObject *retval = CPyTagged_StealAsObject(self->_DIV);
    return retval;
}

static int
ops___FloatOp_set_DIV(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatOp' object attribute 'DIV' cannot be deleted");
        return -1;
    }
    if (self->_DIV != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_DIV);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_DIV = tmp;
    return 0;
}

static PyObject *
ops___FloatOp_get_MOD(mypyc___ir___ops___FloatOpObject *self, void *closure)
{
    if (unlikely(self->_MOD == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'MOD' of 'FloatOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_MOD);
    PyObject *retval = CPyTagged_StealAsObject(self->_MOD);
    return retval;
}

static int
ops___FloatOp_set_MOD(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatOp' object attribute 'MOD' cannot be deleted");
        return -1;
    }
    if (self->_MOD != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_MOD);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_MOD = tmp;
    return 0;
}

static PyObject *
ops___FloatOp_get_op_str(mypyc___ir___ops___FloatOpObject *self, void *closure)
{
    if (unlikely(self->_op_str == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'op_str' of 'FloatOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_op_str);
    PyObject *retval = self->_op_str;
    return retval;
}

static int
ops___FloatOp_set_op_str(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatOp' object attribute 'op_str' cannot be deleted");
        return -1;
    }
    if (self->_op_str != NULL) {
        CPy_DECREF(self->_op_str);
    }
    PyObject *tmp;
    if (likely(PyDict_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("dict", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_op_str = tmp;
    return 0;
}

static PyObject *
ops___FloatOp_get_lhs(mypyc___ir___ops___FloatOpObject *self, void *closure)
{
    if (unlikely(self->_lhs == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'lhs' of 'FloatOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_lhs);
    PyObject *retval = self->_lhs;
    return retval;
}

static int
ops___FloatOp_set_lhs(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatOp' object attribute 'lhs' cannot be deleted");
        return -1;
    }
    if (self->_lhs != NULL) {
        CPy_DECREF(self->_lhs);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_lhs = tmp;
    return 0;
}

static PyObject *
ops___FloatOp_get_rhs(mypyc___ir___ops___FloatOpObject *self, void *closure)
{
    if (unlikely(self->_rhs == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'rhs' of 'FloatOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_rhs);
    PyObject *retval = self->_rhs;
    return retval;
}

static int
ops___FloatOp_set_rhs(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatOp' object attribute 'rhs' cannot be deleted");
        return -1;
    }
    if (self->_rhs != NULL) {
        CPy_DECREF(self->_rhs);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_rhs = tmp;
    return 0;
}

static PyObject *
ops___FloatOp_get_op(mypyc___ir___ops___FloatOpObject *self, void *closure)
{
    if (unlikely(self->_op == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'op' of 'FloatOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_op);
    PyObject *retval = CPyTagged_StealAsObject(self->_op);
    return retval;
}

static int
ops___FloatOp_set_op(mypyc___ir___ops___FloatOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatOp' object attribute 'op' cannot be deleted");
        return -1;
    }
    if (self->_op != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_op);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_op = tmp;
    return 0;
}

static int
ops___FloatNeg_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___FloatNeg_setup(PyTypeObject *type);
PyObject *CPyDef_ops___FloatNeg(PyObject *cpy_r_src, CPyTagged cpy_r_line);

static PyObject *
ops___FloatNeg_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___FloatNeg) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___FloatNeg_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___FloatNeg_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___FloatNeg_traverse(mypyc___ir___ops___FloatNegObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    return 0;
}

static int
ops___FloatNeg_clear(mypyc___ir___ops___FloatNegObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    return 0;
}

static void
ops___FloatNeg_dealloc(mypyc___ir___ops___FloatNegObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___FloatNeg_dealloc)
    ops___FloatNeg_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___FloatNeg_vtable[16];
static bool
CPyDef_ops___FloatNeg_trait_vtable_setup(void)
{
    CPyVTableItem ops___FloatNeg_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___FloatNeg_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___FloatNeg_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___FloatNeg___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___FloatNeg___accept,
        (CPyVTableItem)CPyDef_ops___FloatNeg_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___FloatNeg_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___FloatNeg_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___FloatNeg_____init__,
        (CPyVTableItem)CPyDef_ops___FloatNeg___sources,
        (CPyVTableItem)CPyDef_ops___FloatNeg___accept,
        (CPyVTableItem)CPyDef_ops___FloatNeg_____mypyc_defaults_setup,
    };
    memcpy(ops___FloatNeg_vtable, ops___FloatNeg_vtable_scratch, sizeof(ops___FloatNeg_vtable));
    return 1;
}

static PyObject *
ops___FloatNeg_get_error_kind(mypyc___ir___ops___FloatNegObject *self, void *closure);
static int
ops___FloatNeg_set_error_kind(mypyc___ir___ops___FloatNegObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatNeg_get_src(mypyc___ir___ops___FloatNegObject *self, void *closure);
static int
ops___FloatNeg_set_src(mypyc___ir___ops___FloatNegObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___FloatNeg_getseters[] = {
    {"error_kind",
     (getter)ops___FloatNeg_get_error_kind, (setter)ops___FloatNeg_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___FloatNeg_get_src, (setter)ops___FloatNeg_set_src,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___FloatNeg_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___FloatNeg_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___FloatNeg___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___FloatNeg___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___FloatNeg_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___FloatNeg_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "FloatNeg",
    .tp_new = ops___FloatNeg_new,
    .tp_dealloc = (destructor)ops___FloatNeg_dealloc,
    .tp_traverse = (traverseproc)ops___FloatNeg_traverse,
    .tp_clear = (inquiry)ops___FloatNeg_clear,
    .tp_getset = ops___FloatNeg_getseters,
    .tp_methods = ops___FloatNeg_methods,
    .tp_init = ops___FloatNeg_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___FloatNegObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___FloatNeg_template = &CPyType_ops___FloatNeg_template_;

static PyObject *
ops___FloatNeg_setup(PyTypeObject *type)
{
    mypyc___ir___ops___FloatNegObject *self;
    self = (mypyc___ir___ops___FloatNegObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___FloatNeg_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___FloatNeg_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___FloatNeg(PyObject *cpy_r_src, CPyTagged cpy_r_line)
{
    PyObject *self = ops___FloatNeg_setup(CPyType_ops___FloatNeg);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___FloatNeg_____init__(self, cpy_r_src, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___FloatNeg_get_error_kind(mypyc___ir___ops___FloatNegObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'FloatNeg' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___FloatNeg_set_error_kind(mypyc___ir___ops___FloatNegObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatNeg' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___FloatNeg_get_src(mypyc___ir___ops___FloatNegObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'FloatNeg' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___FloatNeg_set_src(mypyc___ir___ops___FloatNegObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatNeg' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static int
ops___FloatComparisonOp_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___FloatComparisonOp_setup(PyTypeObject *type);
PyObject *CPyDef_ops___FloatComparisonOp(PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line);

static PyObject *
ops___FloatComparisonOp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___FloatComparisonOp) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___FloatComparisonOp_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___FloatComparisonOp_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___FloatComparisonOp_traverse(mypyc___ir___ops___FloatComparisonOpObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    if (CPyTagged_CheckLong(self->_EQ)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_EQ));
    }
    if (CPyTagged_CheckLong(self->_NEQ)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_NEQ));
    }
    if (CPyTagged_CheckLong(self->_LT)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_LT));
    }
    if (CPyTagged_CheckLong(self->_GT)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_GT));
    }
    if (CPyTagged_CheckLong(self->_LE)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_LE));
    }
    if (CPyTagged_CheckLong(self->_GE)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_GE));
    }
    Py_VISIT(self->_op_str);
    Py_VISIT(self->_lhs);
    Py_VISIT(self->_rhs);
    if (CPyTagged_CheckLong(self->_op)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_op));
    }
    return 0;
}

static int
ops___FloatComparisonOp_clear(mypyc___ir___ops___FloatComparisonOpObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_EQ)) {
        CPyTagged __tmp = self->_EQ;
        self->_EQ = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_NEQ)) {
        CPyTagged __tmp = self->_NEQ;
        self->_NEQ = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_LT)) {
        CPyTagged __tmp = self->_LT;
        self->_LT = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_GT)) {
        CPyTagged __tmp = self->_GT;
        self->_GT = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_LE)) {
        CPyTagged __tmp = self->_LE;
        self->_LE = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    if (CPyTagged_CheckLong(self->_GE)) {
        CPyTagged __tmp = self->_GE;
        self->_GE = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_op_str);
    Py_CLEAR(self->_lhs);
    Py_CLEAR(self->_rhs);
    if (CPyTagged_CheckLong(self->_op)) {
        CPyTagged __tmp = self->_op;
        self->_op = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    return 0;
}

static void
ops___FloatComparisonOp_dealloc(mypyc___ir___ops___FloatComparisonOpObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___FloatComparisonOp_dealloc)
    ops___FloatComparisonOp_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___FloatComparisonOp_vtable[16];
static bool
CPyDef_ops___FloatComparisonOp_trait_vtable_setup(void)
{
    CPyVTableItem ops___FloatComparisonOp_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___FloatComparisonOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___FloatComparisonOp_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___FloatComparisonOp___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___FloatComparisonOp___accept,
        (CPyVTableItem)CPyDef_ops___FloatComparisonOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___FloatComparisonOp_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___FloatComparisonOp_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___FloatComparisonOp_____init__,
        (CPyVTableItem)CPyDef_ops___FloatComparisonOp___sources,
        (CPyVTableItem)CPyDef_ops___FloatComparisonOp___accept,
        (CPyVTableItem)CPyDef_ops___FloatComparisonOp_____mypyc_defaults_setup,
    };
    memcpy(ops___FloatComparisonOp_vtable, ops___FloatComparisonOp_vtable_scratch, sizeof(ops___FloatComparisonOp_vtable));
    return 1;
}

static PyObject *
ops___FloatComparisonOp_get_error_kind(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure);
static int
ops___FloatComparisonOp_set_error_kind(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatComparisonOp_get_EQ(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure);
static int
ops___FloatComparisonOp_set_EQ(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatComparisonOp_get_NEQ(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure);
static int
ops___FloatComparisonOp_set_NEQ(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatComparisonOp_get_LT(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure);
static int
ops___FloatComparisonOp_set_LT(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatComparisonOp_get_GT(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure);
static int
ops___FloatComparisonOp_set_GT(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatComparisonOp_get_LE(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure);
static int
ops___FloatComparisonOp_set_LE(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatComparisonOp_get_GE(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure);
static int
ops___FloatComparisonOp_set_GE(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatComparisonOp_get_op_str(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure);
static int
ops___FloatComparisonOp_set_op_str(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatComparisonOp_get_lhs(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure);
static int
ops___FloatComparisonOp_set_lhs(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatComparisonOp_get_rhs(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure);
static int
ops___FloatComparisonOp_set_rhs(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure);
static PyObject *
ops___FloatComparisonOp_get_op(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure);
static int
ops___FloatComparisonOp_set_op(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___FloatComparisonOp_getseters[] = {
    {"error_kind",
     (getter)ops___FloatComparisonOp_get_error_kind, (setter)ops___FloatComparisonOp_set_error_kind,
     NULL, NULL},
    {"EQ",
     (getter)ops___FloatComparisonOp_get_EQ, (setter)ops___FloatComparisonOp_set_EQ,
     NULL, NULL},
    {"NEQ",
     (getter)ops___FloatComparisonOp_get_NEQ, (setter)ops___FloatComparisonOp_set_NEQ,
     NULL, NULL},
    {"LT",
     (getter)ops___FloatComparisonOp_get_LT, (setter)ops___FloatComparisonOp_set_LT,
     NULL, NULL},
    {"GT",
     (getter)ops___FloatComparisonOp_get_GT, (setter)ops___FloatComparisonOp_set_GT,
     NULL, NULL},
    {"LE",
     (getter)ops___FloatComparisonOp_get_LE, (setter)ops___FloatComparisonOp_set_LE,
     NULL, NULL},
    {"GE",
     (getter)ops___FloatComparisonOp_get_GE, (setter)ops___FloatComparisonOp_set_GE,
     NULL, NULL},
    {"op_str",
     (getter)ops___FloatComparisonOp_get_op_str, (setter)ops___FloatComparisonOp_set_op_str,
     NULL, NULL},
    {"lhs",
     (getter)ops___FloatComparisonOp_get_lhs, (setter)ops___FloatComparisonOp_set_lhs,
     NULL, NULL},
    {"rhs",
     (getter)ops___FloatComparisonOp_get_rhs, (setter)ops___FloatComparisonOp_set_rhs,
     NULL, NULL},
    {"op",
     (getter)ops___FloatComparisonOp_get_op, (setter)ops___FloatComparisonOp_set_op,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___FloatComparisonOp_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___FloatComparisonOp_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___FloatComparisonOp___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___FloatComparisonOp___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___FloatComparisonOp_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___FloatComparisonOp_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "FloatComparisonOp",
    .tp_new = ops___FloatComparisonOp_new,
    .tp_dealloc = (destructor)ops___FloatComparisonOp_dealloc,
    .tp_traverse = (traverseproc)ops___FloatComparisonOp_traverse,
    .tp_clear = (inquiry)ops___FloatComparisonOp_clear,
    .tp_getset = ops___FloatComparisonOp_getseters,
    .tp_methods = ops___FloatComparisonOp_methods,
    .tp_init = ops___FloatComparisonOp_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___FloatComparisonOpObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___FloatComparisonOp_template = &CPyType_ops___FloatComparisonOp_template_;

static PyObject *
ops___FloatComparisonOp_setup(PyTypeObject *type)
{
    mypyc___ir___ops___FloatComparisonOpObject *self;
    self = (mypyc___ir___ops___FloatComparisonOpObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___FloatComparisonOp_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_EQ = CPY_INT_TAG;
    self->_NEQ = CPY_INT_TAG;
    self->_LT = CPY_INT_TAG;
    self->_GT = CPY_INT_TAG;
    self->_LE = CPY_INT_TAG;
    self->_GE = CPY_INT_TAG;
    self->_op = CPY_INT_TAG;
    if (CPyDef_ops___FloatComparisonOp_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___FloatComparisonOp(PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line)
{
    PyObject *self = ops___FloatComparisonOp_setup(CPyType_ops___FloatComparisonOp);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___FloatComparisonOp_____init__(self, cpy_r_lhs, cpy_r_rhs, cpy_r_op, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___FloatComparisonOp_get_error_kind(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'FloatComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___FloatComparisonOp_set_error_kind(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatComparisonOp' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___FloatComparisonOp_get_EQ(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_EQ == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'EQ' of 'FloatComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_EQ);
    PyObject *retval = CPyTagged_StealAsObject(self->_EQ);
    return retval;
}

static int
ops___FloatComparisonOp_set_EQ(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatComparisonOp' object attribute 'EQ' cannot be deleted");
        return -1;
    }
    if (self->_EQ != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_EQ);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_EQ = tmp;
    return 0;
}

static PyObject *
ops___FloatComparisonOp_get_NEQ(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_NEQ == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'NEQ' of 'FloatComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_NEQ);
    PyObject *retval = CPyTagged_StealAsObject(self->_NEQ);
    return retval;
}

static int
ops___FloatComparisonOp_set_NEQ(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatComparisonOp' object attribute 'NEQ' cannot be deleted");
        return -1;
    }
    if (self->_NEQ != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_NEQ);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_NEQ = tmp;
    return 0;
}

static PyObject *
ops___FloatComparisonOp_get_LT(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_LT == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'LT' of 'FloatComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_LT);
    PyObject *retval = CPyTagged_StealAsObject(self->_LT);
    return retval;
}

static int
ops___FloatComparisonOp_set_LT(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatComparisonOp' object attribute 'LT' cannot be deleted");
        return -1;
    }
    if (self->_LT != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_LT);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_LT = tmp;
    return 0;
}

static PyObject *
ops___FloatComparisonOp_get_GT(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_GT == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'GT' of 'FloatComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_GT);
    PyObject *retval = CPyTagged_StealAsObject(self->_GT);
    return retval;
}

static int
ops___FloatComparisonOp_set_GT(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatComparisonOp' object attribute 'GT' cannot be deleted");
        return -1;
    }
    if (self->_GT != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_GT);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_GT = tmp;
    return 0;
}

static PyObject *
ops___FloatComparisonOp_get_LE(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_LE == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'LE' of 'FloatComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_LE);
    PyObject *retval = CPyTagged_StealAsObject(self->_LE);
    return retval;
}

static int
ops___FloatComparisonOp_set_LE(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatComparisonOp' object attribute 'LE' cannot be deleted");
        return -1;
    }
    if (self->_LE != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_LE);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_LE = tmp;
    return 0;
}

static PyObject *
ops___FloatComparisonOp_get_GE(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_GE == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'GE' of 'FloatComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_GE);
    PyObject *retval = CPyTagged_StealAsObject(self->_GE);
    return retval;
}

static int
ops___FloatComparisonOp_set_GE(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatComparisonOp' object attribute 'GE' cannot be deleted");
        return -1;
    }
    if (self->_GE != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_GE);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_GE = tmp;
    return 0;
}

static PyObject *
ops___FloatComparisonOp_get_op_str(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_op_str == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'op_str' of 'FloatComparisonOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_op_str);
    PyObject *retval = self->_op_str;
    return retval;
}

static int
ops___FloatComparisonOp_set_op_str(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatComparisonOp' object attribute 'op_str' cannot be deleted");
        return -1;
    }
    if (self->_op_str != NULL) {
        CPy_DECREF(self->_op_str);
    }
    PyObject *tmp;
    if (likely(PyDict_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("dict", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_op_str = tmp;
    return 0;
}

static PyObject *
ops___FloatComparisonOp_get_lhs(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_lhs == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'lhs' of 'FloatComparisonOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_lhs);
    PyObject *retval = self->_lhs;
    return retval;
}

static int
ops___FloatComparisonOp_set_lhs(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatComparisonOp' object attribute 'lhs' cannot be deleted");
        return -1;
    }
    if (self->_lhs != NULL) {
        CPy_DECREF(self->_lhs);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_lhs = tmp;
    return 0;
}

static PyObject *
ops___FloatComparisonOp_get_rhs(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_rhs == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'rhs' of 'FloatComparisonOp' undefined");
        return NULL;
    }
    CPy_INCREF(self->_rhs);
    PyObject *retval = self->_rhs;
    return retval;
}

static int
ops___FloatComparisonOp_set_rhs(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatComparisonOp' object attribute 'rhs' cannot be deleted");
        return -1;
    }
    if (self->_rhs != NULL) {
        CPy_DECREF(self->_rhs);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_rhs = tmp;
    return 0;
}

static PyObject *
ops___FloatComparisonOp_get_op(mypyc___ir___ops___FloatComparisonOpObject *self, void *closure)
{
    if (unlikely(self->_op == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'op' of 'FloatComparisonOp' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_op);
    PyObject *retval = CPyTagged_StealAsObject(self->_op);
    return retval;
}

static int
ops___FloatComparisonOp_set_op(mypyc___ir___ops___FloatComparisonOpObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'FloatComparisonOp' object attribute 'op' cannot be deleted");
        return -1;
    }
    if (self->_op != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_op);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_op = tmp;
    return 0;
}

static int
ops___LoadMem_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___LoadMem_setup(PyTypeObject *type);
PyObject *CPyDef_ops___LoadMem(PyObject *cpy_r_type, PyObject *cpy_r_src, CPyTagged cpy_r_line);

static PyObject *
ops___LoadMem_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___LoadMem) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___LoadMem_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___LoadMem_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___LoadMem_traverse(mypyc___ir___ops___LoadMemObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    return 0;
}

static int
ops___LoadMem_clear(mypyc___ir___ops___LoadMemObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    return 0;
}

static void
ops___LoadMem_dealloc(mypyc___ir___ops___LoadMemObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___LoadMem_dealloc)
    ops___LoadMem_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___LoadMem_vtable[16];
static bool
CPyDef_ops___LoadMem_trait_vtable_setup(void)
{
    CPyVTableItem ops___LoadMem_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___LoadMem_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadMem_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadMem___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___LoadMem___accept,
        (CPyVTableItem)CPyDef_ops___LoadMem_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadMem_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadMem_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadMem_____init__,
        (CPyVTableItem)CPyDef_ops___LoadMem___sources,
        (CPyVTableItem)CPyDef_ops___LoadMem___accept,
        (CPyVTableItem)CPyDef_ops___LoadMem_____mypyc_defaults_setup,
    };
    memcpy(ops___LoadMem_vtable, ops___LoadMem_vtable_scratch, sizeof(ops___LoadMem_vtable));
    return 1;
}

static PyObject *
ops___LoadMem_get_error_kind(mypyc___ir___ops___LoadMemObject *self, void *closure);
static int
ops___LoadMem_set_error_kind(mypyc___ir___ops___LoadMemObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadMem_get_src(mypyc___ir___ops___LoadMemObject *self, void *closure);
static int
ops___LoadMem_set_src(mypyc___ir___ops___LoadMemObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___LoadMem_getseters[] = {
    {"error_kind",
     (getter)ops___LoadMem_get_error_kind, (setter)ops___LoadMem_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___LoadMem_get_src, (setter)ops___LoadMem_set_src,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___LoadMem_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___LoadMem_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___LoadMem___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___LoadMem___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___LoadMem_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___LoadMem_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "LoadMem",
    .tp_new = ops___LoadMem_new,
    .tp_dealloc = (destructor)ops___LoadMem_dealloc,
    .tp_traverse = (traverseproc)ops___LoadMem_traverse,
    .tp_clear = (inquiry)ops___LoadMem_clear,
    .tp_getset = ops___LoadMem_getseters,
    .tp_methods = ops___LoadMem_methods,
    .tp_init = ops___LoadMem_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___LoadMemObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___LoadMem_template = &CPyType_ops___LoadMem_template_;

static PyObject *
ops___LoadMem_setup(PyTypeObject *type)
{
    mypyc___ir___ops___LoadMemObject *self;
    self = (mypyc___ir___ops___LoadMemObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___LoadMem_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___LoadMem_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___LoadMem(PyObject *cpy_r_type, PyObject *cpy_r_src, CPyTagged cpy_r_line)
{
    PyObject *self = ops___LoadMem_setup(CPyType_ops___LoadMem);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___LoadMem_____init__(self, cpy_r_type, cpy_r_src, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___LoadMem_get_error_kind(mypyc___ir___ops___LoadMemObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'LoadMem' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___LoadMem_set_error_kind(mypyc___ir___ops___LoadMemObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadMem' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___LoadMem_get_src(mypyc___ir___ops___LoadMemObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'LoadMem' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___LoadMem_set_src(mypyc___ir___ops___LoadMemObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadMem' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static int
ops___SetMem_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___SetMem_setup(PyTypeObject *type);
PyObject *CPyDef_ops___SetMem(PyObject *cpy_r_type, PyObject *cpy_r_dest, PyObject *cpy_r_src, CPyTagged cpy_r_line);

static PyObject *
ops___SetMem_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___SetMem) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___SetMem_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___SetMem_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___SetMem_traverse(mypyc___ir___ops___SetMemObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_dest_type);
    Py_VISIT(self->_src);
    Py_VISIT(self->_dest);
    return 0;
}

static int
ops___SetMem_clear(mypyc___ir___ops___SetMemObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_dest_type);
    Py_CLEAR(self->_src);
    Py_CLEAR(self->_dest);
    return 0;
}

static void
ops___SetMem_dealloc(mypyc___ir___ops___SetMemObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___SetMem_dealloc)
    ops___SetMem_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___SetMem_vtable[14];
static bool
CPyDef_ops___SetMem_trait_vtable_setup(void)
{
    CPyVTableItem ops___SetMem_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___SetMem_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___SetMem_____init__,
        (CPyVTableItem)CPyDef_ops___Op___can_raise,
        (CPyVTableItem)CPyDef_ops___SetMem___sources,
        (CPyVTableItem)CPyDef_ops___SetMem___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___SetMem___accept,
        (CPyVTableItem)CPyDef_ops___SetMem_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___SetMem_____init__,
        (CPyVTableItem)CPyDef_ops___SetMem___sources,
        (CPyVTableItem)CPyDef_ops___SetMem___stolen,
        (CPyVTableItem)CPyDef_ops___SetMem___accept,
        (CPyVTableItem)CPyDef_ops___SetMem_____mypyc_defaults_setup,
    };
    memcpy(ops___SetMem_vtable, ops___SetMem_vtable_scratch, sizeof(ops___SetMem_vtable));
    return 1;
}

static PyObject *
ops___SetMem_get_error_kind(mypyc___ir___ops___SetMemObject *self, void *closure);
static int
ops___SetMem_set_error_kind(mypyc___ir___ops___SetMemObject *self, PyObject *value, void *closure);
static PyObject *
ops___SetMem_get_dest_type(mypyc___ir___ops___SetMemObject *self, void *closure);
static int
ops___SetMem_set_dest_type(mypyc___ir___ops___SetMemObject *self, PyObject *value, void *closure);
static PyObject *
ops___SetMem_get_src(mypyc___ir___ops___SetMemObject *self, void *closure);
static int
ops___SetMem_set_src(mypyc___ir___ops___SetMemObject *self, PyObject *value, void *closure);
static PyObject *
ops___SetMem_get_dest(mypyc___ir___ops___SetMemObject *self, void *closure);
static int
ops___SetMem_set_dest(mypyc___ir___ops___SetMemObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___SetMem_getseters[] = {
    {"error_kind",
     (getter)ops___SetMem_get_error_kind, (setter)ops___SetMem_set_error_kind,
     NULL, NULL},
    {"dest_type",
     (getter)ops___SetMem_get_dest_type, (setter)ops___SetMem_set_dest_type,
     NULL, NULL},
    {"src",
     (getter)ops___SetMem_get_src, (setter)ops___SetMem_set_src,
     NULL, NULL},
    {"dest",
     (getter)ops___SetMem_get_dest, (setter)ops___SetMem_set_dest,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___SetMem_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___SetMem_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___SetMem___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"stolen",
     (PyCFunction)CPyPy_ops___SetMem___stolen,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___SetMem___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___SetMem_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___SetMem_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "SetMem",
    .tp_new = ops___SetMem_new,
    .tp_dealloc = (destructor)ops___SetMem_dealloc,
    .tp_traverse = (traverseproc)ops___SetMem_traverse,
    .tp_clear = (inquiry)ops___SetMem_clear,
    .tp_getset = ops___SetMem_getseters,
    .tp_methods = ops___SetMem_methods,
    .tp_init = ops___SetMem_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___SetMemObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___SetMem_template = &CPyType_ops___SetMem_template_;

static PyObject *
ops___SetMem_setup(PyTypeObject *type)
{
    mypyc___ir___ops___SetMemObject *self;
    self = (mypyc___ir___ops___SetMemObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___SetMem_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___SetMem_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___SetMem(PyObject *cpy_r_type, PyObject *cpy_r_dest, PyObject *cpy_r_src, CPyTagged cpy_r_line)
{
    PyObject *self = ops___SetMem_setup(CPyType_ops___SetMem);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___SetMem_____init__(self, cpy_r_type, cpy_r_dest, cpy_r_src, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___SetMem_get_error_kind(mypyc___ir___ops___SetMemObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'SetMem' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___SetMem_set_error_kind(mypyc___ir___ops___SetMemObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'SetMem' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___SetMem_get_dest_type(mypyc___ir___ops___SetMemObject *self, void *closure)
{
    if (unlikely(self->_dest_type == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'dest_type' of 'SetMem' undefined");
        return NULL;
    }
    CPy_INCREF(self->_dest_type);
    PyObject *retval = self->_dest_type;
    return retval;
}

static int
ops___SetMem_set_dest_type(mypyc___ir___ops___SetMemObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'SetMem' object attribute 'dest_type' cannot be deleted");
        return -1;
    }
    if (self->_dest_type != NULL) {
        CPy_DECREF(self->_dest_type);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_rtypes___RType)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_dest_type = tmp;
    return 0;
}

static PyObject *
ops___SetMem_get_src(mypyc___ir___ops___SetMemObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'SetMem' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___SetMem_set_src(mypyc___ir___ops___SetMemObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'SetMem' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static PyObject *
ops___SetMem_get_dest(mypyc___ir___ops___SetMemObject *self, void *closure)
{
    if (unlikely(self->_dest == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'dest' of 'SetMem' undefined");
        return NULL;
    }
    CPy_INCREF(self->_dest);
    PyObject *retval = self->_dest;
    return retval;
}

static int
ops___SetMem_set_dest(mypyc___ir___ops___SetMemObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'SetMem' object attribute 'dest' cannot be deleted");
        return -1;
    }
    if (self->_dest != NULL) {
        CPy_DECREF(self->_dest);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_dest = tmp;
    return 0;
}

static int
ops___GetElementPtr_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___GetElementPtr_setup(PyTypeObject *type);
PyObject *CPyDef_ops___GetElementPtr(PyObject *cpy_r_src, PyObject *cpy_r_src_type, PyObject *cpy_r_field, CPyTagged cpy_r_line);

static PyObject *
ops___GetElementPtr_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___GetElementPtr) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___GetElementPtr_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___GetElementPtr_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___GetElementPtr_traverse(mypyc___ir___ops___GetElementPtrObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    Py_VISIT(self->_src_type);
    Py_VISIT(self->_field);
    return 0;
}

static int
ops___GetElementPtr_clear(mypyc___ir___ops___GetElementPtrObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    Py_CLEAR(self->_src_type);
    Py_CLEAR(self->_field);
    return 0;
}

static void
ops___GetElementPtr_dealloc(mypyc___ir___ops___GetElementPtrObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___GetElementPtr_dealloc)
    ops___GetElementPtr_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___GetElementPtr_vtable[16];
static bool
CPyDef_ops___GetElementPtr_trait_vtable_setup(void)
{
    CPyVTableItem ops___GetElementPtr_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___GetElementPtr_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___GetElementPtr_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___GetElementPtr___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___GetElementPtr___accept,
        (CPyVTableItem)CPyDef_ops___GetElementPtr_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___GetElementPtr_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___GetElementPtr_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___GetElementPtr_____init__,
        (CPyVTableItem)CPyDef_ops___GetElementPtr___sources,
        (CPyVTableItem)CPyDef_ops___GetElementPtr___accept,
        (CPyVTableItem)CPyDef_ops___GetElementPtr_____mypyc_defaults_setup,
    };
    memcpy(ops___GetElementPtr_vtable, ops___GetElementPtr_vtable_scratch, sizeof(ops___GetElementPtr_vtable));
    return 1;
}

static PyObject *
ops___GetElementPtr_get_error_kind(mypyc___ir___ops___GetElementPtrObject *self, void *closure);
static int
ops___GetElementPtr_set_error_kind(mypyc___ir___ops___GetElementPtrObject *self, PyObject *value, void *closure);
static PyObject *
ops___GetElementPtr_get_src(mypyc___ir___ops___GetElementPtrObject *self, void *closure);
static int
ops___GetElementPtr_set_src(mypyc___ir___ops___GetElementPtrObject *self, PyObject *value, void *closure);
static PyObject *
ops___GetElementPtr_get_src_type(mypyc___ir___ops___GetElementPtrObject *self, void *closure);
static int
ops___GetElementPtr_set_src_type(mypyc___ir___ops___GetElementPtrObject *self, PyObject *value, void *closure);
static PyObject *
ops___GetElementPtr_get_field(mypyc___ir___ops___GetElementPtrObject *self, void *closure);
static int
ops___GetElementPtr_set_field(mypyc___ir___ops___GetElementPtrObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___GetElementPtr_getseters[] = {
    {"error_kind",
     (getter)ops___GetElementPtr_get_error_kind, (setter)ops___GetElementPtr_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___GetElementPtr_get_src, (setter)ops___GetElementPtr_set_src,
     NULL, NULL},
    {"src_type",
     (getter)ops___GetElementPtr_get_src_type, (setter)ops___GetElementPtr_set_src_type,
     NULL, NULL},
    {"field",
     (getter)ops___GetElementPtr_get_field, (setter)ops___GetElementPtr_set_field,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___GetElementPtr_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___GetElementPtr_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___GetElementPtr___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___GetElementPtr___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___GetElementPtr_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___GetElementPtr_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "GetElementPtr",
    .tp_new = ops___GetElementPtr_new,
    .tp_dealloc = (destructor)ops___GetElementPtr_dealloc,
    .tp_traverse = (traverseproc)ops___GetElementPtr_traverse,
    .tp_clear = (inquiry)ops___GetElementPtr_clear,
    .tp_getset = ops___GetElementPtr_getseters,
    .tp_methods = ops___GetElementPtr_methods,
    .tp_init = ops___GetElementPtr_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___GetElementPtrObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___GetElementPtr_template = &CPyType_ops___GetElementPtr_template_;

static PyObject *
ops___GetElementPtr_setup(PyTypeObject *type)
{
    mypyc___ir___ops___GetElementPtrObject *self;
    self = (mypyc___ir___ops___GetElementPtrObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___GetElementPtr_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___GetElementPtr_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___GetElementPtr(PyObject *cpy_r_src, PyObject *cpy_r_src_type, PyObject *cpy_r_field, CPyTagged cpy_r_line)
{
    PyObject *self = ops___GetElementPtr_setup(CPyType_ops___GetElementPtr);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___GetElementPtr_____init__(self, cpy_r_src, cpy_r_src_type, cpy_r_field, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___GetElementPtr_get_error_kind(mypyc___ir___ops___GetElementPtrObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'GetElementPtr' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___GetElementPtr_set_error_kind(mypyc___ir___ops___GetElementPtrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'GetElementPtr' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___GetElementPtr_get_src(mypyc___ir___ops___GetElementPtrObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'GetElementPtr' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___GetElementPtr_set_src(mypyc___ir___ops___GetElementPtrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'GetElementPtr' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_ops___Value)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static PyObject *
ops___GetElementPtr_get_src_type(mypyc___ir___ops___GetElementPtrObject *self, void *closure)
{
    if (unlikely(self->_src_type == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src_type' of 'GetElementPtr' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src_type);
    PyObject *retval = self->_src_type;
    return retval;
}

static int
ops___GetElementPtr_set_src_type(mypyc___ir___ops___GetElementPtrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'GetElementPtr' object attribute 'src_type' cannot be deleted");
        return -1;
    }
    if (self->_src_type != NULL) {
        CPy_DECREF(self->_src_type);
    }
    PyObject *tmp;
    if (likely(PyObject_TypeCheck(value, CPyType_rtypes___RType)))
        tmp = value;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src_type = tmp;
    return 0;
}

static PyObject *
ops___GetElementPtr_get_field(mypyc___ir___ops___GetElementPtrObject *self, void *closure)
{
    if (unlikely(self->_field == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'field' of 'GetElementPtr' undefined");
        return NULL;
    }
    CPy_INCREF(self->_field);
    PyObject *retval = self->_field;
    return retval;
}

static int
ops___GetElementPtr_set_field(mypyc___ir___ops___GetElementPtrObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'GetElementPtr' object attribute 'field' cannot be deleted");
        return -1;
    }
    if (self->_field != NULL) {
        CPy_DECREF(self->_field);
    }
    PyObject *tmp;
    if (likely(PyUnicode_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("str", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_field = tmp;
    return 0;
}

static int
ops___LoadAddress_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___LoadAddress_setup(PyTypeObject *type);
PyObject *CPyDef_ops___LoadAddress(PyObject *cpy_r_type, PyObject *cpy_r_src, CPyTagged cpy_r_line);

static PyObject *
ops___LoadAddress_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___LoadAddress) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___LoadAddress_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___LoadAddress_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___LoadAddress_traverse(mypyc___ir___ops___LoadAddressObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    return 0;
}

static int
ops___LoadAddress_clear(mypyc___ir___ops___LoadAddressObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    return 0;
}

static void
ops___LoadAddress_dealloc(mypyc___ir___ops___LoadAddressObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___LoadAddress_dealloc)
    ops___LoadAddress_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___LoadAddress_vtable[16];
static bool
CPyDef_ops___LoadAddress_trait_vtable_setup(void)
{
    CPyVTableItem ops___LoadAddress_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___LoadAddress_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadAddress_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadAddress___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___LoadAddress___accept,
        (CPyVTableItem)CPyDef_ops___LoadAddress_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadAddress_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___LoadAddress_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___LoadAddress_____init__,
        (CPyVTableItem)CPyDef_ops___LoadAddress___sources,
        (CPyVTableItem)CPyDef_ops___LoadAddress___accept,
        (CPyVTableItem)CPyDef_ops___LoadAddress_____mypyc_defaults_setup,
    };
    memcpy(ops___LoadAddress_vtable, ops___LoadAddress_vtable_scratch, sizeof(ops___LoadAddress_vtable));
    return 1;
}

static PyObject *
ops___LoadAddress_get_error_kind(mypyc___ir___ops___LoadAddressObject *self, void *closure);
static int
ops___LoadAddress_set_error_kind(mypyc___ir___ops___LoadAddressObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadAddress_get_is_borrowed(mypyc___ir___ops___LoadAddressObject *self, void *closure);
static int
ops___LoadAddress_set_is_borrowed(mypyc___ir___ops___LoadAddressObject *self, PyObject *value, void *closure);
static PyObject *
ops___LoadAddress_get_src(mypyc___ir___ops___LoadAddressObject *self, void *closure);
static int
ops___LoadAddress_set_src(mypyc___ir___ops___LoadAddressObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___LoadAddress_getseters[] = {
    {"error_kind",
     (getter)ops___LoadAddress_get_error_kind, (setter)ops___LoadAddress_set_error_kind,
     NULL, NULL},
    {"is_borrowed",
     (getter)ops___LoadAddress_get_is_borrowed, (setter)ops___LoadAddress_set_is_borrowed,
     NULL, NULL},
    {"src",
     (getter)ops___LoadAddress_get_src, (setter)ops___LoadAddress_set_src,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___LoadAddress_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___LoadAddress_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___LoadAddress___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___LoadAddress___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___LoadAddress_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___LoadAddress_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "LoadAddress",
    .tp_new = ops___LoadAddress_new,
    .tp_dealloc = (destructor)ops___LoadAddress_dealloc,
    .tp_traverse = (traverseproc)ops___LoadAddress_traverse,
    .tp_clear = (inquiry)ops___LoadAddress_clear,
    .tp_getset = ops___LoadAddress_getseters,
    .tp_methods = ops___LoadAddress_methods,
    .tp_init = ops___LoadAddress_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___LoadAddressObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___LoadAddress_template = &CPyType_ops___LoadAddress_template_;

static PyObject *
ops___LoadAddress_setup(PyTypeObject *type)
{
    mypyc___ir___ops___LoadAddressObject *self;
    self = (mypyc___ir___ops___LoadAddressObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___LoadAddress_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    self->_is_borrowed = 2;
    if (CPyDef_ops___LoadAddress_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___LoadAddress(PyObject *cpy_r_type, PyObject *cpy_r_src, CPyTagged cpy_r_line)
{
    PyObject *self = ops___LoadAddress_setup(CPyType_ops___LoadAddress);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___LoadAddress_____init__(self, cpy_r_type, cpy_r_src, cpy_r_line);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___LoadAddress_get_error_kind(mypyc___ir___ops___LoadAddressObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'LoadAddress' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___LoadAddress_set_error_kind(mypyc___ir___ops___LoadAddressObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadAddress' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___LoadAddress_get_is_borrowed(mypyc___ir___ops___LoadAddressObject *self, void *closure)
{
    PyObject *retval = self->_is_borrowed ? Py_True : Py_False;
    CPy_INCREF(retval);
    return retval;
}

static int
ops___LoadAddress_set_is_borrowed(mypyc___ir___ops___LoadAddressObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadAddress' object attribute 'is_borrowed' cannot be deleted");
        return -1;
    }
    char tmp;
    if (unlikely(!PyBool_Check(value))) {
        CPy_TypeError("bool", value); return -1;
    } else
        tmp = value == Py_True;
    self->_is_borrowed = tmp;
    return 0;
}

static PyObject *
ops___LoadAddress_get_src(mypyc___ir___ops___LoadAddressObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'LoadAddress' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___LoadAddress_set_src(mypyc___ir___ops___LoadAddressObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'LoadAddress' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (PyUnicode_Check(value))
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9864;
    if (Py_TYPE(value) == CPyType_ops___Register)
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9864;
    if (Py_TYPE(value) == CPyType_ops___LoadStatic)
        tmp = value;
    else {
        tmp = NULL;
    }
    if (tmp != NULL) goto __LL9864;
    CPy_TypeError("union[str, mypyc.ir.ops.Register, mypyc.ir.ops.LoadStatic]", value); 
    tmp = NULL;
__LL9864: ;
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

static int
ops___KeepAlive_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    return 0;
}
static PyObject *ops___KeepAlive_setup(PyTypeObject *type);
PyObject *CPyDef_ops___KeepAlive(PyObject *cpy_r_src);

static PyObject *
ops___KeepAlive_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___KeepAlive) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");
        return NULL;
    }
    PyObject *self = ops___KeepAlive_setup(type);
    if (self == NULL)
        return NULL;
    PyObject *ret = CPyPy_ops___KeepAlive_____init__(self, args, kwds);
    if (ret == NULL)
        return NULL;
    return self;
}

static int
ops___KeepAlive_traverse(mypyc___ir___ops___KeepAliveObject *self, visitproc visit, void *arg)
{
    if (CPyTagged_CheckLong(self->_line)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_line));
    }
    Py_VISIT(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        Py_VISIT(CPyTagged_LongAsObject(self->_error_kind));
    }
    Py_VISIT(self->_src);
    return 0;
}

static int
ops___KeepAlive_clear(mypyc___ir___ops___KeepAliveObject *self)
{
    if (CPyTagged_CheckLong(self->_line)) {
        CPyTagged __tmp = self->_line;
        self->_line = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->__type);
    if (CPyTagged_CheckLong(self->_error_kind)) {
        CPyTagged __tmp = self->_error_kind;
        self->_error_kind = CPY_INT_TAG;
        Py_XDECREF(CPyTagged_LongAsObject(__tmp));
    }
    Py_CLEAR(self->_src);
    return 0;
}

static void
ops___KeepAlive_dealloc(mypyc___ir___ops___KeepAliveObject *self)
{
    PyObject_GC_UnTrack(self);
    CPy_TRASHCAN_BEGIN(self, ops___KeepAlive_dealloc)
    ops___KeepAlive_clear(self);
    Py_TYPE(self)->tp_free((PyObject *)self);
    CPy_TRASHCAN_END(self)
}

static CPyVTableItem ops___KeepAlive_vtable[16];
static bool
CPyDef_ops___KeepAlive_trait_vtable_setup(void)
{
    CPyVTableItem ops___KeepAlive_vtable_scratch[] = {
        (CPyVTableItem)CPyDef_ops___Value___is_void,
        (CPyVTableItem)CPyDef_ops___KeepAlive_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___KeepAlive_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___KeepAlive___sources,
        (CPyVTableItem)CPyDef_ops___Op___stolen,
        (CPyVTableItem)CPyDef_ops___Op___unique_sources,
        (CPyVTableItem)CPyDef_ops___KeepAlive___accept,
        (CPyVTableItem)CPyDef_ops___KeepAlive_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___KeepAlive_____init__,
        (CPyVTableItem)CPyDef_ops___RegisterOp___can_raise,
        (CPyVTableItem)CPyDef_ops___KeepAlive_____mypyc_defaults_setup,
        (CPyVTableItem)CPyDef_ops___KeepAlive_____init__,
        (CPyVTableItem)CPyDef_ops___KeepAlive___sources,
        (CPyVTableItem)CPyDef_ops___KeepAlive___accept,
        (CPyVTableItem)CPyDef_ops___KeepAlive_____mypyc_defaults_setup,
    };
    memcpy(ops___KeepAlive_vtable, ops___KeepAlive_vtable_scratch, sizeof(ops___KeepAlive_vtable));
    return 1;
}

static PyObject *
ops___KeepAlive_get_error_kind(mypyc___ir___ops___KeepAliveObject *self, void *closure);
static int
ops___KeepAlive_set_error_kind(mypyc___ir___ops___KeepAliveObject *self, PyObject *value, void *closure);
static PyObject *
ops___KeepAlive_get_src(mypyc___ir___ops___KeepAliveObject *self, void *closure);
static int
ops___KeepAlive_set_src(mypyc___ir___ops___KeepAliveObject *self, PyObject *value, void *closure);

static PyGetSetDef ops___KeepAlive_getseters[] = {
    {"error_kind",
     (getter)ops___KeepAlive_get_error_kind, (setter)ops___KeepAlive_set_error_kind,
     NULL, NULL},
    {"src",
     (getter)ops___KeepAlive_get_src, (setter)ops___KeepAlive_set_src,
     NULL, NULL},
    {NULL}  /* Sentinel */
};

static PyMethodDef ops___KeepAlive_methods[] = {
    {"__init__",
     (PyCFunction)CPyPy_ops___KeepAlive_____init__,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"sources",
     (PyCFunction)CPyPy_ops___KeepAlive___sources,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"accept",
     (PyCFunction)CPyPy_ops___KeepAlive___accept,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__mypyc_defaults_setup",
     (PyCFunction)CPyPy_ops___KeepAlive_____mypyc_defaults_setup,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___KeepAlive_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "KeepAlive",
    .tp_new = ops___KeepAlive_new,
    .tp_dealloc = (destructor)ops___KeepAlive_dealloc,
    .tp_traverse = (traverseproc)ops___KeepAlive_traverse,
    .tp_clear = (inquiry)ops___KeepAlive_clear,
    .tp_getset = ops___KeepAlive_getseters,
    .tp_methods = ops___KeepAlive_methods,
    .tp_init = ops___KeepAlive_init,
    .tp_basicsize = sizeof(mypyc___ir___ops___KeepAliveObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
};
static PyTypeObject *CPyType_ops___KeepAlive_template = &CPyType_ops___KeepAlive_template_;

static PyObject *
ops___KeepAlive_setup(PyTypeObject *type)
{
    mypyc___ir___ops___KeepAliveObject *self;
    self = (mypyc___ir___ops___KeepAliveObject *)type->tp_alloc(type, 0);
    if (self == NULL)
        return NULL;
    self->vtable = ops___KeepAlive_vtable;
    self->_line = CPY_INT_TAG;
    self->_is_borrowed = 2;
    self->_error_kind = CPY_INT_TAG;
    self->_error_kind = CPY_INT_TAG;
    if (CPyDef_ops___KeepAlive_____mypyc_defaults_setup((PyObject *)self) == 0) {
        Py_DECREF(self);
        return NULL;
    }
    return (PyObject *)self;
}

PyObject *CPyDef_ops___KeepAlive(PyObject *cpy_r_src)
{
    PyObject *self = ops___KeepAlive_setup(CPyType_ops___KeepAlive);
    if (self == NULL)
        return NULL;
    char res = CPyDef_ops___KeepAlive_____init__(self, cpy_r_src);
    if (res == 2) {
        Py_DECREF(self);
        return NULL;
    }
    return self;
}

static PyObject *
ops___KeepAlive_get_error_kind(mypyc___ir___ops___KeepAliveObject *self, void *closure)
{
    if (unlikely(self->_error_kind == CPY_INT_TAG)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'error_kind' of 'KeepAlive' undefined");
        return NULL;
    }
    CPyTagged_INCREF(self->_error_kind);
    PyObject *retval = CPyTagged_StealAsObject(self->_error_kind);
    return retval;
}

static int
ops___KeepAlive_set_error_kind(mypyc___ir___ops___KeepAliveObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'KeepAlive' object attribute 'error_kind' cannot be deleted");
        return -1;
    }
    if (self->_error_kind != CPY_INT_TAG) {
        CPyTagged_DECREF(self->_error_kind);
    }
    CPyTagged tmp;
    if (likely(PyLong_Check(value)))
        tmp = CPyTagged_FromObject(value);
    else {
        CPy_TypeError("int", value); return -1;
    }
    CPyTagged_INCREF(tmp);
    self->_error_kind = tmp;
    return 0;
}

static PyObject *
ops___KeepAlive_get_src(mypyc___ir___ops___KeepAliveObject *self, void *closure)
{
    if (unlikely(self->_src == NULL)) {
        PyErr_SetString(PyExc_AttributeError,
            "attribute 'src' of 'KeepAlive' undefined");
        return NULL;
    }
    CPy_INCREF(self->_src);
    PyObject *retval = self->_src;
    return retval;
}

static int
ops___KeepAlive_set_src(mypyc___ir___ops___KeepAliveObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_AttributeError,
            "'KeepAlive' object attribute 'src' cannot be deleted");
        return -1;
    }
    if (self->_src != NULL) {
        CPy_DECREF(self->_src);
    }
    PyObject *tmp;
    if (likely(PyList_Check(value)))
        tmp = value;
    else {
        CPy_TypeError("list", value); 
        tmp = NULL;
    }
    if (!tmp)
        return -1;
    CPy_INCREF(tmp);
    self->_src = tmp;
    return 0;
}

PyMemberDef ops___OpVisitor_members[] = {
    {"__dict__", T_OBJECT_EX, sizeof(PyObject), 0, NULL},
    {"__weakref__", T_OBJECT_EX, sizeof(PyObject) + sizeof(PyObject *), 0, NULL},
    {0}
};

static PyGetSetDef ops___OpVisitor_getseters[] = {
    {NULL}  /* Sentinel */
};

static PyObject *
ops___OpVisitor_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    if (type != CPyType_ops___OpVisitor) {
        PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled traits");
    } else {
        PyErr_SetString(PyExc_TypeError, "traits may not be directly created");
    }
    return NULL;
}
static PyMethodDef ops___OpVisitor_methods[] = {
    {"visit_goto",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_goto,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_branch",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_branch,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_return",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_return,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_unreachable",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_unreachable,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_assign",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_assign,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_assign_multi",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_assign_multi,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_load_error_value",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_load_error_value,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_load_literal",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_load_literal,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_get_attr",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_get_attr,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_set_attr",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_set_attr,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_load_static",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_load_static,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_init_static",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_init_static,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_tuple_get",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_tuple_get,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_tuple_set",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_tuple_set,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_inc_ref",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_inc_ref,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_dec_ref",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_dec_ref,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_call",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_call,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_method_call",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_method_call,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_cast",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_cast,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_box",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_box,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_unbox",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_unbox,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_raise_standard_error",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_raise_standard_error,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_call_c",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_call_c,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_truncate",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_truncate,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_extend",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_extend,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_load_global",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_load_global,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_int_op",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_int_op,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_comparison_op",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_comparison_op,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_float_op",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_float_op,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_float_neg",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_float_neg,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_float_comparison_op",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_float_comparison_op,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_load_mem",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_load_mem,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_set_mem",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_set_mem,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_get_element_ptr",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_get_element_ptr,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_load_address",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_load_address,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"visit_keep_alive",
     (PyCFunction)CPyPy_ops___OpVisitor___visit_keep_alive,
     METH_FASTCALL | METH_KEYWORDS, NULL},
    {"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},
    {"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},
    {NULL}  /* Sentinel */
};

static PyTypeObject CPyType_ops___OpVisitor_template_ = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "OpVisitor",
    .tp_new = ops___OpVisitor_new,
    .tp_getset = ops___OpVisitor_getseters,
    .tp_methods = ops___OpVisitor_methods,
    .tp_members = ops___OpVisitor_members,
    .tp_basicsize = sizeof(PyObject) + 2*sizeof(PyObject *),
    .tp_dictoffset = sizeof(PyObject),
    .tp_weaklistoffset = sizeof(PyObject) + sizeof(PyObject *),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE | Py_TPFLAGS_BASETYPE,
};
static PyTypeObject *CPyType_ops___OpVisitor_template = &CPyType_ops___OpVisitor_template_;

static PyMethodDef opsmodule_methods[] = {
    {NULL, NULL, 0, NULL}
};

static struct PyModuleDef opsmodule = {
    PyModuleDef_HEAD_INIT,
    "mypyc.ir.ops",
    NULL, /* docstring */
    -1,       /* size of per-interpreter state of the module,
                 or -1 if the module keeps state in global variables. */
    opsmodule_methods
};

PyObject *CPyInit_mypyc___ir___ops(void)
{
    PyObject* modname = NULL;
    if (CPyModule_mypyc___ir___ops_internal) {
        Py_INCREF(CPyModule_mypyc___ir___ops_internal);
        return CPyModule_mypyc___ir___ops_internal;
    }
    CPyModule_mypyc___ir___ops_internal = PyModule_Create(&opsmodule);
    if (unlikely(CPyModule_mypyc___ir___ops_internal == NULL))
        goto fail;
    modname = PyObject_GetAttrString((PyObject *)CPyModule_mypyc___ir___ops_internal, "__name__");
    CPyStatic_ops___globals = PyModule_GetDict(CPyModule_mypyc___ir___ops_internal);
    if (unlikely(CPyStatic_ops___globals == NULL))
        goto fail;
    if (CPyGlobalsInit() < 0)
        goto fail;
    char result = CPyDef_ops_____top_level__();
    if (result == 2)
        goto fail;
    Py_DECREF(modname);
    return CPyModule_mypyc___ir___ops_internal;
    fail:
    Py_CLEAR(CPyModule_mypyc___ir___ops_internal);
    Py_CLEAR(modname);
    CPy_XDECREF(CPyStatic_ops___IntOp___op_str);
    CPyStatic_ops___IntOp___op_str = NULL;
    CPy_XDECREF(CPyStatic_ops___int_op_to_id);
    CPyStatic_ops___int_op_to_id = NULL;
    CPy_XDECREF(CPyStatic_ops___ComparisonOp___op_str);
    CPyStatic_ops___ComparisonOp___op_str = NULL;
    CPy_XDECREF(CPyStatic_ops___ComparisonOp___signed_ops);
    CPyStatic_ops___ComparisonOp___signed_ops = NULL;
    CPy_XDECREF(CPyStatic_ops___ComparisonOp___unsigned_ops);
    CPyStatic_ops___ComparisonOp___unsigned_ops = NULL;
    CPy_XDECREF(CPyStatic_ops___FloatOp___op_str);
    CPyStatic_ops___FloatOp___op_str = NULL;
    CPy_XDECREF(CPyStatic_ops___float_op_to_id);
    CPyStatic_ops___float_op_to_id = NULL;
    CPy_XDECREF(CPyStatic_ops___FloatComparisonOp___op_str);
    CPyStatic_ops___FloatComparisonOp___op_str = NULL;
    CPy_XDECREF(CPyStatic_ops___float_comparison_op_to_id);
    CPyStatic_ops___float_comparison_op_to_id = NULL;
    Py_CLEAR(CPyType_ops___BasicBlock);
    Py_CLEAR(CPyType_ops___Value);
    Py_CLEAR(CPyType_ops___Register);
    Py_CLEAR(CPyType_ops___Integer);
    Py_CLEAR(CPyType_ops___Float);
    Py_CLEAR(CPyType_ops___Op);
    Py_CLEAR(CPyType_ops___BaseAssign);
    Py_CLEAR(CPyType_ops___Assign);
    Py_CLEAR(CPyType_ops___AssignMulti);
    Py_CLEAR(CPyType_ops___ControlOp);
    Py_CLEAR(CPyType_ops___Goto);
    Py_CLEAR(CPyType_ops___Branch);
    Py_CLEAR(CPyType_ops___Return);
    Py_CLEAR(CPyType_ops___Unreachable);
    Py_CLEAR(CPyType_ops___RegisterOp);
    Py_CLEAR(CPyType_ops___IncRef);
    Py_CLEAR(CPyType_ops___DecRef);
    Py_CLEAR(CPyType_ops___Call);
    Py_CLEAR(CPyType_ops___MethodCall);
    Py_CLEAR(CPyType_ops___LoadErrorValue);
    Py_CLEAR(CPyType_ops___LoadLiteral);
    Py_CLEAR(CPyType_ops___GetAttr);
    Py_CLEAR(CPyType_ops___SetAttr);
    Py_CLEAR(CPyType_ops___LoadStatic);
    Py_CLEAR(CPyType_ops___InitStatic);
    Py_CLEAR(CPyType_ops___TupleSet);
    Py_CLEAR(CPyType_ops___TupleGet);
    Py_CLEAR(CPyType_ops___Cast);
    Py_CLEAR(CPyType_ops___Box);
    Py_CLEAR(CPyType_ops___Unbox);
    Py_CLEAR(CPyType_ops___RaiseStandardError);
    Py_CLEAR(CPyType_ops___CallC);
    Py_CLEAR(CPyType_ops___Truncate);
    Py_CLEAR(CPyType_ops___Extend);
    Py_CLEAR(CPyType_ops___LoadGlobal);
    Py_CLEAR(CPyType_ops___IntOp);
    Py_CLEAR(CPyType_ops___ComparisonOp);
    Py_CLEAR(CPyType_ops___FloatOp);
    Py_CLEAR(CPyType_ops___FloatNeg);
    Py_CLEAR(CPyType_ops___FloatComparisonOp);
    Py_CLEAR(CPyType_ops___LoadMem);
    Py_CLEAR(CPyType_ops___SetMem);
    Py_CLEAR(CPyType_ops___GetElementPtr);
    Py_CLEAR(CPyType_ops___LoadAddress);
    Py_CLEAR(CPyType_ops___KeepAlive);
    Py_CLEAR(CPyType_ops___OpVisitor);
    Py_CLEAR(CPyType_ops___DeserMaps);
    return NULL;
}

char CPyDef_ops___BasicBlock_____init__(PyObject *cpy_r_self, CPyTagged cpy_r_label) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    if (cpy_r_label != CPY_INT_TAG) goto CPyL5;
    cpy_r_label = -2;
CPyL2: ;
    ((mypyc___ir___ops___BasicBlockObject *)cpy_r_self)->_label = cpy_r_label;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 81, CPyStatic_ops___globals);
        goto CPyL4;
    }
    ((mypyc___ir___ops___BasicBlockObject *)cpy_r_self)->_ops = cpy_r_r0;
    cpy_r_r1 = Py_None;
    CPy_INCREF(cpy_r_r1);
    ((mypyc___ir___ops___BasicBlockObject *)cpy_r_self)->_error_handler = cpy_r_r1;
    ((mypyc___ir___ops___BasicBlockObject *)cpy_r_self)->_referenced = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
CPyL5: ;
    CPyTagged_INCREF(cpy_r_label);
    goto CPyL2;
}

PyObject *CPyPy_ops___BasicBlock_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"label", 0};
    PyObject *obj_label = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "|O", "__init__", kwlist, &obj_label)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___BasicBlock))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", obj_self); 
        goto fail;
    }
    CPyTagged arg_label;
    if (obj_label == NULL) {
        arg_label = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_label)))
        arg_label = CPyTagged_BorrowFromObject(obj_label);
    else {
        CPy_TypeError("int", obj_label); goto fail;
    }
    char retval = CPyDef_ops___BasicBlock_____init__(arg_self, arg_label);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 79, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___BasicBlock___terminated(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    CPyPtr cpy_r_r1;
    int64_t cpy_r_r2;
    CPyTagged cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    char cpy_r_r9;
    char cpy_r_r10;
    cpy_r_r0 = ((mypyc___ir___ops___BasicBlockObject *)cpy_r_self)->_ops;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = (CPyPtr)&((PyVarObject *)cpy_r_r0)->ob_size;
    cpy_r_r2 = *(int64_t *)cpy_r_r1;
    CPy_DECREF(cpy_r_r0);
    cpy_r_r3 = cpy_r_r2 << 1;
    cpy_r_r4 = cpy_r_r3 != 0;
    if (cpy_r_r4) goto CPyL2;
    cpy_r_r5 = cpy_r_r4;
    goto CPyL4;
CPyL2: ;
    cpy_r_r6 = ((mypyc___ir___ops___BasicBlockObject *)cpy_r_self)->_ops;
    cpy_r_r7 = CPyList_GetItemShortBorrow(cpy_r_r6, -2);
    if (unlikely(cpy_r_r7 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "terminated", 92, CPyStatic_ops___globals);
        goto CPyL5;
    }
    cpy_r_r8 = (PyObject *)CPyType_ops___ControlOp;
    cpy_r_r9 = CPy_TypeCheck(cpy_r_r7, cpy_r_r8);
    cpy_r_r5 = cpy_r_r9;
CPyL4: ;
    return cpy_r_r5;
CPyL5: ;
    cpy_r_r10 = 2;
    return cpy_r_r10;
}

PyObject *CPyPy_ops___BasicBlock___terminated(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":terminated", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___BasicBlock))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", obj_self); 
        goto fail;
    }
    char retval = CPyDef_ops___BasicBlock___terminated(arg_self);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "terminated", 86, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___BasicBlock___terminator(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    CPyPtr cpy_r_r1;
    int64_t cpy_r_r2;
    CPyTagged cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    char cpy_r_r9;
    char cpy_r_r10;
    PyObject *cpy_r_r11;
    PyObject *cpy_r_r12;
    PyObject *cpy_r_r13;
    PyObject *cpy_r_r14;
    cpy_r_r0 = ((mypyc___ir___ops___BasicBlockObject *)cpy_r_self)->_ops;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = (CPyPtr)&((PyVarObject *)cpy_r_r0)->ob_size;
    cpy_r_r2 = *(int64_t *)cpy_r_r1;
    CPy_DECREF(cpy_r_r0);
    cpy_r_r3 = cpy_r_r2 << 1;
    cpy_r_r4 = cpy_r_r3 != 0;
    if (cpy_r_r4) goto CPyL2;
    cpy_r_r5 = cpy_r_r4;
    goto CPyL4;
CPyL2: ;
    cpy_r_r6 = ((mypyc___ir___ops___BasicBlockObject *)cpy_r_self)->_ops;
    cpy_r_r7 = CPyList_GetItemShortBorrow(cpy_r_r6, -2);
    if (unlikely(cpy_r_r7 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "terminator", 97, CPyStatic_ops___globals);
        goto CPyL10;
    }
    cpy_r_r8 = (PyObject *)CPyType_ops___ControlOp;
    cpy_r_r9 = CPy_TypeCheck(cpy_r_r7, cpy_r_r8);
    cpy_r_r5 = cpy_r_r9;
CPyL4: ;
    if (cpy_r_r5) goto CPyL7;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r10 = 0;
    if (unlikely(!cpy_r_r10)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "terminator", 97, CPyStatic_ops___globals);
        goto CPyL10;
    }
    CPy_Unreachable();
CPyL7: ;
    cpy_r_r11 = ((mypyc___ir___ops___BasicBlockObject *)cpy_r_self)->_ops;
    cpy_r_r12 = CPyList_GetItemShort(cpy_r_r11, -2);
    if (unlikely(cpy_r_r12 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "terminator", 98, CPyStatic_ops___globals);
        goto CPyL10;
    }
    if (likely(PyObject_TypeCheck(cpy_r_r12, CPyType_ops___ControlOp)))
        cpy_r_r13 = cpy_r_r12;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "terminator", 98, CPyStatic_ops___globals, "mypyc.ir.ops.ControlOp", cpy_r_r12);
        goto CPyL10;
    }
    return cpy_r_r13;
CPyL10: ;
    cpy_r_r14 = NULL;
    return cpy_r_r14;
}

PyObject *CPyPy_ops___BasicBlock___terminator(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":terminator", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___BasicBlock))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___BasicBlock___terminator(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "terminator", 95, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Value___is_void(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    PyObject *cpy_r_r3;
    char cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___ValueObject *)cpy_r_self)->_type;
    cpy_r_r1 = (PyObject *)CPyType_rtypes___RVoid;
    cpy_r_r2 = (CPyPtr)&((PyObject *)cpy_r_r0)->ob_type;
    cpy_r_r3 = *(PyObject * *)cpy_r_r2;
    cpy_r_r4 = cpy_r_r3 == cpy_r_r1;
    return cpy_r_r4;
}

PyObject *CPyPy_ops___Value___is_void(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":is_void", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___Value)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_self); 
        goto fail;
    }
    char retval = CPyDef_ops___Value___is_void(arg_self);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "is_void", 140, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Value_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___ValueObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___ValueObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___ValueObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___Value_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(PyObject_TypeCheck(obj___mypyc_self__, CPyType_ops___Value)))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Value_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Register_____init__(PyObject *cpy_r_self, PyObject *cpy_r_type, PyObject *cpy_r_name, char cpy_r_is_arg, CPyTagged cpy_r_line) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    if (cpy_r_name != NULL) goto CPyL7;
    cpy_r_r0 = CPyStatics[163]; /* '' */
    CPy_INCREF(cpy_r_r0);
    cpy_r_name = cpy_r_r0;
CPyL2: ;
    if (cpy_r_is_arg != 2) goto CPyL4;
    cpy_r_is_arg = 0;
CPyL4: ;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL8;
    cpy_r_line = -2;
CPyL6: ;
    CPy_INCREF(cpy_r_type);
    CPy_DECREF(((mypyc___ir___ops___RegisterObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___RegisterObject *)cpy_r_self)->_type = cpy_r_type;
    ((mypyc___ir___ops___RegisterObject *)cpy_r_self)->_name = cpy_r_name;
    ((mypyc___ir___ops___RegisterObject *)cpy_r_self)->_is_arg = cpy_r_is_arg;
    ((mypyc___ir___ops___RegisterObject *)cpy_r_self)->_is_borrowed = cpy_r_is_arg;
    CPyTagged_DECREF(((mypyc___ir___ops___RegisterObject *)cpy_r_self)->_line);
    ((mypyc___ir___ops___RegisterObject *)cpy_r_self)->_line = cpy_r_line;
    return 1;
CPyL7: ;
    CPy_INCREF(cpy_r_name);
    goto CPyL2;
CPyL8: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL6;
}

PyObject *CPyPy_ops___Register_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"type", "name", "is_arg", "line", 0};
    PyObject *obj_type;
    PyObject *obj_name = NULL;
    PyObject *obj_is_arg = NULL;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O|OOO", "__init__", kwlist, &obj_type, &obj_name, &obj_is_arg, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Register))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Register", obj_self); 
        goto fail;
    }
    PyObject *arg_type;
    if (likely(PyObject_TypeCheck(obj_type, CPyType_rtypes___RType)))
        arg_type = obj_type;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_type); 
        goto fail;
    }
    PyObject *arg_name;
    if (obj_name == NULL) {
        arg_name = NULL;
    } else if (likely(PyUnicode_Check(obj_name)))
        arg_name = obj_name;
    else {
        CPy_TypeError("str", obj_name); 
        goto fail;
    }
    char arg_is_arg;
    if (obj_is_arg == NULL) {
        arg_is_arg = 2;
    } else if (unlikely(!PyBool_Check(obj_is_arg))) {
        CPy_TypeError("bool", obj_is_arg); goto fail;
    } else
        arg_is_arg = obj_is_arg == Py_True;
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Register_____init__(arg_self, arg_type, arg_name, arg_is_arg, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 155, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Register___is_void(PyObject *cpy_r_self) {
    return 0;
}

PyObject *CPyPy_ops___Register___is_void(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":is_void", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Register))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Register", obj_self); 
        goto fail;
    }
    char retval = CPyDef_ops___Register___is_void(arg_self);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "is_void", 163, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Register_____repr__(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject **cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject *cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    CPyTagged cpy_r_r12;
    PyObject *cpy_r_r13;
    PyObject *cpy_r_r14;
    PyObject *cpy_r_r15;
    PyObject *cpy_r_r16;
    PyObject **cpy_r_r18;
    PyObject *cpy_r_r19;
    PyObject *cpy_r_r20;
    PyObject *cpy_r_r21;
    PyObject *cpy_r_r22;
    PyObject **cpy_r_r24;
    PyObject *cpy_r_r25;
    PyObject *cpy_r_r26;
    PyObject *cpy_r_r27;
    PyObject *cpy_r_r28;
    CPyPtr cpy_r_r29;
    CPyPtr cpy_r_r30;
    CPyPtr cpy_r_r31;
    CPyPtr cpy_r_r32;
    CPyPtr cpy_r_r33;
    CPyPtr cpy_r_r34;
    PyObject *cpy_r_r35;
    PyObject *cpy_r_r36;
    cpy_r_r0 = CPyStatics[163]; /* '' */
    cpy_r_r1 = CPyStatics[7804]; /* '<Register ' */
    cpy_r_r2 = CPyStatics[353]; /* '{!r:{}}' */
    cpy_r_r3 = ((mypyc___ir___ops___RegisterObject *)cpy_r_self)->_name;
    CPy_INCREF(cpy_r_r3);
    cpy_r_r4 = CPyStatics[163]; /* '' */
    cpy_r_r5 = CPyStatics[193]; /* 'format' */
    PyObject *cpy_r_r6[3] = {cpy_r_r2, cpy_r_r3, cpy_r_r4};
    cpy_r_r7 = (PyObject **)&cpy_r_r6;
    cpy_r_r8 = PyObject_VectorcallMethod(cpy_r_r5, cpy_r_r7, 9223372036854775811ULL, 0);
    if (unlikely(cpy_r_r8 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 167, CPyStatic_ops___globals);
        goto CPyL11;
    }
    CPy_DECREF(cpy_r_r3);
    if (likely(PyUnicode_Check(cpy_r_r8)))
        cpy_r_r9 = cpy_r_r8;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__repr__", 167, CPyStatic_ops___globals, "str", cpy_r_r8);
        goto CPyL10;
    }
    cpy_r_r10 = CPyStatics[293]; /* ' at ' */
    cpy_r_r11 = CPyStatics[221]; /* '{:{}}' */
    cpy_r_r12 = CPyTagged_Id(cpy_r_self);
    cpy_r_r13 = CPyModule_builtins;
    cpy_r_r14 = CPyStatics[7805]; /* 'hex' */
    cpy_r_r15 = CPyObject_GetAttr(cpy_r_r13, cpy_r_r14);
    if (unlikely(cpy_r_r15 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 167, CPyStatic_ops___globals);
        goto CPyL12;
    }
    cpy_r_r16 = CPyTagged_StealAsObject(cpy_r_r12);
    PyObject *cpy_r_r17[1] = {cpy_r_r16};
    cpy_r_r18 = (PyObject **)&cpy_r_r17;
    cpy_r_r19 = _PyObject_Vectorcall(cpy_r_r15, cpy_r_r18, 1, 0);
    CPy_DECREF(cpy_r_r15);
    if (unlikely(cpy_r_r19 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 167, CPyStatic_ops___globals);
        goto CPyL13;
    }
    CPy_DECREF(cpy_r_r16);
    if (likely(PyUnicode_Check(cpy_r_r19)))
        cpy_r_r20 = cpy_r_r19;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__repr__", 167, CPyStatic_ops___globals, "str", cpy_r_r19);
        goto CPyL14;
    }
    cpy_r_r21 = CPyStatics[163]; /* '' */
    cpy_r_r22 = CPyStatics[193]; /* 'format' */
    PyObject *cpy_r_r23[3] = {cpy_r_r11, cpy_r_r20, cpy_r_r21};
    cpy_r_r24 = (PyObject **)&cpy_r_r23;
    cpy_r_r25 = PyObject_VectorcallMethod(cpy_r_r22, cpy_r_r24, 9223372036854775811ULL, 0);
    if (unlikely(cpy_r_r25 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 167, CPyStatic_ops___globals);
        goto CPyL15;
    }
    CPy_DECREF(cpy_r_r20);
    if (likely(PyUnicode_Check(cpy_r_r25)))
        cpy_r_r26 = cpy_r_r25;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__repr__", 167, CPyStatic_ops___globals, "str", cpy_r_r25);
        goto CPyL14;
    }
    cpy_r_r27 = CPyStatics[840]; /* '>' */
    cpy_r_r28 = PyList_New(5);
    if (unlikely(cpy_r_r28 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 167, CPyStatic_ops___globals);
        goto CPyL16;
    }
    cpy_r_r29 = (CPyPtr)&((PyListObject *)cpy_r_r28)->ob_item;
    cpy_r_r30 = *(CPyPtr *)cpy_r_r29;
    CPy_INCREF(cpy_r_r1);
    *(PyObject * *)cpy_r_r30 = cpy_r_r1;
    cpy_r_r31 = cpy_r_r30 + 8;
    *(PyObject * *)cpy_r_r31 = cpy_r_r9;
    cpy_r_r32 = cpy_r_r30 + 16;
    CPy_INCREF(cpy_r_r10);
    *(PyObject * *)cpy_r_r32 = cpy_r_r10;
    cpy_r_r33 = cpy_r_r30 + 24;
    *(PyObject * *)cpy_r_r33 = cpy_r_r26;
    cpy_r_r34 = cpy_r_r30 + 32;
    CPy_INCREF(cpy_r_r27);
    *(PyObject * *)cpy_r_r34 = cpy_r_r27;
    cpy_r_r35 = PyUnicode_Join(cpy_r_r0, cpy_r_r28);
    CPy_DECREF(cpy_r_r28);
    if (unlikely(cpy_r_r35 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 167, CPyStatic_ops___globals);
        goto CPyL10;
    }
    return cpy_r_r35;
CPyL10: ;
    cpy_r_r36 = NULL;
    return cpy_r_r36;
CPyL11: ;
    CPy_DecRef(cpy_r_r3);
    goto CPyL10;
CPyL12: ;
    CPy_DecRef(cpy_r_r9);
    CPyTagged_DecRef(cpy_r_r12);
    goto CPyL10;
CPyL13: ;
    CPy_DecRef(cpy_r_r9);
    CPy_DecRef(cpy_r_r16);
    goto CPyL10;
CPyL14: ;
    CPy_DecRef(cpy_r_r9);
    goto CPyL10;
CPyL15: ;
    CPy_DecRef(cpy_r_r9);
    CPy_DecRef(cpy_r_r20);
    goto CPyL10;
CPyL16: ;
    CPy_DecRef(cpy_r_r9);
    CPy_DecRef(cpy_r_r26);
    goto CPyL10;
}

PyObject *CPyPy_ops___Register_____repr__(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__repr__", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Register))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Register", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Register_____repr__(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 166, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Register_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___RegisterObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___RegisterObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___RegisterObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___Register_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Register))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Register", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Register_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Integer_____init__(PyObject *cpy_r_self, CPyTagged cpy_r_value, PyObject *cpy_r_rtype, CPyTagged cpy_r_line) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    CPyTagged cpy_r_r4;
    char cpy_r_r5;
    char cpy_r_r6;
    char cpy_r_r7;
    if (cpy_r_rtype != NULL) goto CPyL15;
    cpy_r_r0 = CPyStatic_rtypes___short_int_rprimitive;
    if (likely(cpy_r_r0 != NULL)) goto CPyL4;
    PyErr_SetString(PyExc_NameError, "value for final name \"short_int_rprimitive\" was not set");
    cpy_r_r1 = 0;
    if (unlikely(!cpy_r_r1)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 186, CPyStatic_ops___globals);
        goto CPyL14;
    }
    CPy_Unreachable();
CPyL4: ;
    CPy_INCREF(cpy_r_r0);
    cpy_r_rtype = cpy_r_r0;
CPyL5: ;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL16;
    cpy_r_line = -2;
CPyL7: ;
    cpy_r_r2 = CPyDef_rtypes___is_short_int_rprimitive(cpy_r_rtype);
    if (unlikely(cpy_r_r2 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 187, CPyStatic_ops___globals);
        goto CPyL17;
    }
    if (cpy_r_r2) goto CPyL11;
    cpy_r_r3 = CPyDef_rtypes___is_int_rprimitive(cpy_r_rtype);
    if (unlikely(cpy_r_r3 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 187, CPyStatic_ops___globals);
        goto CPyL17;
    }
    if (!cpy_r_r3) goto CPyL12;
CPyL11: ;
    cpy_r_r4 = CPyTagged_Multiply(cpy_r_value, 4);
    ((mypyc___ir___ops___IntegerObject *)cpy_r_self)->_value = cpy_r_r4;
    goto CPyL13;
CPyL12: ;
    CPyTagged_INCREF(cpy_r_value);
    ((mypyc___ir___ops___IntegerObject *)cpy_r_self)->_value = cpy_r_value;
CPyL13: ;
    CPy_DECREF(((mypyc___ir___ops___IntegerObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___IntegerObject *)cpy_r_self)->_type = cpy_r_rtype;
    CPyTagged_DECREF(((mypyc___ir___ops___IntegerObject *)cpy_r_self)->_line);
    ((mypyc___ir___ops___IntegerObject *)cpy_r_self)->_line = cpy_r_line;
    return 1;
CPyL14: ;
    cpy_r_r7 = 2;
    return cpy_r_r7;
CPyL15: ;
    CPy_INCREF(cpy_r_rtype);
    goto CPyL5;
CPyL16: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL7;
CPyL17: ;
    CPy_DecRef(cpy_r_rtype);
    CPyTagged_DecRef(cpy_r_line);
    goto CPyL14;
}

PyObject *CPyPy_ops___Integer_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"value", "rtype", "line", 0};
    PyObject *obj_value;
    PyObject *obj_rtype = NULL;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O|OO", "__init__", kwlist, &obj_value, &obj_rtype, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Integer))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Integer", obj_self); 
        goto fail;
    }
    CPyTagged arg_value;
    if (likely(PyLong_Check(obj_value)))
        arg_value = CPyTagged_BorrowFromObject(obj_value);
    else {
        CPy_TypeError("int", obj_value); goto fail;
    }
    PyObject *arg_rtype;
    if (obj_rtype == NULL) {
        arg_rtype = NULL;
    } else if (likely(PyObject_TypeCheck(obj_rtype, CPyType_rtypes___RType)))
        arg_rtype = obj_rtype;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_rtype); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Integer_____init__(arg_self, arg_value, arg_rtype, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 186, CPyStatic_ops___globals);
    return NULL;
}

CPyTagged CPyDef_ops___Integer___numeric_value(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    CPyTagged cpy_r_r4;
    CPyTagged cpy_r_r5;
    CPyTagged cpy_r_r6;
    CPyTagged cpy_r_r7;
    cpy_r_r0 = ((mypyc___ir___ops___IntegerObject *)cpy_r_self)->_type;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = CPyDef_rtypes___is_short_int_rprimitive(cpy_r_r0);
    CPy_DECREF(cpy_r_r0);
    if (unlikely(cpy_r_r1 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "numeric_value", 195, CPyStatic_ops___globals);
        goto CPyL7;
    }
    if (cpy_r_r1) goto CPyL4;
    cpy_r_r2 = ((mypyc___ir___ops___IntegerObject *)cpy_r_self)->_type;
    CPy_INCREF(cpy_r_r2);
    cpy_r_r3 = CPyDef_rtypes___is_int_rprimitive(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(cpy_r_r3 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "numeric_value", 195, CPyStatic_ops___globals);
        goto CPyL7;
    }
    if (!cpy_r_r3) goto CPyL6;
CPyL4: ;
    cpy_r_r4 = ((mypyc___ir___ops___IntegerObject *)cpy_r_self)->_value;
    CPyTagged_INCREF(cpy_r_r4);
    cpy_r_r5 = CPyTagged_Rshift(cpy_r_r4, 2);
    CPyTagged_DECREF(cpy_r_r4);
    if (unlikely(cpy_r_r5 == CPY_INT_TAG)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "numeric_value", -1, CPyStatic_ops___globals);
        goto CPyL7;
    }
    return cpy_r_r5;
CPyL6: ;
    cpy_r_r6 = ((mypyc___ir___ops___IntegerObject *)cpy_r_self)->_value;
    CPyTagged_INCREF(cpy_r_r6);
    return cpy_r_r6;
CPyL7: ;
    cpy_r_r7 = CPY_INT_TAG;
    return cpy_r_r7;
}

PyObject *CPyPy_ops___Integer___numeric_value(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":numeric_value", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Integer))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Integer", obj_self); 
        goto fail;
    }
    CPyTagged retval = CPyDef_ops___Integer___numeric_value(arg_self);
    if (retval == CPY_INT_TAG) {
        return NULL;
    }
    PyObject *retbox = CPyTagged_StealAsObject(retval);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "numeric_value", 194, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Integer_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___IntegerObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___IntegerObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___IntegerObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___Integer_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Integer))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Integer", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Integer_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Float_____init__(PyObject *cpy_r_self, double cpy_r_value, CPyTagged cpy_r_line) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL7;
    cpy_r_line = -2;
CPyL2: ;
    ((mypyc___ir___ops___FloatObject *)cpy_r_self)->_value = cpy_r_value;
    cpy_r_r0 = CPyStatic_rtypes___float_rprimitive;
    if (unlikely(cpy_r_r0 == NULL)) {
        goto CPyL8;
    } else
        goto CPyL5;
CPyL3: ;
    PyErr_SetString(PyExc_NameError, "value for final name \"float_rprimitive\" was not set");
    cpy_r_r1 = 0;
    if (unlikely(!cpy_r_r1)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 210, CPyStatic_ops___globals);
        goto CPyL6;
    }
    CPy_Unreachable();
CPyL5: ;
    CPy_INCREF(cpy_r_r0);
    CPy_DECREF(((mypyc___ir___ops___FloatObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___FloatObject *)cpy_r_self)->_type = cpy_r_r0;
    CPyTagged_DECREF(((mypyc___ir___ops___FloatObject *)cpy_r_self)->_line);
    ((mypyc___ir___ops___FloatObject *)cpy_r_self)->_line = cpy_r_line;
    return 1;
CPyL6: ;
    cpy_r_r4 = 2;
    return cpy_r_r4;
CPyL7: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
CPyL8: ;
    CPyTagged_DecRef(cpy_r_line);
    goto CPyL3;
}

PyObject *CPyPy_ops___Float_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"value", "line", 0};
    PyObject *obj_value;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O|O", "__init__", kwlist, &obj_value, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Float))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Float", obj_self); 
        goto fail;
    }
    double arg_value;
    arg_value = PyFloat_AsDouble(obj_value);
    if (arg_value == -1.0 && PyErr_Occurred()) {
        CPy_TypeError("float", obj_value); goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Float_____init__(arg_self, arg_value, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 208, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Float_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___FloatObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___FloatObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___FloatObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___Float_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Float))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Float", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Float_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Op_____init__(PyObject *cpy_r_self, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    CPyTagged_INCREF(cpy_r_line);
    CPyTagged_DECREF(((mypyc___ir___ops___OpObject *)cpy_r_self)->_line);
    ((mypyc___ir___ops___OpObject *)cpy_r_self)->_line = cpy_r_line;
    return 1;
}

PyObject *CPyPy_ops___Op_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"line", 0};
    PyObject *obj_line;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O", "__init__", kwlist, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___Op)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Op", obj_self); 
        goto fail;
    }
    CPyTagged arg_line;
    if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Op_____init__(arg_self, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 226, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Op___can_raise(PyObject *cpy_r_self) {
    return 0;
}

PyObject *CPyPy_ops___Op___can_raise(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":can_raise", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___Op)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Op", obj_self); 
        goto fail;
    }
    char retval = CPyDef_ops___Op___can_raise(arg_self);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "can_raise", 229, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Op___sources(PyObject *cpy_r_self) {
    CPy_Unreachable();
}

PyObject *CPyPy_ops___Op___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___Op)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Op", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Op___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 235, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Op___stolen(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 240, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Op___stolen(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":stolen", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___Op)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Op", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Op___stolen(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 238, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Op___unique_sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_result;
    PyObject *cpy_r_r1;
    CPyTagged cpy_r_r2;
    CPyPtr cpy_r_r3;
    int64_t cpy_r_r4;
    CPyTagged cpy_r_r5;
    char cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject *cpy_r_reg;
    int32_t cpy_r_r9;
    char cpy_r_r10;
    char cpy_r_r11;
    char cpy_r_r12;
    int32_t cpy_r_r13;
    char cpy_r_r14;
    CPyTagged cpy_r_r15;
    PyObject *cpy_r_r16;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "unique_sources", 243, CPyStatic_ops___globals);
        goto CPyL10;
    }
    cpy_r_result = cpy_r_r0;
    cpy_r_r1 = CPY_GET_METHOD(cpy_r_self, CPyType_ops___Op, 4, mypyc___ir___ops___OpObject, PyObject * (*)(PyObject *))(cpy_r_self); /* sources */
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "unique_sources", 244, CPyStatic_ops___globals);
        goto CPyL11;
    }
    cpy_r_r2 = 0;
CPyL3: ;
    cpy_r_r3 = (CPyPtr)&((PyVarObject *)cpy_r_r1)->ob_size;
    cpy_r_r4 = *(int64_t *)cpy_r_r3;
    cpy_r_r5 = cpy_r_r4 << 1;
    cpy_r_r6 = (Py_ssize_t)cpy_r_r2 < (Py_ssize_t)cpy_r_r5;
    if (!cpy_r_r6) goto CPyL12;
    cpy_r_r7 = CPyList_GetItemUnsafe(cpy_r_r1, cpy_r_r2);
    if (likely(PyObject_TypeCheck(cpy_r_r7, CPyType_ops___Value)))
        cpy_r_r8 = cpy_r_r7;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "unique_sources", 244, CPyStatic_ops___globals, "mypyc.ir.ops.Value", cpy_r_r7);
        goto CPyL13;
    }
    cpy_r_reg = cpy_r_r8;
    cpy_r_r9 = PySequence_Contains(cpy_r_result, cpy_r_reg);
    cpy_r_r10 = cpy_r_r9 >= 0;
    if (unlikely(!cpy_r_r10)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "unique_sources", 245, CPyStatic_ops___globals);
        goto CPyL14;
    }
    cpy_r_r11 = cpy_r_r9;
    cpy_r_r12 = cpy_r_r11 ^ 1;
    if (!cpy_r_r12) goto CPyL15;
    cpy_r_r13 = PyList_Append(cpy_r_result, cpy_r_reg);
    CPy_DECREF(cpy_r_reg);
    cpy_r_r14 = cpy_r_r13 >= 0;
    if (unlikely(!cpy_r_r14)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "unique_sources", 246, CPyStatic_ops___globals);
        goto CPyL13;
    }
CPyL8: ;
    cpy_r_r15 = cpy_r_r2 + 2;
    cpy_r_r2 = cpy_r_r15;
    goto CPyL3;
CPyL9: ;
    return cpy_r_result;
CPyL10: ;
    cpy_r_r16 = NULL;
    return cpy_r_r16;
CPyL11: ;
    CPy_DecRef(cpy_r_result);
    goto CPyL10;
CPyL12: ;
    CPy_DECREF(cpy_r_r1);
    goto CPyL9;
CPyL13: ;
    CPy_DecRef(cpy_r_result);
    CPy_DecRef(cpy_r_r1);
    goto CPyL10;
CPyL14: ;
    CPy_DecRef(cpy_r_result);
    CPy_DecRef(cpy_r_r1);
    CPy_DecRef(cpy_r_reg);
    goto CPyL10;
CPyL15: ;
    CPy_DECREF(cpy_r_reg);
    goto CPyL8;
}

PyObject *CPyPy_ops___Op___unique_sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":unique_sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___Op)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Op", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Op___unique_sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "unique_sources", 242, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Op___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    cpy_r_r0 = Py_None;
    CPy_INCREF(cpy_r_r0);
    return cpy_r_r0;
}

PyObject *CPyPy_ops___Op___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___Op)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Op", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Op___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 250, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Op_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___OpObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___OpObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___OpObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___Op_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(PyObject_TypeCheck(obj___mypyc_self__, CPyType_ops___Op)))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Op", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Op_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___BaseAssign_____init__(PyObject *cpy_r_self, PyObject *cpy_r_dest, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    char cpy_r_r1;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL5;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___Op_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 258, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_INCREF(cpy_r_dest);
    ((mypyc___ir___ops___BaseAssignObject *)cpy_r_self)->_dest = cpy_r_dest;
    return 1;
CPyL4: ;
    cpy_r_r1 = 2;
    return cpy_r_r1;
CPyL5: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___BaseAssign_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"dest", "line", 0};
    PyObject *obj_dest;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O|O", "__init__", kwlist, &obj_dest, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely((Py_TYPE(obj_self) == CPyType_ops___Assign) || (Py_TYPE(obj_self) == CPyType_ops___AssignMulti)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.BaseAssign", obj_self); 
        goto fail;
    }
    PyObject *arg_dest;
    if (likely(Py_TYPE(obj_dest) == CPyType_ops___Register))
        arg_dest = obj_dest;
    else {
        CPy_TypeError("mypyc.ir.ops.Register", obj_dest); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___BaseAssign_____init__(arg_self, arg_dest, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 257, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___BaseAssign_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___BaseAssignObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___BaseAssignObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___BaseAssignObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___BaseAssign_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely((Py_TYPE(obj___mypyc_self__) == CPyType_ops___Assign) || (Py_TYPE(obj___mypyc_self__) == CPyType_ops___AssignMulti)))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.BaseAssign", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___BaseAssign_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Assign_____init__(PyObject *cpy_r_self, PyObject *cpy_r_dest, PyObject *cpy_r_src, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    char cpy_r_r1;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL5;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___BaseAssign_____init__(cpy_r_self, cpy_r_dest, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 268, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___AssignObject *)cpy_r_self)->_src = cpy_r_src;
    return 1;
CPyL4: ;
    cpy_r_r1 = 2;
    return cpy_r_r1;
CPyL5: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___Assign_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"dest", "src", "line", 0};
    PyObject *obj_dest;
    PyObject *obj_src;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OO|O", "__init__", kwlist, &obj_dest, &obj_src, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Assign))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Assign", obj_self); 
        goto fail;
    }
    PyObject *arg_dest;
    if (likely(Py_TYPE(obj_dest) == CPyType_ops___Register))
        arg_dest = obj_dest;
    else {
        CPy_TypeError("mypyc.ir.ops.Register", obj_dest); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Assign_____init__(arg_self, arg_dest, arg_src, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 267, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Assign___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___AssignObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 272, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___Assign___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Assign))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Assign", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Assign___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 271, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Assign___stolen(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___AssignObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 275, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___Assign___stolen(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":stolen", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Assign))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Assign", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Assign___stolen(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 274, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Assign___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 4, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_assign */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 278, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Assign___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Assign))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Assign", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Assign___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 277, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Assign_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___AssignObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___AssignObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___AssignObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___AssignObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___Assign_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Assign))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Assign", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Assign_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___AssignMulti_____init__(PyObject *cpy_r_self, PyObject *cpy_r_dest, PyObject *cpy_r_src, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    CPyPtr cpy_r_r1;
    int64_t cpy_r_r2;
    CPyTagged cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    CPyPtr cpy_r_r8;
    PyObject *cpy_r_r9;
    char cpy_r_r10;
    char cpy_r_r11;
    PyObject *cpy_r_r12;
    PyObject *cpy_r_r13;
    CPyTagged cpy_r_r14;
    CPyPtr cpy_r_r15;
    int64_t cpy_r_r16;
    CPyTagged cpy_r_r17;
    int64_t cpy_r_r18;
    char cpy_r_r19;
    char cpy_r_r20;
    char cpy_r_r21;
    char cpy_r_r22;
    char cpy_r_r23;
    char cpy_r_r24;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL18;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___BaseAssign_____init__(cpy_r_self, cpy_r_dest, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 295, CPyStatic_ops___globals);
        goto CPyL17;
    }
    cpy_r_r1 = (CPyPtr)&((PyVarObject *)cpy_r_src)->ob_size;
    cpy_r_r2 = *(int64_t *)cpy_r_r1;
    cpy_r_r3 = cpy_r_r2 << 1;
    cpy_r_r4 = cpy_r_r3 != 0;
    if (cpy_r_r4) goto CPyL6;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r5 = 0;
    if (unlikely(!cpy_r_r5)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 296, CPyStatic_ops___globals);
        goto CPyL17;
    }
    CPy_Unreachable();
CPyL6: ;
    cpy_r_r6 = ((mypyc___ir___ops___RegisterObject *)cpy_r_dest)->_type;
    cpy_r_r7 = (PyObject *)CPyType_rtypes___RArray;
    cpy_r_r8 = (CPyPtr)&((PyObject *)cpy_r_r6)->ob_type;
    cpy_r_r9 = *(PyObject * *)cpy_r_r8;
    cpy_r_r10 = cpy_r_r9 == cpy_r_r7;
    if (cpy_r_r10) goto CPyL9;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r11 = 0;
    if (unlikely(!cpy_r_r11)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 297, CPyStatic_ops___globals);
        goto CPyL17;
    }
    CPy_Unreachable();
CPyL9: ;
    cpy_r_r12 = ((mypyc___ir___ops___RegisterObject *)cpy_r_dest)->_type;
    if (likely(Py_TYPE(cpy_r_r12) == CPyType_rtypes___RArray))
        cpy_r_r13 = cpy_r_r12;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__init__", 298, CPyStatic_ops___globals, "mypyc.ir.rtypes.RArray", cpy_r_r12);
        goto CPyL17;
    }
    cpy_r_r14 = ((mypyc___ir___rtypes___RArrayObject *)cpy_r_r13)->_length;
    CPyTagged_INCREF(cpy_r_r14);
    cpy_r_r15 = (CPyPtr)&((PyVarObject *)cpy_r_src)->ob_size;
    cpy_r_r16 = *(int64_t *)cpy_r_r15;
    cpy_r_r17 = cpy_r_r16 << 1;
    cpy_r_r18 = cpy_r_r14 & 1;
    cpy_r_r19 = cpy_r_r18 == 0;
    if (!cpy_r_r19) goto CPyL12;
    cpy_r_r20 = cpy_r_r14 == cpy_r_r17;
    CPyTagged_DECREF(cpy_r_r14);
    cpy_r_r21 = cpy_r_r20;
    goto CPyL13;
CPyL12: ;
    cpy_r_r22 = CPyTagged_IsEq_(cpy_r_r14, cpy_r_r17);
    CPyTagged_DECREF(cpy_r_r14);
    cpy_r_r21 = cpy_r_r22;
CPyL13: ;
    if (cpy_r_r21) goto CPyL16;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r23 = 0;
    if (unlikely(!cpy_r_r23)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 298, CPyStatic_ops___globals);
        goto CPyL17;
    }
    CPy_Unreachable();
CPyL16: ;
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___AssignMultiObject *)cpy_r_self)->_src = cpy_r_src;
    return 1;
CPyL17: ;
    cpy_r_r24 = 2;
    return cpy_r_r24;
CPyL18: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___AssignMulti_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"dest", "src", "line", 0};
    PyObject *obj_dest;
    PyObject *obj_src;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OO|O", "__init__", kwlist, &obj_dest, &obj_src, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___AssignMulti))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.AssignMulti", obj_self); 
        goto fail;
    }
    PyObject *arg_dest;
    if (likely(Py_TYPE(obj_dest) == CPyType_ops___Register))
        arg_dest = obj_dest;
    else {
        CPy_TypeError("mypyc.ir.ops.Register", obj_dest); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyList_Check(obj_src)))
        arg_src = obj_src;
    else {
        CPy_TypeError("list", obj_src); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___AssignMulti_____init__(arg_self, arg_dest, arg_src, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 294, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___AssignMulti___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject **cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___AssignMultiObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = CPyStatics[362]; /* 'copy' */
    PyObject *cpy_r_r2[1] = {cpy_r_r0};
    cpy_r_r3 = (PyObject **)&cpy_r_r2;
    cpy_r_r4 = PyObject_VectorcallMethod(cpy_r_r1, cpy_r_r3, 9223372036854775809ULL, 0);
    if (unlikely(cpy_r_r4 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 302, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_DECREF(cpy_r_r0);
    if (likely(PyList_Check(cpy_r_r4)))
        cpy_r_r5 = cpy_r_r4;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "sources", 302, CPyStatic_ops___globals, "list", cpy_r_r4);
        goto CPyL3;
    }
    return cpy_r_r5;
CPyL3: ;
    cpy_r_r6 = NULL;
    return cpy_r_r6;
CPyL4: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL3;
}

PyObject *CPyPy_ops___AssignMulti___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___AssignMulti))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.AssignMulti", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___AssignMulti___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 301, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___AssignMulti___stolen(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 305, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___AssignMulti___stolen(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":stolen", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___AssignMulti))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.AssignMulti", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___AssignMulti___stolen(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 304, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___AssignMulti___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 5, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_assign_multi */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 308, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___AssignMulti___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___AssignMulti))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.AssignMulti", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___AssignMulti___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 307, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___AssignMulti_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___AssignMultiObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___AssignMultiObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___AssignMultiObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___AssignMultiObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___AssignMulti_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___AssignMulti))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.AssignMulti", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___AssignMulti_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___ControlOp___targets(PyObject *cpy_r_self) {
    tuple_T0 cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0.empty_struct_error_flag = 0;
    cpy_r_r1 = PyTuple_New(0);
    if (unlikely(cpy_r_r1 == NULL))
        CPyError_OutOfMemory();
    return cpy_r_r1;
}

PyObject *CPyPy_ops___ControlOp___targets(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":targets", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___ControlOp)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.ControlOp", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___ControlOp___targets(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "targets", 314, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___ControlOp___set_target(PyObject *cpy_r_self, CPyTagged cpy_r_i, PyObject *cpy_r_new) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject **cpy_r_r10;
    PyObject *cpy_r_r11;
    char cpy_r_r12;
    cpy_r_r0 = CPyStatics[7806]; /* 'Invalid set_target(' */
    cpy_r_r1 = PyObject_Str(cpy_r_self);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "set_target", 320, CPyStatic_ops___globals);
        goto CPyL7;
    }
    cpy_r_r2 = CPyStatics[71]; /* ', ' */
    cpy_r_r3 = CPyTagged_Str(cpy_r_i);
    if (unlikely(cpy_r_r3 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "set_target", 320, CPyStatic_ops___globals);
        goto CPyL8;
    }
    cpy_r_r4 = CPyStatics[72]; /* ')' */
    cpy_r_r5 = CPyStr_Build(5, cpy_r_r0, cpy_r_r1, cpy_r_r2, cpy_r_r3, cpy_r_r4);
    CPy_DECREF(cpy_r_r1);
    CPy_DECREF(cpy_r_r3);
    if (unlikely(cpy_r_r5 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "set_target", 320, CPyStatic_ops___globals);
        goto CPyL7;
    }
    cpy_r_r6 = CPyModule_builtins;
    cpy_r_r7 = CPyStatics[23]; /* 'AssertionError' */
    cpy_r_r8 = CPyObject_GetAttr(cpy_r_r6, cpy_r_r7);
    if (unlikely(cpy_r_r8 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "set_target", 320, CPyStatic_ops___globals);
        goto CPyL9;
    }
    PyObject *cpy_r_r9[1] = {cpy_r_r5};
    cpy_r_r10 = (PyObject **)&cpy_r_r9;
    cpy_r_r11 = _PyObject_Vectorcall(cpy_r_r8, cpy_r_r10, 1, 0);
    CPy_DECREF(cpy_r_r8);
    if (unlikely(cpy_r_r11 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "set_target", 320, CPyStatic_ops___globals);
        goto CPyL9;
    }
    CPy_DECREF(cpy_r_r5);
    CPy_Raise(cpy_r_r11);
    CPy_DECREF(cpy_r_r11);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "set_target", 320, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_Unreachable();
CPyL7: ;
    cpy_r_r12 = 2;
    return cpy_r_r12;
CPyL8: ;
    CPy_DecRef(cpy_r_r1);
    goto CPyL7;
CPyL9: ;
    CPy_DecRef(cpy_r_r5);
    goto CPyL7;
}

PyObject *CPyPy_ops___ControlOp___set_target(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"i", "new", 0};
    static CPyArg_Parser parser = {"OO:set_target", kwlist, 0};
    PyObject *obj_i;
    PyObject *obj_new;
    if (!CPyArg_ParseStackAndKeywordsSimple(args, nargs, kwnames, &parser, &obj_i, &obj_new)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___ControlOp)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.ControlOp", obj_self); 
        goto fail;
    }
    CPyTagged arg_i;
    if (likely(PyLong_Check(obj_i)))
        arg_i = CPyTagged_BorrowFromObject(obj_i);
    else {
        CPy_TypeError("int", obj_i); goto fail;
    }
    PyObject *arg_new;
    if (likely(Py_TYPE(obj_new) == CPyType_ops___BasicBlock))
        arg_new = obj_new;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", obj_new); 
        goto fail;
    }
    char retval = CPyDef_ops___ControlOp___set_target(arg_self, arg_i, arg_new);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "set_target", 318, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___ControlOp_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___ControlOpObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___ControlOpObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___ControlOpObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___ControlOp_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(PyObject_TypeCheck(obj___mypyc_self__, CPyType_ops___ControlOp)))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.ControlOp", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___ControlOp_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Goto_____init__(PyObject *cpy_r_self, PyObject *cpy_r_label, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    char cpy_r_r1;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL5;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___Op_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 329, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_INCREF(cpy_r_label);
    ((mypyc___ir___ops___GotoObject *)cpy_r_self)->_label = cpy_r_label;
    return 1;
CPyL4: ;
    cpy_r_r1 = 2;
    return cpy_r_r1;
CPyL5: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___Goto_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"label", "line", 0};
    PyObject *obj_label;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O|O", "__init__", kwlist, &obj_label, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Goto))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Goto", obj_self); 
        goto fail;
    }
    PyObject *arg_label;
    if (likely(Py_TYPE(obj_label) == CPyType_ops___BasicBlock))
        arg_label = obj_label;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", obj_label); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Goto_____init__(arg_self, arg_label, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 328, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Goto___targets(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    tuple_T1O cpy_r_r1;
    PyObject *cpy_r_r2;
    cpy_r_r0 = ((mypyc___ir___ops___GotoObject *)cpy_r_self)->_label;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1.f0 = cpy_r_r0;
    CPy_INCREF(cpy_r_r1.f0);
    CPy_DECREF(cpy_r_r0);
    cpy_r_r2 = PyTuple_New(1);
    if (unlikely(cpy_r_r2 == NULL))
        CPyError_OutOfMemory();
    PyObject *__tmp9865 = cpy_r_r1.f0;
    PyTuple_SET_ITEM(cpy_r_r2, 0, __tmp9865);
    return cpy_r_r2;
}

PyObject *CPyPy_ops___Goto___targets(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":targets", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Goto))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Goto", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Goto___targets(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "targets", 332, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Goto___set_target(PyObject *cpy_r_self, CPyTagged cpy_r_i, PyObject *cpy_r_new) {
    int64_t cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    char cpy_r_r6;
    char cpy_r_r7;
    cpy_r_r0 = cpy_r_i & 1;
    cpy_r_r1 = cpy_r_r0 == 0;
    if (!cpy_r_r1) goto CPyL2;
    cpy_r_r2 = cpy_r_i == 0;
    cpy_r_r3 = cpy_r_r2;
    goto CPyL3;
CPyL2: ;
    cpy_r_r4 = CPyTagged_IsEq_(cpy_r_i, 0);
    cpy_r_r3 = cpy_r_r4;
CPyL3: ;
    if (cpy_r_r3) goto CPyL6;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r5 = 0;
    if (unlikely(!cpy_r_r5)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "set_target", 336, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_Unreachable();
CPyL6: ;
    CPy_INCREF(cpy_r_new);
    CPy_DECREF(((mypyc___ir___ops___GotoObject *)cpy_r_self)->_label);
    ((mypyc___ir___ops___GotoObject *)cpy_r_self)->_label = cpy_r_new;
    return 1;
CPyL7: ;
    cpy_r_r7 = 2;
    return cpy_r_r7;
}

PyObject *CPyPy_ops___Goto___set_target(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"i", "new", 0};
    static CPyArg_Parser parser = {"OO:set_target", kwlist, 0};
    PyObject *obj_i;
    PyObject *obj_new;
    if (!CPyArg_ParseStackAndKeywordsSimple(args, nargs, kwnames, &parser, &obj_i, &obj_new)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Goto))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Goto", obj_self); 
        goto fail;
    }
    CPyTagged arg_i;
    if (likely(PyLong_Check(obj_i)))
        arg_i = CPyTagged_BorrowFromObject(obj_i);
    else {
        CPy_TypeError("int", obj_i); goto fail;
    }
    PyObject *arg_new;
    if (likely(Py_TYPE(obj_new) == CPyType_ops___BasicBlock))
        arg_new = obj_new;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", obj_new); 
        goto fail;
    }
    char retval = CPyDef_ops___Goto___set_target(arg_self, arg_i, arg_new);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "set_target", 335, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Goto_____repr__(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    CPyTagged cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___GotoObject *)cpy_r_self)->_label;
    cpy_r_r1 = ((mypyc___ir___ops___BasicBlockObject *)cpy_r_r0)->_label;
    CPyTagged_INCREF(cpy_r_r1);
    cpy_r_r2 = CPyTagged_Str(cpy_r_r1);
    CPyTagged_DECREF(cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 340, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r3 = CPyStatics[7807]; /* '<Goto ' */
    cpy_r_r4 = CPyStatics[840]; /* '>' */
    cpy_r_r5 = CPyStr_Build(3, cpy_r_r3, cpy_r_r2, cpy_r_r4);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(cpy_r_r5 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 340, CPyStatic_ops___globals);
        goto CPyL3;
    }
    return cpy_r_r5;
CPyL3: ;
    cpy_r_r6 = NULL;
    return cpy_r_r6;
}

PyObject *CPyPy_ops___Goto_____repr__(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__repr__", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Goto))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Goto", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Goto_____repr__(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 339, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Goto___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 343, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Goto___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Goto))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Goto", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Goto___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 342, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Goto___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 0, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_goto */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 346, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Goto___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Goto))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Goto", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Goto___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 345, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Goto_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___GotoObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___GotoObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___GotoObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___GotoObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___Goto_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Goto))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Goto", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Goto_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Branch_____init__(PyObject *cpy_r_self, PyObject *cpy_r_value, PyObject *cpy_r_true_label, PyObject *cpy_r_false_label, CPyTagged cpy_r_op, CPyTagged cpy_r_line, char cpy_r_rare) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL7;
    cpy_r_line = -2;
CPyL2: ;
    if (cpy_r_rare != 2) goto CPyL4;
    cpy_r_rare = 0;
CPyL4: ;
    cpy_r_r0 = CPyDef_ops___Op_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 375, CPyStatic_ops___globals);
        goto CPyL6;
    }
    CPy_INCREF(cpy_r_value);
    ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_value = cpy_r_value;
    CPy_INCREF(cpy_r_true_label);
    ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_true = cpy_r_true_label;
    CPy_INCREF(cpy_r_false_label);
    ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_false = cpy_r_false_label;
    CPyTagged_INCREF(cpy_r_op);
    ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_op = cpy_r_op;
    ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_negated = 0;
    cpy_r_r1 = Py_None;
    CPy_INCREF(cpy_r_r1);
    ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_traceback_entry = cpy_r_r1;
    ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_rare = cpy_r_rare;
    return 1;
CPyL6: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
CPyL7: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___Branch_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"value", "true_label", "false_label", "op", "line", "rare", 0};
    PyObject *obj_value;
    PyObject *obj_true_label;
    PyObject *obj_false_label;
    PyObject *obj_op;
    PyObject *obj_line = NULL;
    PyObject *obj_rare = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOOO|O$O", "__init__", kwlist, &obj_value, &obj_true_label, &obj_false_label, &obj_op, &obj_line, &obj_rare)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Branch))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Branch", obj_self); 
        goto fail;
    }
    PyObject *arg_value;
    if (likely(PyObject_TypeCheck(obj_value, CPyType_ops___Value)))
        arg_value = obj_value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_value); 
        goto fail;
    }
    PyObject *arg_true_label;
    if (likely(Py_TYPE(obj_true_label) == CPyType_ops___BasicBlock))
        arg_true_label = obj_true_label;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", obj_true_label); 
        goto fail;
    }
    PyObject *arg_false_label;
    if (likely(Py_TYPE(obj_false_label) == CPyType_ops___BasicBlock))
        arg_false_label = obj_false_label;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", obj_false_label); 
        goto fail;
    }
    CPyTagged arg_op;
    if (likely(PyLong_Check(obj_op)))
        arg_op = CPyTagged_BorrowFromObject(obj_op);
    else {
        CPy_TypeError("int", obj_op); goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char arg_rare;
    if (obj_rare == NULL) {
        arg_rare = 2;
    } else if (unlikely(!PyBool_Check(obj_rare))) {
        CPy_TypeError("bool", obj_rare); goto fail;
    } else
        arg_rare = obj_rare == Py_True;
    char retval = CPyDef_ops___Branch_____init__(arg_self, arg_value, arg_true_label, arg_false_label, arg_op, arg_line, arg_rare);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 365, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Branch___targets(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    tuple_T2OO cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_true;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_false;
    CPy_INCREF(cpy_r_r1);
    cpy_r_r2.f0 = cpy_r_r0;
    cpy_r_r2.f1 = cpy_r_r1;
    CPy_INCREF(cpy_r_r2.f0);
    CPy_INCREF(cpy_r_r2.f1);
    CPy_DECREF(cpy_r_r0);
    CPy_DECREF(cpy_r_r1);
    cpy_r_r3 = PyTuple_New(2);
    if (unlikely(cpy_r_r3 == NULL))
        CPyError_OutOfMemory();
    PyObject *__tmp9866 = cpy_r_r2.f0;
    PyTuple_SET_ITEM(cpy_r_r3, 0, __tmp9866);
    PyObject *__tmp9867 = cpy_r_r2.f1;
    PyTuple_SET_ITEM(cpy_r_r3, 1, __tmp9867);
    return cpy_r_r3;
}

PyObject *CPyPy_ops___Branch___targets(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":targets", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Branch))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Branch", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Branch___targets(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "targets", 392, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Branch___set_target(PyObject *cpy_r_self, CPyTagged cpy_r_i, PyObject *cpy_r_new) {
    int64_t cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    int64_t cpy_r_r6;
    char cpy_r_r7;
    char cpy_r_r8;
    char cpy_r_r9;
    char cpy_r_r10;
    char cpy_r_r11;
    char cpy_r_r12;
    char cpy_r_r13;
    char cpy_r_r14;
    char cpy_r_r15;
    cpy_r_r0 = cpy_r_i & 1;
    cpy_r_r1 = cpy_r_r0 == 0;
    if (!cpy_r_r1) goto CPyL2;
    cpy_r_r2 = cpy_r_i == 0;
    cpy_r_r3 = cpy_r_r2;
    goto CPyL3;
CPyL2: ;
    cpy_r_r4 = CPyTagged_IsEq_(cpy_r_i, 0);
    cpy_r_r3 = cpy_r_r4;
CPyL3: ;
    if (!cpy_r_r3) goto CPyL5;
    cpy_r_r5 = cpy_r_r3;
    goto CPyL9;
CPyL5: ;
    cpy_r_r6 = cpy_r_i & 1;
    cpy_r_r7 = cpy_r_r6 == 0;
    if (!cpy_r_r7) goto CPyL7;
    cpy_r_r8 = cpy_r_i == 2;
    cpy_r_r9 = cpy_r_r8;
    goto CPyL8;
CPyL7: ;
    cpy_r_r10 = CPyTagged_IsEq_(cpy_r_i, 2);
    cpy_r_r9 = cpy_r_r10;
CPyL8: ;
    cpy_r_r5 = cpy_r_r9;
CPyL9: ;
    if (cpy_r_r5) goto CPyL12;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r11 = 0;
    if (unlikely(!cpy_r_r11)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "set_target", 396, CPyStatic_ops___globals);
        goto CPyL16;
    }
    CPy_Unreachable();
CPyL12: ;
    cpy_r_r12 = cpy_r_i == 0;
    if (!cpy_r_r12) goto CPyL14;
    CPy_INCREF(cpy_r_new);
    CPy_DECREF(((mypyc___ir___ops___BranchObject *)cpy_r_self)->_true);
    ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_true = cpy_r_new;
    goto CPyL15;
CPyL14: ;
    CPy_INCREF(cpy_r_new);
    CPy_DECREF(((mypyc___ir___ops___BranchObject *)cpy_r_self)->_false);
    ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_false = cpy_r_new;
CPyL15: ;
    return 1;
CPyL16: ;
    cpy_r_r15 = 2;
    return cpy_r_r15;
}

PyObject *CPyPy_ops___Branch___set_target(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"i", "new", 0};
    static CPyArg_Parser parser = {"OO:set_target", kwlist, 0};
    PyObject *obj_i;
    PyObject *obj_new;
    if (!CPyArg_ParseStackAndKeywordsSimple(args, nargs, kwnames, &parser, &obj_i, &obj_new)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Branch))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Branch", obj_self); 
        goto fail;
    }
    CPyTagged arg_i;
    if (likely(PyLong_Check(obj_i)))
        arg_i = CPyTagged_BorrowFromObject(obj_i);
    else {
        CPy_TypeError("int", obj_i); goto fail;
    }
    PyObject *arg_new;
    if (likely(Py_TYPE(obj_new) == CPyType_ops___BasicBlock))
        arg_new = obj_new;
    else {
        CPy_TypeError("mypyc.ir.ops.BasicBlock", obj_new); 
        goto fail;
    }
    char retval = CPyDef_ops___Branch___set_target(arg_self, arg_i, arg_new);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "set_target", 395, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Branch___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_value;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 403, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___Branch___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Branch))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Branch", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Branch___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 402, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Branch___invert(PyObject *cpy_r_self) {
    char cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    cpy_r_r0 = ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_negated;
    cpy_r_r1 = cpy_r_r0 ^ 1;
    ((mypyc___ir___ops___BranchObject *)cpy_r_self)->_negated = cpy_r_r1;
    return 1;
}

PyObject *CPyPy_ops___Branch___invert(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":invert", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Branch))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Branch", obj_self); 
        goto fail;
    }
    char retval = CPyDef_ops___Branch___invert(arg_self);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "invert", 405, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Branch___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 1, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_branch */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 409, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Branch___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Branch))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Branch", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Branch___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 408, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Branch_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___BranchObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___BranchObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___BranchObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___BranchObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    ((mypyc___ir___ops___BranchObject *)cpy_r___mypyc_self__)->_BOOL = 200;
    ((mypyc___ir___ops___BranchObject *)cpy_r___mypyc_self__)->_IS_ERROR = 202;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___Branch_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Branch))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Branch", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Branch_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Return_____init__(PyObject *cpy_r_self, PyObject *cpy_r_value, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    char cpy_r_r1;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL5;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___Op_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 418, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_INCREF(cpy_r_value);
    ((mypyc___ir___ops___ReturnObject *)cpy_r_self)->_value = cpy_r_value;
    return 1;
CPyL4: ;
    cpy_r_r1 = 2;
    return cpy_r_r1;
CPyL5: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___Return_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"value", "line", 0};
    PyObject *obj_value;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O|O", "__init__", kwlist, &obj_value, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Return))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Return", obj_self); 
        goto fail;
    }
    PyObject *arg_value;
    if (likely(PyObject_TypeCheck(obj_value, CPyType_ops___Value)))
        arg_value = obj_value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_value); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Return_____init__(arg_self, arg_value, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 417, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Return___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___ReturnObject *)cpy_r_self)->_value;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 422, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___Return___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Return))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Return", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Return___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 421, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Return___stolen(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___ReturnObject *)cpy_r_self)->_value;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 425, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___Return___stolen(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":stolen", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Return))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Return", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Return___stolen(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 424, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Return___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 2, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_return */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 428, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Return___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Return))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Return", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Return___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 427, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Return_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___ReturnObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___ReturnObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___ReturnObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___ReturnObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___Return_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Return))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Return", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Return_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Unreachable_____init__(PyObject *cpy_r_self, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    char cpy_r_r1;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL5;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___Op_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 450, CPyStatic_ops___globals);
        goto CPyL4;
    }
    return 1;
CPyL4: ;
    cpy_r_r1 = 2;
    return cpy_r_r1;
CPyL5: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___Unreachable_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"line", 0};
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "|O", "__init__", kwlist, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Unreachable))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Unreachable", obj_self); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Unreachable_____init__(arg_self, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 449, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Unreachable___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 453, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Unreachable___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Unreachable))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Unreachable", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Unreachable___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 452, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Unreachable___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 3, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_unreachable */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 456, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Unreachable___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Unreachable))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Unreachable", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Unreachable___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 455, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Unreachable_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___UnreachableObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___UnreachableObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___UnreachableObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___UnreachableObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___Unreachable_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Unreachable))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Unreachable", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Unreachable_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___RegisterOp_____init__(PyObject *cpy_r_self, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    CPyTagged cpy_r_r1;
    int64_t cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    char cpy_r_r6;
    char cpy_r_r7;
    char cpy_r_r8;
    char cpy_r_r9;
    cpy_r_r0 = CPyDef_ops___Op_____init__(cpy_r_self, cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 477, CPyStatic_ops___globals);
        goto CPyL8;
    }
    cpy_r_r1 = ((mypyc___ir___ops___RegisterOpObject *)cpy_r_self)->_error_kind;
    cpy_r_r2 = cpy_r_r1 & 1;
    cpy_r_r3 = cpy_r_r2 == 0;
    if (!cpy_r_r3) goto CPyL3;
    cpy_r_r4 = (Py_ssize_t)cpy_r_r1 != -2;
    cpy_r_r5 = cpy_r_r4;
    goto CPyL4;
CPyL3: ;
    cpy_r_r6 = CPyTagged_IsEq_(cpy_r_r1, -2);
    cpy_r_r7 = cpy_r_r6 ^ 1;
    cpy_r_r5 = cpy_r_r7;
CPyL4: ;
    if (cpy_r_r5) goto CPyL7;
    PyErr_SetString(PyExc_AssertionError, "error_kind not defined");
    cpy_r_r8 = 0;
    if (unlikely(!cpy_r_r8)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 478, CPyStatic_ops___globals);
        goto CPyL8;
    }
    CPy_Unreachable();
CPyL7: ;
    return 1;
CPyL8: ;
    cpy_r_r9 = 2;
    return cpy_r_r9;
}

PyObject *CPyPy_ops___RegisterOp_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"line", 0};
    PyObject *obj_line;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O", "__init__", kwlist, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___RegisterOp)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.RegisterOp", obj_self); 
        goto fail;
    }
    CPyTagged arg_line;
    if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___RegisterOp_____init__(arg_self, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 476, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___RegisterOp___can_raise(PyObject *cpy_r_self) {
    CPyTagged cpy_r_r0;
    int64_t cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    char cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___RegisterOpObject *)cpy_r_self)->_error_kind;
    cpy_r_r1 = cpy_r_r0 & 1;
    cpy_r_r2 = cpy_r_r1 == 0;
    if (!cpy_r_r2) goto CPyL2;
    cpy_r_r3 = cpy_r_r0 != 0;
    cpy_r_r4 = cpy_r_r3;
    goto CPyL3;
CPyL2: ;
    cpy_r_r5 = CPyTagged_IsEq_(cpy_r_r0, 0);
    cpy_r_r6 = cpy_r_r5 ^ 1;
    cpy_r_r4 = cpy_r_r6;
CPyL3: ;
    return cpy_r_r4;
}

PyObject *CPyPy_ops___RegisterOp___can_raise(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":can_raise", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___RegisterOp)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.RegisterOp", obj_self); 
        goto fail;
    }
    char retval = CPyDef_ops___RegisterOp___can_raise(arg_self);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "can_raise", 480, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___RegisterOp_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___RegisterOpObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___RegisterOpObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___RegisterOpObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___RegisterOpObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___RegisterOpObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___RegisterOp_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(PyObject_TypeCheck(obj___mypyc_self__, CPyType_ops___RegisterOp)))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.RegisterOp", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___RegisterOp_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___IncRef_____init__(PyObject *cpy_r_self, PyObject *cpy_r_src, CPyTagged cpy_r_line) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL8;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = ((mypyc___ir___ops___ValueObject *)cpy_r_src)->_type;
    cpy_r_r1 = ((mypyc___ir___rtypes___RTypeObject *)cpy_r_r0)->_is_refcounted;
    if (cpy_r_r1) {
        goto CPyL5;
    } else
        goto CPyL9;
CPyL3: ;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r2 = 0;
    if (unlikely(!cpy_r_r2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 490, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_Unreachable();
CPyL5: ;
    cpy_r_r3 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r3 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 491, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___IncRefObject *)cpy_r_self)->_src = cpy_r_src;
    return 1;
CPyL7: ;
    cpy_r_r4 = 2;
    return cpy_r_r4;
CPyL8: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
CPyL9: ;
    CPyTagged_DECREF(cpy_r_line);
    goto CPyL3;
}

PyObject *CPyPy_ops___IncRef_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"src", "line", 0};
    PyObject *obj_src;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O|O", "__init__", kwlist, &obj_src, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___IncRef))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.IncRef", obj_self); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___IncRef_____init__(arg_self, arg_src, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 489, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___IncRef___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___IncRefObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 495, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___IncRef___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___IncRef))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.IncRef", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___IncRef___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 494, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___IncRef___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 14, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_inc_ref */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 498, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___IncRef___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___IncRef))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.IncRef", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___IncRef___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 497, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___IncRef_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___IncRefObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___IncRefObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___IncRefObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___IncRefObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___IncRefObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___IncRefObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___IncRef_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___IncRef))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.IncRef", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___IncRef_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___DecRef_____init__(PyObject *cpy_r_self, PyObject *cpy_r_src, char cpy_r_is_xdec, CPyTagged cpy_r_line) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    if (cpy_r_is_xdec != 2) goto CPyL2;
    cpy_r_is_xdec = 0;
CPyL2: ;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL10;
    cpy_r_line = -2;
CPyL4: ;
    cpy_r_r0 = ((mypyc___ir___ops___ValueObject *)cpy_r_src)->_type;
    cpy_r_r1 = ((mypyc___ir___rtypes___RTypeObject *)cpy_r_r0)->_is_refcounted;
    if (cpy_r_r1) {
        goto CPyL7;
    } else
        goto CPyL11;
CPyL5: ;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r2 = 0;
    if (unlikely(!cpy_r_r2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 511, CPyStatic_ops___globals);
        goto CPyL9;
    }
    CPy_Unreachable();
CPyL7: ;
    cpy_r_r3 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r3 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 512, CPyStatic_ops___globals);
        goto CPyL9;
    }
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___DecRefObject *)cpy_r_self)->_src = cpy_r_src;
    ((mypyc___ir___ops___DecRefObject *)cpy_r_self)->_is_xdec = cpy_r_is_xdec;
    return 1;
CPyL9: ;
    cpy_r_r4 = 2;
    return cpy_r_r4;
CPyL10: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL4;
CPyL11: ;
    CPyTagged_DECREF(cpy_r_line);
    goto CPyL5;
}

PyObject *CPyPy_ops___DecRef_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"src", "is_xdec", "line", 0};
    PyObject *obj_src;
    PyObject *obj_is_xdec = NULL;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O|OO", "__init__", kwlist, &obj_src, &obj_is_xdec, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___DecRef))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.DecRef", obj_self); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    char arg_is_xdec;
    if (obj_is_xdec == NULL) {
        arg_is_xdec = 2;
    } else if (unlikely(!PyBool_Check(obj_is_xdec))) {
        CPy_TypeError("bool", obj_is_xdec); goto fail;
    } else
        arg_is_xdec = obj_is_xdec == Py_True;
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___DecRef_____init__(arg_self, arg_src, arg_is_xdec, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 510, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___DecRef_____repr__(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject **cpy_r_r8;
    PyObject *cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    cpy_r_r0 = CPyStatics[7808]; /* '<{}DecRef {!r}>' */
    cpy_r_r1 = ((mypyc___ir___ops___DecRefObject *)cpy_r_self)->_is_xdec;
    if (!cpy_r_r1) goto CPyL2;
CPyL1: ;
    cpy_r_r2 = CPyStatics[1463]; /* 'X' */
    CPy_INCREF(cpy_r_r2);
    cpy_r_r3 = cpy_r_r2;
    goto CPyL3;
CPyL2: ;
    cpy_r_r4 = CPyStatics[163]; /* '' */
    CPy_INCREF(cpy_r_r4);
    cpy_r_r3 = cpy_r_r4;
CPyL3: ;
    cpy_r_r5 = ((mypyc___ir___ops___DecRefObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r5);
    cpy_r_r6 = CPyStatics[193]; /* 'format' */
    PyObject *cpy_r_r7[3] = {cpy_r_r0, cpy_r_r3, cpy_r_r5};
    cpy_r_r8 = (PyObject **)&cpy_r_r7;
    cpy_r_r9 = PyObject_VectorcallMethod(cpy_r_r6, cpy_r_r8, 9223372036854775811ULL, 0);
    if (unlikely(cpy_r_r9 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 517, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_DECREF(cpy_r_r3);
    CPy_DECREF(cpy_r_r5);
    if (likely(PyUnicode_Check(cpy_r_r9)))
        cpy_r_r10 = cpy_r_r9;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__repr__", 517, CPyStatic_ops___globals, "str", cpy_r_r9);
        goto CPyL6;
    }
    return cpy_r_r10;
CPyL6: ;
    cpy_r_r11 = NULL;
    return cpy_r_r11;
CPyL7: ;
    CPy_DecRef(cpy_r_r3);
    CPy_DecRef(cpy_r_r5);
    goto CPyL6;
}

PyObject *CPyPy_ops___DecRef_____repr__(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__repr__", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___DecRef))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.DecRef", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___DecRef_____repr__(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__repr__", 516, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___DecRef___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___DecRefObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 520, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___DecRef___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___DecRef))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.DecRef", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___DecRef___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 519, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___DecRef___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 15, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_dec_ref */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 523, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___DecRef___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___DecRef))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.DecRef", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___DecRef___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 522, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___DecRef_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___DecRefObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___DecRefObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___DecRefObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___DecRefObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___DecRefObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___DecRefObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___DecRef_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___DecRef))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.DecRef", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___DecRef_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Call_____init__(PyObject *cpy_r_self, PyObject *cpy_r_fn, PyObject *cpy_r_args, CPyTagged cpy_r_line) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    int64_t cpy_r_r3;
    CPyTagged cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    CPyPtr cpy_r_r7;
    int64_t cpy_r_r8;
    CPyTagged cpy_r_r9;
    char cpy_r_r10;
    char cpy_r_r11;
    PyObject *cpy_r_r12;
    PyObject *cpy_r_r13;
    char cpy_r_r14;
    PyObject *cpy_r_r15;
    PyObject *cpy_r_r16;
    PyObject *cpy_r_ret_type;
    char cpy_r_r17;
    char cpy_r_r18;
    char cpy_r_r19;
    char cpy_r_r20;
    char cpy_r_r21;
    CPy_INCREF(cpy_r_fn);
    ((mypyc___ir___ops___CallObject *)cpy_r_self)->_fn = cpy_r_fn;
    cpy_r_r0 = PySequence_List(cpy_r_args);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 534, CPyStatic_ops___globals);
        goto CPyL9;
    }
    ((mypyc___ir___ops___CallObject *)cpy_r_self)->_args = cpy_r_r0;
    cpy_r_r1 = ((mypyc___ir___ops___CallObject *)cpy_r_self)->_args;
    cpy_r_r2 = (CPyPtr)&((PyVarObject *)cpy_r_r1)->ob_size;
    cpy_r_r3 = *(int64_t *)cpy_r_r2;
    cpy_r_r4 = cpy_r_r3 << 1;
    cpy_r_r5 = ((mypyc___ir___func_ir___FuncDeclObject *)cpy_r_fn)->_sig;
    cpy_r_r6 = ((mypyc___ir___func_ir___FuncSignatureObject *)cpy_r_r5)->_args;
    CPy_INCREF(cpy_r_r6);
    cpy_r_r7 = (CPyPtr)&((PyVarObject *)cpy_r_r6)->ob_size;
    cpy_r_r8 = *(int64_t *)cpy_r_r7;
    CPy_DECREF(cpy_r_r6);
    cpy_r_r9 = cpy_r_r8 << 1;
    cpy_r_r10 = cpy_r_r4 == cpy_r_r9;
    if (cpy_r_r10) goto CPyL4;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r11 = 0;
    if (unlikely(!cpy_r_r11)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 535, CPyStatic_ops___globals);
        goto CPyL9;
    }
    CPy_Unreachable();
CPyL4: ;
    cpy_r_r12 = ((mypyc___ir___func_ir___FuncDeclObject *)cpy_r_fn)->_sig;
    cpy_r_r13 = ((mypyc___ir___func_ir___FuncSignatureObject *)cpy_r_r12)->_ret_type;
    CPy_INCREF(cpy_r_r13);
    CPy_DECREF(((mypyc___ir___ops___CallObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___CallObject *)cpy_r_self)->_type = cpy_r_r13;
    cpy_r_r15 = ((mypyc___ir___func_ir___FuncDeclObject *)cpy_r_fn)->_sig;
    cpy_r_r16 = ((mypyc___ir___func_ir___FuncSignatureObject *)cpy_r_r15)->_ret_type;
    CPy_INCREF(cpy_r_r16);
    cpy_r_ret_type = cpy_r_r16;
    cpy_r_r17 = ((mypyc___ir___rtypes___RTypeObject *)cpy_r_ret_type)->_error_overlap;
    CPy_DECREF(cpy_r_ret_type);
    if (cpy_r_r17) goto CPyL6;
CPyL5: ;
    CPyTagged_DECREF(((mypyc___ir___ops___CallObject *)cpy_r_self)->_error_kind);
    ((mypyc___ir___ops___CallObject *)cpy_r_self)->_error_kind = 2;
    goto CPyL7;
CPyL6: ;
    CPyTagged_DECREF(((mypyc___ir___ops___CallObject *)cpy_r_self)->_error_kind);
    ((mypyc___ir___ops___CallObject *)cpy_r_self)->_error_kind = 8;
CPyL7: ;
    cpy_r_r20 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    if (unlikely(cpy_r_r20 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 542, CPyStatic_ops___globals);
        goto CPyL9;
    }
    return 1;
CPyL9: ;
    cpy_r_r21 = 2;
    return cpy_r_r21;
}

PyObject *CPyPy_ops___Call_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"fn", "args", "line", 0};
    PyObject *obj_fn;
    PyObject *obj_args;
    PyObject *obj_line;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO", "__init__", kwlist, &obj_fn, &obj_args, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Call))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Call", obj_self); 
        goto fail;
    }
    PyObject *arg_fn;
    if (likely(Py_TYPE(obj_fn) == CPyType_func_ir___FuncDecl))
        arg_fn = obj_fn;
    else {
        CPy_TypeError("mypyc.ir.func_ir.FuncDecl", obj_fn); 
        goto fail;
    }
    PyObject *arg_args = obj_args;
    CPyTagged arg_line;
    if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Call_____init__(arg_self, arg_fn, arg_args, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 532, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Call___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject **cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    cpy_r_r0 = ((mypyc___ir___ops___CallObject *)cpy_r_self)->_args;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = CPyStatics[362]; /* 'copy' */
    PyObject *cpy_r_r2[1] = {cpy_r_r0};
    cpy_r_r3 = (PyObject **)&cpy_r_r2;
    cpy_r_r4 = PyObject_VectorcallMethod(cpy_r_r1, cpy_r_r3, 9223372036854775809ULL, 0);
    if (unlikely(cpy_r_r4 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 545, CPyStatic_ops___globals);
        goto CPyL5;
    }
    CPy_DECREF(cpy_r_r0);
    if (likely(PyList_Check(cpy_r_r4)))
        cpy_r_r5 = cpy_r_r4;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "sources", 545, CPyStatic_ops___globals, "list", cpy_r_r4);
        goto CPyL4;
    }
    cpy_r_r6 = PySequence_List(cpy_r_r5);
    CPy_DECREF(cpy_r_r5);
    if (unlikely(cpy_r_r6 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 545, CPyStatic_ops___globals);
        goto CPyL4;
    }
    return cpy_r_r6;
CPyL4: ;
    cpy_r_r7 = NULL;
    return cpy_r_r7;
CPyL5: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL4;
}

PyObject *CPyPy_ops___Call___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Call))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Call", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Call___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 544, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Call___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 16, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_call */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 548, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Call___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Call))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Call", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Call___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 547, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Call_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___CallObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___CallObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___CallObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___CallObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___CallObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___Call_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Call))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Call", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Call_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___MethodCall_____init__(PyObject *cpy_r_self, PyObject *cpy_r_obj, PyObject *cpy_r_method, PyObject *cpy_r_args, CPyTagged cpy_r_line) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    PyObject *cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject *cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_method_ir;
    PyObject *cpy_r_r11;
    char cpy_r_r12;
    PyObject *cpy_r_r13;
    PyObject *cpy_r_r14;
    PyObject *cpy_r_r15;
    PyObject *cpy_r_r16;
    PyObject *cpy_r_r17;
    PyObject *cpy_r_r18;
    PyObject *cpy_r_r19;
    PyObject **cpy_r_r21;
    PyObject *cpy_r_r22;
    PyObject *cpy_r_r23;
    PyObject *cpy_r_ret_type;
    char cpy_r_r24;
    char cpy_r_r25;
    char cpy_r_r26;
    char cpy_r_r27;
    char cpy_r_r28;
    char cpy_r_r29;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL19;
    cpy_r_line = -2;
CPyL2: ;
    CPy_INCREF(cpy_r_obj);
    ((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_obj = cpy_r_obj;
    CPy_INCREF(cpy_r_method);
    ((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_method = cpy_r_method;
    CPy_INCREF(cpy_r_args);
    ((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_args = cpy_r_args;
    cpy_r_r0 = ((mypyc___ir___ops___ValueObject *)cpy_r_obj)->_type;
    cpy_r_r1 = (PyObject *)CPyType_rtypes___RInstance;
    cpy_r_r2 = (CPyPtr)&((PyObject *)cpy_r_r0)->ob_type;
    cpy_r_r3 = *(PyObject * *)cpy_r_r2;
    cpy_r_r4 = cpy_r_r3 == cpy_r_r1;
    if (cpy_r_r4) {
        goto CPyL5;
    } else
        goto CPyL20;
CPyL3: ;
    PyErr_SetString(PyExc_AssertionError, "Methods can only be called on instances");
    cpy_r_r5 = 0;
    if (unlikely(!cpy_r_r5)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 558, CPyStatic_ops___globals);
        goto CPyL18;
    }
    CPy_Unreachable();
CPyL5: ;
    cpy_r_r6 = ((mypyc___ir___ops___ValueObject *)cpy_r_obj)->_type;
    CPy_INCREF(cpy_r_r6);
    if (likely(Py_TYPE(cpy_r_r6) == CPyType_rtypes___RInstance))
        cpy_r_r7 = cpy_r_r6;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__init__", 559, CPyStatic_ops___globals, "mypyc.ir.rtypes.RInstance", cpy_r_r6);
        goto CPyL21;
    }
    ((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_receiver_type = cpy_r_r7;
    cpy_r_r8 = ((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_receiver_type;
    cpy_r_r9 = ((mypyc___ir___rtypes___RInstanceObject *)cpy_r_r8)->_class_ir;
    CPy_INCREF(cpy_r_r9);
    cpy_r_r10 = CPyDef_class_ir___ClassIR___method_sig(cpy_r_r9, cpy_r_method);
    CPy_DECREF(cpy_r_r9);
    if (unlikely(cpy_r_r10 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 560, CPyStatic_ops___globals);
        goto CPyL21;
    }
    cpy_r_method_ir = cpy_r_r10;
    cpy_r_r11 = (PyObject *)&_Py_NoneStruct;
    cpy_r_r12 = cpy_r_method_ir != cpy_r_r11;
    if (cpy_r_r12) {
        goto CPyL13;
    } else
        goto CPyL22;
CPyL8: ;
    cpy_r_r13 = ((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_receiver_type;
    cpy_r_r14 = ((mypyc___ir___rtypes___RInstanceObject *)cpy_r_r13)->_name;
    CPy_INCREF(cpy_r_r14);
    cpy_r_r15 = CPyStatics[7809]; /* " doesn't have method " */
    cpy_r_r16 = CPyStr_Build(3, cpy_r_r14, cpy_r_r15, cpy_r_method);
    CPy_DECREF(cpy_r_r14);
    if (unlikely(cpy_r_r16 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 561, CPyStatic_ops___globals);
        goto CPyL18;
    }
    cpy_r_r17 = CPyModule_builtins;
    cpy_r_r18 = CPyStatics[23]; /* 'AssertionError' */
    cpy_r_r19 = CPyObject_GetAttr(cpy_r_r17, cpy_r_r18);
    if (unlikely(cpy_r_r19 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 561, CPyStatic_ops___globals);
        goto CPyL23;
    }
    PyObject *cpy_r_r20[1] = {cpy_r_r16};
    cpy_r_r21 = (PyObject **)&cpy_r_r20;
    cpy_r_r22 = _PyObject_Vectorcall(cpy_r_r19, cpy_r_r21, 1, 0);
    CPy_DECREF(cpy_r_r19);
    if (unlikely(cpy_r_r22 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 561, CPyStatic_ops___globals);
        goto CPyL23;
    }
    CPy_DECREF(cpy_r_r16);
    CPy_Raise(cpy_r_r22);
    CPy_DECREF(cpy_r_r22);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 561, CPyStatic_ops___globals);
        goto CPyL18;
    }
    CPy_Unreachable();
CPyL13: ;
    cpy_r_r23 = ((mypyc___ir___func_ir___FuncSignatureObject *)cpy_r_method_ir)->_ret_type;
    CPy_INCREF(cpy_r_r23);
    CPy_DECREF(cpy_r_method_ir);
    cpy_r_ret_type = cpy_r_r23;
    CPy_INCREF(cpy_r_ret_type);
    CPy_DECREF(((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_type = cpy_r_ret_type;
    cpy_r_r25 = ((mypyc___ir___rtypes___RTypeObject *)cpy_r_ret_type)->_error_overlap;
    CPy_DECREF(cpy_r_ret_type);
    if (cpy_r_r25) goto CPyL15;
CPyL14: ;
    CPyTagged_DECREF(((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_error_kind);
    ((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_error_kind = 2;
    goto CPyL16;
CPyL15: ;
    CPyTagged_DECREF(((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_error_kind);
    ((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_error_kind = 8;
CPyL16: ;
    cpy_r_r28 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r28 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 570, CPyStatic_ops___globals);
        goto CPyL18;
    }
    return 1;
CPyL18: ;
    cpy_r_r29 = 2;
    return cpy_r_r29;
CPyL19: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
CPyL20: ;
    CPyTagged_DECREF(cpy_r_line);
    goto CPyL3;
CPyL21: ;
    CPyTagged_DecRef(cpy_r_line);
    goto CPyL18;
CPyL22: ;
    CPyTagged_DECREF(cpy_r_line);
    CPy_DECREF(cpy_r_method_ir);
    goto CPyL8;
CPyL23: ;
    CPy_DecRef(cpy_r_r16);
    goto CPyL18;
}

PyObject *CPyPy_ops___MethodCall_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"obj", "method", "args", "line", 0};
    PyObject *obj_obj;
    PyObject *obj_method;
    PyObject *obj_args;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO|O", "__init__", kwlist, &obj_obj, &obj_method, &obj_args, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___MethodCall))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.MethodCall", obj_self); 
        goto fail;
    }
    PyObject *arg_obj;
    if (likely(PyObject_TypeCheck(obj_obj, CPyType_ops___Value)))
        arg_obj = obj_obj;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_obj); 
        goto fail;
    }
    PyObject *arg_method;
    if (likely(PyUnicode_Check(obj_method)))
        arg_method = obj_method;
    else {
        CPy_TypeError("str", obj_method); 
        goto fail;
    }
    PyObject *arg_args;
    if (likely(PyList_Check(obj_args)))
        arg_args = obj_args;
    else {
        CPy_TypeError("list", obj_args); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___MethodCall_____init__(arg_self, arg_obj, arg_method, arg_args, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 554, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___MethodCall___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject **cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    CPyPtr cpy_r_r8;
    CPyPtr cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    PyObject *cpy_r_r12;
    cpy_r_r0 = ((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_args;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = CPyStatics[362]; /* 'copy' */
    PyObject *cpy_r_r2[1] = {cpy_r_r0};
    cpy_r_r3 = (PyObject **)&cpy_r_r2;
    cpy_r_r4 = PyObject_VectorcallMethod(cpy_r_r1, cpy_r_r3, 9223372036854775809ULL, 0);
    if (unlikely(cpy_r_r4 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 573, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_DECREF(cpy_r_r0);
    if (likely(PyList_Check(cpy_r_r4)))
        cpy_r_r5 = cpy_r_r4;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "sources", 573, CPyStatic_ops___globals, "list", cpy_r_r4);
        goto CPyL6;
    }
    cpy_r_r6 = ((mypyc___ir___ops___MethodCallObject *)cpy_r_self)->_obj;
    CPy_INCREF(cpy_r_r6);
    cpy_r_r7 = PyList_New(1);
    if (unlikely(cpy_r_r7 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 573, CPyStatic_ops___globals);
        goto CPyL8;
    }
    cpy_r_r8 = (CPyPtr)&((PyListObject *)cpy_r_r7)->ob_item;
    cpy_r_r9 = *(CPyPtr *)cpy_r_r8;
    *(PyObject * *)cpy_r_r9 = cpy_r_r6;
    cpy_r_r10 = PyNumber_Add(cpy_r_r5, cpy_r_r7);
    CPy_DECREF(cpy_r_r5);
    CPy_DECREF(cpy_r_r7);
    if (unlikely(cpy_r_r10 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 573, CPyStatic_ops___globals);
        goto CPyL6;
    }
    if (likely(PyList_Check(cpy_r_r10)))
        cpy_r_r11 = cpy_r_r10;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "sources", 573, CPyStatic_ops___globals, "list", cpy_r_r10);
        goto CPyL6;
    }
    return cpy_r_r11;
CPyL6: ;
    cpy_r_r12 = NULL;
    return cpy_r_r12;
CPyL7: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL6;
CPyL8: ;
    CPy_DecRef(cpy_r_r5);
    CPy_DecRef(cpy_r_r6);
    goto CPyL6;
}

PyObject *CPyPy_ops___MethodCall___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___MethodCall))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.MethodCall", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___MethodCall___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 572, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___MethodCall___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 17, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_method_call */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 576, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___MethodCall___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___MethodCall))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.MethodCall", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___MethodCall___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 575, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___MethodCall_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___MethodCallObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___MethodCallObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___MethodCallObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___MethodCallObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___MethodCallObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___MethodCall_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___MethodCall))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.MethodCall", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___MethodCall_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadErrorValue_____init__(PyObject *cpy_r_self, PyObject *cpy_r_rtype, CPyTagged cpy_r_line, char cpy_r_is_borrowed, char cpy_r_undefines) {
    char cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL9;
    cpy_r_line = -2;
CPyL2: ;
    if (cpy_r_is_borrowed != 2) goto CPyL4;
    cpy_r_is_borrowed = 0;
CPyL4: ;
    if (cpy_r_undefines != 2) goto CPyL6;
    cpy_r_undefines = 0;
CPyL6: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 591, CPyStatic_ops___globals);
        goto CPyL8;
    }
    CPy_INCREF(cpy_r_rtype);
    CPy_DECREF(((mypyc___ir___ops___LoadErrorValueObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___LoadErrorValueObject *)cpy_r_self)->_type = cpy_r_rtype;
    ((mypyc___ir___ops___LoadErrorValueObject *)cpy_r_self)->_is_borrowed = cpy_r_is_borrowed;
    ((mypyc___ir___ops___LoadErrorValueObject *)cpy_r_self)->_undefines = cpy_r_undefines;
    return 1;
CPyL8: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
CPyL9: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___LoadErrorValue_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"rtype", "line", "is_borrowed", "undefines", 0};
    PyObject *obj_rtype;
    PyObject *obj_line = NULL;
    PyObject *obj_is_borrowed = NULL;
    PyObject *obj_undefines = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O|OOO", "__init__", kwlist, &obj_rtype, &obj_line, &obj_is_borrowed, &obj_undefines)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadErrorValue))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadErrorValue", obj_self); 
        goto fail;
    }
    PyObject *arg_rtype;
    if (likely(PyObject_TypeCheck(obj_rtype, CPyType_rtypes___RType)))
        arg_rtype = obj_rtype;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_rtype); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char arg_is_borrowed;
    if (obj_is_borrowed == NULL) {
        arg_is_borrowed = 2;
    } else if (unlikely(!PyBool_Check(obj_is_borrowed))) {
        CPy_TypeError("bool", obj_is_borrowed); goto fail;
    } else
        arg_is_borrowed = obj_is_borrowed == Py_True;
    char arg_undefines;
    if (obj_undefines == NULL) {
        arg_undefines = 2;
    } else if (unlikely(!PyBool_Check(obj_undefines))) {
        CPy_TypeError("bool", obj_undefines); goto fail;
    } else
        arg_undefines = obj_undefines == Py_True;
    char retval = CPyDef_ops___LoadErrorValue_____init__(arg_self, arg_rtype, arg_line, arg_is_borrowed, arg_undefines);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 588, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadErrorValue___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 600, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___LoadErrorValue___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadErrorValue))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadErrorValue", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadErrorValue___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 599, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadErrorValue___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 6, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_load_error_value */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 603, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___LoadErrorValue___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadErrorValue))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadErrorValue", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadErrorValue___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 602, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadErrorValue_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___LoadErrorValueObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___LoadErrorValueObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___LoadErrorValueObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___LoadErrorValueObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___LoadErrorValueObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___LoadErrorValueObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___LoadErrorValue_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___LoadErrorValue))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadErrorValue", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___LoadErrorValue_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadLiteral_____init__(PyObject *cpy_r_self, PyObject *cpy_r_value, PyObject *cpy_r_rtype) {
    char cpy_r_r0;
    CPy_INCREF(cpy_r_value);
    ((mypyc___ir___ops___LoadLiteralObject *)cpy_r_self)->_value = cpy_r_value;
    CPy_INCREF(cpy_r_rtype);
    CPy_DECREF(((mypyc___ir___ops___LoadLiteralObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___LoadLiteralObject *)cpy_r_self)->_type = cpy_r_rtype;
    return 1;
}

PyObject *CPyPy_ops___LoadLiteral_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"value", "rtype", 0};
    PyObject *obj_value;
    PyObject *obj_rtype;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OO", "__init__", kwlist, &obj_value, &obj_rtype)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadLiteral))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadLiteral", obj_self); 
        goto fail;
    }
    PyObject *arg_value;
    if (PyUnicode_Check(obj_value))
        arg_value = obj_value;
    else {
        arg_value = NULL;
    }
    if (arg_value != NULL) goto __LL9868;
    if (PyBytes_Check(obj_value) || PyByteArray_Check(obj_value))
        arg_value = obj_value;
    else {
        arg_value = NULL;
    }
    if (arg_value != NULL) goto __LL9868;
    if (PyLong_Check(obj_value))
        arg_value = obj_value;
    else {
        arg_value = NULL;
    }
    if (arg_value != NULL) goto __LL9868;
    if (PyBool_Check(obj_value))
        arg_value = obj_value;
    else {
        arg_value = NULL;
    }
    if (arg_value != NULL) goto __LL9868;
    if (CPyFloat_Check(obj_value))
        arg_value = obj_value;
    else {
        arg_value = NULL;
    }
    if (arg_value != NULL) goto __LL9868;
    arg_value = obj_value;
    if (arg_value != NULL) goto __LL9868;
    if (PyTuple_Check(obj_value))
        arg_value = obj_value;
    else {
        arg_value = NULL;
    }
    if (arg_value != NULL) goto __LL9868;
    if (obj_value == Py_None)
        arg_value = obj_value;
    else {
        arg_value = NULL;
    }
    if (arg_value != NULL) goto __LL9868;
    CPy_TypeError("union[str, bytes, int, bool, float, object, tuple, None]", obj_value); 
    goto fail;
__LL9868: ;
    PyObject *arg_rtype;
    if (likely(PyObject_TypeCheck(obj_rtype, CPyType_rtypes___RType)))
        arg_rtype = obj_rtype;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_rtype); 
        goto fail;
    }
    char retval = CPyDef_ops___LoadLiteral_____init__(arg_self, arg_value, arg_rtype);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 627, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadLiteral___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 632, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___LoadLiteral___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadLiteral))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadLiteral", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadLiteral___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 631, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadLiteral___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 7, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_load_literal */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 635, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___LoadLiteral___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadLiteral))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadLiteral", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadLiteral___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 634, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadLiteral_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___LoadLiteralObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___LoadLiteralObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___LoadLiteralObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___LoadLiteralObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___LoadLiteralObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___LoadLiteralObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    ((mypyc___ir___ops___LoadLiteralObject *)cpy_r___mypyc_self__)->_is_borrowed = 1;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___LoadLiteral_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___LoadLiteral))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadLiteral", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___LoadLiteral_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___GetAttr_____init__(PyObject *cpy_r_self, PyObject *cpy_r_obj, PyObject *cpy_r_attr, CPyTagged cpy_r_line, char cpy_r_borrow) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    char cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject *cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    PyObject *cpy_r_r12;
    PyObject **cpy_r_r14;
    PyObject *cpy_r_r15;
    PyObject *cpy_r_r16;
    PyObject *cpy_r_r17;
    PyObject *cpy_r_r18;
    PyObject *cpy_r_r19;
    PyObject *cpy_r_r20;
    PyObject *cpy_r_attr_type;
    char cpy_r_r21;
    char cpy_r_r22;
    char cpy_r_r23;
    char cpy_r_r24;
    char cpy_r_r25;
    char cpy_r_r26;
    char cpy_r_r27;
    if (cpy_r_borrow != 2) goto CPyL2;
    cpy_r_borrow = 0;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 644, CPyStatic_ops___globals);
        goto CPyL19;
    }
    CPy_INCREF(cpy_r_obj);
    ((mypyc___ir___ops___GetAttrObject *)cpy_r_self)->_obj = cpy_r_obj;
    CPy_INCREF(cpy_r_attr);
    ((mypyc___ir___ops___GetAttrObject *)cpy_r_self)->_attr = cpy_r_attr;
    cpy_r_r1 = ((mypyc___ir___ops___ValueObject *)cpy_r_obj)->_type;
    cpy_r_r2 = (PyObject *)CPyType_rtypes___RInstance;
    cpy_r_r3 = (CPyPtr)&((PyObject *)cpy_r_r1)->ob_type;
    cpy_r_r4 = *(PyObject * *)cpy_r_r3;
    cpy_r_r5 = cpy_r_r4 == cpy_r_r2;
    if (cpy_r_r5) goto CPyL10;
    cpy_r_r6 = ((mypyc___ir___ops___ValueObject *)cpy_r_obj)->_type;
    CPy_INCREF(cpy_r_r6);
    cpy_r_r7 = PyObject_Str(cpy_r_r6);
    CPy_DECREF(cpy_r_r6);
    if (unlikely(cpy_r_r7 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 647, CPyStatic_ops___globals);
        goto CPyL19;
    }
    cpy_r_r8 = CPyStatics[7810]; /* 'Attribute access not supported: ' */
    cpy_r_r9 = CPyStr_Build(2, cpy_r_r8, cpy_r_r7);
    CPy_DECREF(cpy_r_r7);
    if (unlikely(cpy_r_r9 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 647, CPyStatic_ops___globals);
        goto CPyL19;
    }
    cpy_r_r10 = CPyModule_builtins;
    cpy_r_r11 = CPyStatics[23]; /* 'AssertionError' */
    cpy_r_r12 = CPyObject_GetAttr(cpy_r_r10, cpy_r_r11);
    if (unlikely(cpy_r_r12 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 647, CPyStatic_ops___globals);
        goto CPyL20;
    }
    PyObject *cpy_r_r13[1] = {cpy_r_r9};
    cpy_r_r14 = (PyObject **)&cpy_r_r13;
    cpy_r_r15 = _PyObject_Vectorcall(cpy_r_r12, cpy_r_r14, 1, 0);
    CPy_DECREF(cpy_r_r12);
    if (unlikely(cpy_r_r15 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 647, CPyStatic_ops___globals);
        goto CPyL20;
    }
    CPy_DECREF(cpy_r_r9);
    CPy_Raise(cpy_r_r15);
    CPy_DECREF(cpy_r_r15);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 647, CPyStatic_ops___globals);
        goto CPyL19;
    }
    CPy_Unreachable();
CPyL10: ;
    cpy_r_r16 = ((mypyc___ir___ops___ValueObject *)cpy_r_obj)->_type;
    CPy_INCREF(cpy_r_r16);
    if (likely(Py_TYPE(cpy_r_r16) == CPyType_rtypes___RInstance))
        cpy_r_r17 = cpy_r_r16;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__init__", 648, CPyStatic_ops___globals, "mypyc.ir.rtypes.RInstance", cpy_r_r16);
        goto CPyL19;
    }
    ((mypyc___ir___ops___GetAttrObject *)cpy_r_self)->_class_type = cpy_r_r17;
    cpy_r_r18 = ((mypyc___ir___ops___ValueObject *)cpy_r_obj)->_type;
    CPy_INCREF(cpy_r_r18);
    if (likely(Py_TYPE(cpy_r_r18) == CPyType_rtypes___RInstance))
        cpy_r_r19 = cpy_r_r18;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__init__", 649, CPyStatic_ops___globals, "mypyc.ir.rtypes.RInstance", cpy_r_r18);
        goto CPyL19;
    }
    cpy_r_r20 = CPyDef_rtypes___RInstance___attr_type(cpy_r_r19, cpy_r_attr);
    CPy_DECREF(cpy_r_r19);
    if (unlikely(cpy_r_r20 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 649, CPyStatic_ops___globals);
        goto CPyL19;
    }
    cpy_r_attr_type = cpy_r_r20;
    CPy_INCREF(cpy_r_attr_type);
    CPy_DECREF(((mypyc___ir___ops___GetAttrObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___GetAttrObject *)cpy_r_self)->_type = cpy_r_attr_type;
    cpy_r_r22 = ((mypyc___ir___rtypes___RTypeObject *)cpy_r_attr_type)->_error_overlap;
    if (!cpy_r_r22) goto CPyL15;
CPyL14: ;
    CPyTagged_DECREF(((mypyc___ir___ops___GetAttrObject *)cpy_r_self)->_error_kind);
    ((mypyc___ir___ops___GetAttrObject *)cpy_r_self)->_error_kind = 8;
CPyL15: ;
    if (cpy_r_borrow) {
        goto CPyL17;
    } else
        goto CPyL21;
CPyL16: ;
    cpy_r_r24 = cpy_r_borrow;
    goto CPyL18;
CPyL17: ;
    cpy_r_r25 = ((mypyc___ir___rtypes___RTypeObject *)cpy_r_attr_type)->_is_refcounted;
    CPy_DECREF(cpy_r_attr_type);
    cpy_r_r24 = cpy_r_r25;
CPyL18: ;
    ((mypyc___ir___ops___GetAttrObject *)cpy_r_self)->_is_borrowed = cpy_r_r24;
    return 1;
CPyL19: ;
    cpy_r_r27 = 2;
    return cpy_r_r27;
CPyL20: ;
    CPy_DecRef(cpy_r_r9);
    goto CPyL19;
CPyL21: ;
    CPy_DECREF(cpy_r_attr_type);
    goto CPyL16;
}

PyObject *CPyPy_ops___GetAttr_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"obj", "attr", "line", "borrow", 0};
    PyObject *obj_obj;
    PyObject *obj_attr;
    PyObject *obj_line;
    PyObject *obj_borrow = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO|$O", "__init__", kwlist, &obj_obj, &obj_attr, &obj_line, &obj_borrow)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___GetAttr))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.GetAttr", obj_self); 
        goto fail;
    }
    PyObject *arg_obj;
    if (likely(PyObject_TypeCheck(obj_obj, CPyType_ops___Value)))
        arg_obj = obj_obj;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_obj); 
        goto fail;
    }
    PyObject *arg_attr;
    if (likely(PyUnicode_Check(obj_attr)))
        arg_attr = obj_attr;
    else {
        CPy_TypeError("str", obj_attr); 
        goto fail;
    }
    CPyTagged arg_line;
    if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char arg_borrow;
    if (obj_borrow == NULL) {
        arg_borrow = 2;
    } else if (unlikely(!PyBool_Check(obj_borrow))) {
        CPy_TypeError("bool", obj_borrow); goto fail;
    } else
        arg_borrow = obj_borrow == Py_True;
    char retval = CPyDef_ops___GetAttr_____init__(arg_self, arg_obj, arg_attr, arg_line, arg_borrow);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 643, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___GetAttr___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___GetAttrObject *)cpy_r_self)->_obj;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 656, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___GetAttr___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___GetAttr))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.GetAttr", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___GetAttr___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 655, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___GetAttr___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 8, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_get_attr */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 659, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___GetAttr___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___GetAttr))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.GetAttr", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___GetAttr___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 658, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___GetAttr_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___GetAttrObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___GetAttrObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___GetAttrObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___GetAttrObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___GetAttrObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___GetAttrObject *)cpy_r___mypyc_self__)->_error_kind = 2;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___GetAttr_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___GetAttr))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.GetAttr", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___GetAttr_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___SetAttr_____init__(PyObject *cpy_r_self, PyObject *cpy_r_obj, PyObject *cpy_r_attr, PyObject *cpy_r_src, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    char cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject *cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    PyObject *cpy_r_r12;
    PyObject **cpy_r_r14;
    PyObject *cpy_r_r15;
    PyObject *cpy_r_r16;
    PyObject *cpy_r_r17;
    PyObject *cpy_r_r18;
    char cpy_r_r19;
    char cpy_r_r20;
    char cpy_r_r21;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 671, CPyStatic_ops___globals);
        goto CPyL13;
    }
    CPy_INCREF(cpy_r_obj);
    ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_obj = cpy_r_obj;
    CPy_INCREF(cpy_r_attr);
    ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_attr = cpy_r_attr;
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_src = cpy_r_src;
    cpy_r_r1 = ((mypyc___ir___ops___ValueObject *)cpy_r_obj)->_type;
    cpy_r_r2 = (PyObject *)CPyType_rtypes___RInstance;
    cpy_r_r3 = (CPyPtr)&((PyObject *)cpy_r_r1)->ob_type;
    cpy_r_r4 = *(PyObject * *)cpy_r_r3;
    cpy_r_r5 = cpy_r_r4 == cpy_r_r2;
    if (cpy_r_r5) goto CPyL8;
    cpy_r_r6 = ((mypyc___ir___ops___ValueObject *)cpy_r_obj)->_type;
    CPy_INCREF(cpy_r_r6);
    cpy_r_r7 = PyObject_Str(cpy_r_r6);
    CPy_DECREF(cpy_r_r6);
    if (unlikely(cpy_r_r7 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 675, CPyStatic_ops___globals);
        goto CPyL13;
    }
    cpy_r_r8 = CPyStatics[7810]; /* 'Attribute access not supported: ' */
    cpy_r_r9 = CPyStr_Build(2, cpy_r_r8, cpy_r_r7);
    CPy_DECREF(cpy_r_r7);
    if (unlikely(cpy_r_r9 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 675, CPyStatic_ops___globals);
        goto CPyL13;
    }
    cpy_r_r10 = CPyModule_builtins;
    cpy_r_r11 = CPyStatics[23]; /* 'AssertionError' */
    cpy_r_r12 = CPyObject_GetAttr(cpy_r_r10, cpy_r_r11);
    if (unlikely(cpy_r_r12 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 675, CPyStatic_ops___globals);
        goto CPyL14;
    }
    PyObject *cpy_r_r13[1] = {cpy_r_r9};
    cpy_r_r14 = (PyObject **)&cpy_r_r13;
    cpy_r_r15 = _PyObject_Vectorcall(cpy_r_r12, cpy_r_r14, 1, 0);
    CPy_DECREF(cpy_r_r12);
    if (unlikely(cpy_r_r15 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 675, CPyStatic_ops___globals);
        goto CPyL14;
    }
    CPy_DECREF(cpy_r_r9);
    CPy_Raise(cpy_r_r15);
    CPy_DECREF(cpy_r_r15);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 675, CPyStatic_ops___globals);
        goto CPyL13;
    }
    CPy_Unreachable();
CPyL8: ;
    cpy_r_r16 = ((mypyc___ir___ops___ValueObject *)cpy_r_obj)->_type;
    CPy_INCREF(cpy_r_r16);
    if (likely(Py_TYPE(cpy_r_r16) == CPyType_rtypes___RInstance))
        cpy_r_r17 = cpy_r_r16;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__init__", 676, CPyStatic_ops___globals, "mypyc.ir.rtypes.RInstance", cpy_r_r16);
        goto CPyL13;
    }
    ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_class_type = cpy_r_r17;
    cpy_r_r18 = CPyStatic_rtypes___bool_rprimitive;
    if (likely(cpy_r_r18 != NULL)) goto CPyL12;
    PyErr_SetString(PyExc_NameError, "value for final name \"bool_rprimitive\" was not set");
    cpy_r_r19 = 0;
    if (unlikely(!cpy_r_r19)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 677, CPyStatic_ops___globals);
        goto CPyL13;
    }
    CPy_Unreachable();
CPyL12: ;
    CPy_INCREF(cpy_r_r18);
    CPy_DECREF(((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_type = cpy_r_r18;
    ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_is_init = 0;
    return 1;
CPyL13: ;
    cpy_r_r21 = 2;
    return cpy_r_r21;
CPyL14: ;
    CPy_DecRef(cpy_r_r9);
    goto CPyL13;
}

PyObject *CPyPy_ops___SetAttr_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"obj", "attr", "src", "line", 0};
    PyObject *obj_obj;
    PyObject *obj_attr;
    PyObject *obj_src;
    PyObject *obj_line;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOOO", "__init__", kwlist, &obj_obj, &obj_attr, &obj_src, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___SetAttr))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.SetAttr", obj_self); 
        goto fail;
    }
    PyObject *arg_obj;
    if (likely(PyObject_TypeCheck(obj_obj, CPyType_ops___Value)))
        arg_obj = obj_obj;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_obj); 
        goto fail;
    }
    PyObject *arg_attr;
    if (likely(PyUnicode_Check(obj_attr)))
        arg_attr = obj_attr;
    else {
        CPy_TypeError("str", obj_attr); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    CPyTagged arg_line;
    if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___SetAttr_____init__(arg_self, arg_obj, arg_attr, arg_src, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 670, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___SetAttr___mark_as_initializer(PyObject *cpy_r_self) {
    char cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_is_init = 1;
    CPyTagged_DECREF(((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_error_kind);
    ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_error_kind = 0;
    cpy_r_r2 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r2 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r3 = 0;
    if (unlikely(!cpy_r_r3)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "mark_as_initializer", 685, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r2);
    CPy_DECREF(((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_type = cpy_r_r2;
    return 1;
CPyL4: ;
    cpy_r_r5 = 2;
    return cpy_r_r5;
}

PyObject *CPyPy_ops___SetAttr___mark_as_initializer(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":mark_as_initializer", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___SetAttr))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.SetAttr", obj_self); 
        goto fail;
    }
    char retval = CPyDef_ops___SetAttr___mark_as_initializer(arg_self);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "mark_as_initializer", 682, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___SetAttr___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    CPyPtr cpy_r_r3;
    CPyPtr cpy_r_r4;
    CPyPtr cpy_r_r5;
    PyObject *cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_obj;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r1);
    cpy_r_r2 = PyList_New(2);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 688, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r3 = (CPyPtr)&((PyListObject *)cpy_r_r2)->ob_item;
    cpy_r_r4 = *(CPyPtr *)cpy_r_r3;
    *(PyObject * *)cpy_r_r4 = cpy_r_r0;
    cpy_r_r5 = cpy_r_r4 + 8;
    *(PyObject * *)cpy_r_r5 = cpy_r_r1;
    return cpy_r_r2;
CPyL2: ;
    cpy_r_r6 = NULL;
    return cpy_r_r6;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    CPy_DecRef(cpy_r_r1);
    goto CPyL2;
}

PyObject *CPyPy_ops___SetAttr___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___SetAttr))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.SetAttr", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___SetAttr___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 687, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___SetAttr___stolen(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___SetAttrObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 691, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___SetAttr___stolen(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":stolen", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___SetAttr))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.SetAttr", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___SetAttr___stolen(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 690, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___SetAttr___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 9, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_set_attr */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 694, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___SetAttr___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___SetAttr))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.SetAttr", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___SetAttr___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 693, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___SetAttr_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___SetAttrObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___SetAttrObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___SetAttrObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___SetAttrObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___SetAttrObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___SetAttrObject *)cpy_r___mypyc_self__)->_error_kind = 4;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___SetAttr_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___SetAttr))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.SetAttr", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___SetAttr_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadStatic_____init__(PyObject *cpy_r_self, PyObject *cpy_r_type, PyObject *cpy_r_identifier, PyObject *cpy_r_module_name, PyObject *cpy_r_namespace, CPyTagged cpy_r_line, PyObject *cpy_r_ann) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    if (cpy_r_module_name != NULL) goto CPyL11;
    cpy_r_r0 = Py_None;
    CPy_INCREF(cpy_r_r0);
    cpy_r_module_name = cpy_r_r0;
CPyL2: ;
    if (cpy_r_namespace != NULL) goto CPyL12;
    cpy_r_r1 = CPyStatics[7396]; /* 'static' */
    CPy_INCREF(cpy_r_r1);
    cpy_r_namespace = cpy_r_r1;
CPyL4: ;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL13;
    cpy_r_line = -2;
CPyL6: ;
    if (cpy_r_ann != NULL) goto CPyL14;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    cpy_r_ann = cpy_r_r2;
CPyL8: ;
    cpy_r_r3 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r3 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 730, CPyStatic_ops___globals);
        goto CPyL15;
    }
    CPy_INCREF(cpy_r_identifier);
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r_self)->_identifier = cpy_r_identifier;
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r_self)->_module_name = cpy_r_module_name;
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r_self)->_namespace = cpy_r_namespace;
    CPy_INCREF(cpy_r_type);
    CPy_DECREF(((mypyc___ir___ops___LoadStaticObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r_self)->_type = cpy_r_type;
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r_self)->_ann = cpy_r_ann;
    return 1;
CPyL10: ;
    cpy_r_r5 = 2;
    return cpy_r_r5;
CPyL11: ;
    CPy_INCREF(cpy_r_module_name);
    goto CPyL2;
CPyL12: ;
    CPy_INCREF(cpy_r_namespace);
    goto CPyL4;
CPyL13: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL6;
CPyL14: ;
    CPy_INCREF(cpy_r_ann);
    goto CPyL8;
CPyL15: ;
    CPy_DecRef(cpy_r_module_name);
    CPy_DecRef(cpy_r_namespace);
    CPy_DecRef(cpy_r_ann);
    goto CPyL10;
}

PyObject *CPyPy_ops___LoadStatic_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"type", "identifier", "module_name", "namespace", "line", "ann", 0};
    PyObject *obj_type;
    PyObject *obj_identifier;
    PyObject *obj_module_name = NULL;
    PyObject *obj_namespace = NULL;
    PyObject *obj_line = NULL;
    PyObject *obj_ann = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OO|OOOO", "__init__", kwlist, &obj_type, &obj_identifier, &obj_module_name, &obj_namespace, &obj_line, &obj_ann)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadStatic))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadStatic", obj_self); 
        goto fail;
    }
    PyObject *arg_type;
    if (likely(PyObject_TypeCheck(obj_type, CPyType_rtypes___RType)))
        arg_type = obj_type;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_type); 
        goto fail;
    }
    PyObject *arg_identifier;
    if (likely(PyUnicode_Check(obj_identifier)))
        arg_identifier = obj_identifier;
    else {
        CPy_TypeError("str", obj_identifier); 
        goto fail;
    }
    PyObject *arg_module_name;
    if (obj_module_name == NULL) {
        arg_module_name = NULL;
        goto __LL9869;
    }
    if (PyUnicode_Check(obj_module_name))
        arg_module_name = obj_module_name;
    else {
        arg_module_name = NULL;
    }
    if (arg_module_name != NULL) goto __LL9869;
    if (obj_module_name == Py_None)
        arg_module_name = obj_module_name;
    else {
        arg_module_name = NULL;
    }
    if (arg_module_name != NULL) goto __LL9869;
    CPy_TypeError("str or None", obj_module_name); 
    goto fail;
__LL9869: ;
    PyObject *arg_namespace;
    if (obj_namespace == NULL) {
        arg_namespace = NULL;
    } else if (likely(PyUnicode_Check(obj_namespace)))
        arg_namespace = obj_namespace;
    else {
        CPy_TypeError("str", obj_namespace); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    PyObject *arg_ann;
    if (obj_ann == NULL) {
        arg_ann = NULL;
    } else {
        arg_ann = obj_ann; 
    }
    char retval = CPyDef_ops___LoadStatic_____init__(arg_self, arg_type, arg_identifier, arg_module_name, arg_namespace, arg_line, arg_ann);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 721, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadStatic___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 738, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___LoadStatic___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadStatic))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadStatic", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadStatic___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 737, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadStatic___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 10, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_load_static */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 741, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___LoadStatic___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadStatic))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadStatic", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadStatic___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 740, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadStatic_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    ((mypyc___ir___ops___LoadStaticObject *)cpy_r___mypyc_self__)->_is_borrowed = 1;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___LoadStatic_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___LoadStatic))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadStatic", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___LoadStatic_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___InitStatic_____init__(PyObject *cpy_r_self, PyObject *cpy_r_value, PyObject *cpy_r_identifier, PyObject *cpy_r_module_name, PyObject *cpy_r_namespace, CPyTagged cpy_r_line) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    if (cpy_r_module_name != NULL) goto CPyL9;
    cpy_r_r0 = Py_None;
    CPy_INCREF(cpy_r_r0);
    cpy_r_module_name = cpy_r_r0;
CPyL2: ;
    if (cpy_r_namespace != NULL) goto CPyL10;
    cpy_r_r1 = CPyStatics[7396]; /* 'static' */
    CPy_INCREF(cpy_r_r1);
    cpy_r_namespace = cpy_r_r1;
CPyL4: ;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL11;
    cpy_r_line = -2;
CPyL6: ;
    cpy_r_r2 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r2 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 760, CPyStatic_ops___globals);
        goto CPyL12;
    }
    CPy_INCREF(cpy_r_identifier);
    ((mypyc___ir___ops___InitStaticObject *)cpy_r_self)->_identifier = cpy_r_identifier;
    ((mypyc___ir___ops___InitStaticObject *)cpy_r_self)->_module_name = cpy_r_module_name;
    ((mypyc___ir___ops___InitStaticObject *)cpy_r_self)->_namespace = cpy_r_namespace;
    CPy_INCREF(cpy_r_value);
    ((mypyc___ir___ops___InitStaticObject *)cpy_r_self)->_value = cpy_r_value;
    return 1;
CPyL8: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
CPyL9: ;
    CPy_INCREF(cpy_r_module_name);
    goto CPyL2;
CPyL10: ;
    CPy_INCREF(cpy_r_namespace);
    goto CPyL4;
CPyL11: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL6;
CPyL12: ;
    CPy_DecRef(cpy_r_module_name);
    CPy_DecRef(cpy_r_namespace);
    goto CPyL8;
}

PyObject *CPyPy_ops___InitStatic_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"value", "identifier", "module_name", "namespace", "line", 0};
    PyObject *obj_value;
    PyObject *obj_identifier;
    PyObject *obj_module_name = NULL;
    PyObject *obj_namespace = NULL;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OO|OOO", "__init__", kwlist, &obj_value, &obj_identifier, &obj_module_name, &obj_namespace, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___InitStatic))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.InitStatic", obj_self); 
        goto fail;
    }
    PyObject *arg_value;
    if (likely(PyObject_TypeCheck(obj_value, CPyType_ops___Value)))
        arg_value = obj_value;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_value); 
        goto fail;
    }
    PyObject *arg_identifier;
    if (likely(PyUnicode_Check(obj_identifier)))
        arg_identifier = obj_identifier;
    else {
        CPy_TypeError("str", obj_identifier); 
        goto fail;
    }
    PyObject *arg_module_name;
    if (obj_module_name == NULL) {
        arg_module_name = NULL;
        goto __LL9870;
    }
    if (PyUnicode_Check(obj_module_name))
        arg_module_name = obj_module_name;
    else {
        arg_module_name = NULL;
    }
    if (arg_module_name != NULL) goto __LL9870;
    if (obj_module_name == Py_None)
        arg_module_name = obj_module_name;
    else {
        arg_module_name = NULL;
    }
    if (arg_module_name != NULL) goto __LL9870;
    CPy_TypeError("str or None", obj_module_name); 
    goto fail;
__LL9870: ;
    PyObject *arg_namespace;
    if (obj_namespace == NULL) {
        arg_namespace = NULL;
    } else if (likely(PyUnicode_Check(obj_namespace)))
        arg_namespace = obj_namespace;
    else {
        CPy_TypeError("str", obj_namespace); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___InitStatic_____init__(arg_self, arg_value, arg_identifier, arg_module_name, arg_namespace, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 752, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___InitStatic___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___InitStaticObject *)cpy_r_self)->_value;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 767, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___InitStatic___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___InitStatic))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.InitStatic", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___InitStatic___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 766, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___InitStatic___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 11, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_init_static */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 770, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___InitStatic___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___InitStatic))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.InitStatic", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___InitStatic___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 769, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___InitStatic_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___InitStaticObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___InitStaticObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___InitStaticObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___InitStaticObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___InitStaticObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___InitStaticObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___InitStatic_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___InitStatic))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.InitStatic", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___InitStatic_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___TupleSet_____init__(PyObject *cpy_r_self, PyObject *cpy_r_items, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    CPyPtr cpy_r_r1;
    int64_t cpy_r_r2;
    PyObject *cpy_r_r3;
    CPyTagged cpy_r_r4;
    CPyPtr cpy_r_r5;
    int64_t cpy_r_r6;
    CPyTagged cpy_r_r7;
    char cpy_r_r8;
    PyObject *cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_arg;
    PyObject *cpy_r_r11;
    char cpy_r_r12;
    PyObject *cpy_r_r13;
    PyObject *cpy_r_r14;
    PyObject *cpy_r_r15;
    char cpy_r_r16;
    char cpy_r_r17;
    CPyTagged cpy_r_r18;
    PyObject *cpy_r_r19;
    PyObject *cpy_r_r20;
    char cpy_r_r21;
    char cpy_r_r22;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 779, CPyStatic_ops___globals);
        goto CPyL16;
    }
    CPy_INCREF(cpy_r_items);
    ((mypyc___ir___ops___TupleSetObject *)cpy_r_self)->_items = cpy_r_items;
    cpy_r_r1 = (CPyPtr)&((PyVarObject *)cpy_r_items)->ob_size;
    cpy_r_r2 = *(int64_t *)cpy_r_r1;
    cpy_r_r3 = PyList_New(cpy_r_r2);
    if (unlikely(cpy_r_r3 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 785, CPyStatic_ops___globals);
        goto CPyL16;
    }
    cpy_r_r4 = 0;
CPyL3: ;
    cpy_r_r5 = (CPyPtr)&((PyVarObject *)cpy_r_items)->ob_size;
    cpy_r_r6 = *(int64_t *)cpy_r_r5;
    cpy_r_r7 = cpy_r_r6 << 1;
    cpy_r_r8 = (Py_ssize_t)cpy_r_r4 < (Py_ssize_t)cpy_r_r7;
    if (!cpy_r_r8) goto CPyL14;
    cpy_r_r9 = CPyList_GetItemUnsafe(cpy_r_items, cpy_r_r4);
    if (likely(PyObject_TypeCheck(cpy_r_r9, CPyType_ops___Value)))
        cpy_r_r10 = cpy_r_r9;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__init__", 785, CPyStatic_ops___globals, "mypyc.ir.ops.Value", cpy_r_r9);
        goto CPyL17;
    }
    cpy_r_arg = cpy_r_r10;
    cpy_r_r11 = ((mypyc___ir___ops___ValueObject *)cpy_r_arg)->_type;
    CPy_INCREF(cpy_r_r11);
    cpy_r_r12 = CPyDef_rtypes___is_short_int_rprimitive(cpy_r_r11);
    CPy_DECREF(cpy_r_r11);
    if (unlikely(cpy_r_r12 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 786, CPyStatic_ops___globals);
        goto CPyL18;
    }
    if (cpy_r_r12) goto CPyL19;
    cpy_r_r13 = ((mypyc___ir___ops___ValueObject *)cpy_r_arg)->_type;
    CPy_INCREF(cpy_r_r13);
    CPy_DECREF(cpy_r_arg);
    cpy_r_r14 = cpy_r_r13;
    goto CPyL12;
CPyL8: ;
    cpy_r_r15 = CPyStatic_rtypes___int_rprimitive;
    if (unlikely(cpy_r_r15 == NULL)) {
        goto CPyL20;
    } else
        goto CPyL11;
CPyL9: ;
    PyErr_SetString(PyExc_NameError, "value for final name \"int_rprimitive\" was not set");
    cpy_r_r16 = 0;
    if (unlikely(!cpy_r_r16)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 786, CPyStatic_ops___globals);
        goto CPyL16;
    }
    CPy_Unreachable();
CPyL11: ;
    CPy_INCREF(cpy_r_r15);
    cpy_r_r14 = cpy_r_r15;
CPyL12: ;
    cpy_r_r17 = CPyList_SetItemUnsafe(cpy_r_r3, cpy_r_r4, cpy_r_r14);
    if (unlikely(!cpy_r_r17)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 785, CPyStatic_ops___globals);
        goto CPyL17;
    }
    cpy_r_r18 = cpy_r_r4 + 2;
    cpy_r_r4 = cpy_r_r18;
    goto CPyL3;
CPyL14: ;
    cpy_r_r19 = CPyDef_rtypes___RTuple(cpy_r_r3);
    CPy_DECREF(cpy_r_r3);
    if (unlikely(cpy_r_r19 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 784, CPyStatic_ops___globals);
        goto CPyL16;
    }
    ((mypyc___ir___ops___TupleSetObject *)cpy_r_self)->_tuple_type = cpy_r_r19;
    cpy_r_r20 = ((mypyc___ir___ops___TupleSetObject *)cpy_r_self)->_tuple_type;
    CPy_INCREF(cpy_r_r20);
    CPy_DECREF(((mypyc___ir___ops___TupleSetObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___TupleSetObject *)cpy_r_self)->_type = cpy_r_r20;
    return 1;
CPyL16: ;
    cpy_r_r22 = 2;
    return cpy_r_r22;
CPyL17: ;
    CPy_DecRef(cpy_r_r3);
    goto CPyL16;
CPyL18: ;
    CPy_DecRef(cpy_r_r3);
    CPy_DecRef(cpy_r_arg);
    goto CPyL16;
CPyL19: ;
    CPy_DECREF(cpy_r_arg);
    goto CPyL8;
CPyL20: ;
    CPy_DecRef(cpy_r_r3);
    goto CPyL9;
}

PyObject *CPyPy_ops___TupleSet_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"items", "line", 0};
    PyObject *obj_items;
    PyObject *obj_line;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OO", "__init__", kwlist, &obj_items, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___TupleSet))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.TupleSet", obj_self); 
        goto fail;
    }
    PyObject *arg_items;
    if (likely(PyList_Check(obj_items)))
        arg_items = obj_items;
    else {
        CPy_TypeError("list", obj_items); 
        goto fail;
    }
    CPyTagged arg_line;
    if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___TupleSet_____init__(arg_self, arg_items, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 778, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___TupleSet___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject **cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___TupleSetObject *)cpy_r_self)->_items;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = CPyStatics[362]; /* 'copy' */
    PyObject *cpy_r_r2[1] = {cpy_r_r0};
    cpy_r_r3 = (PyObject **)&cpy_r_r2;
    cpy_r_r4 = PyObject_VectorcallMethod(cpy_r_r1, cpy_r_r3, 9223372036854775809ULL, 0);
    if (unlikely(cpy_r_r4 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 793, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_DECREF(cpy_r_r0);
    if (likely(PyList_Check(cpy_r_r4)))
        cpy_r_r5 = cpy_r_r4;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "sources", 793, CPyStatic_ops___globals, "list", cpy_r_r4);
        goto CPyL3;
    }
    return cpy_r_r5;
CPyL3: ;
    cpy_r_r6 = NULL;
    return cpy_r_r6;
CPyL4: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL3;
}

PyObject *CPyPy_ops___TupleSet___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___TupleSet))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.TupleSet", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___TupleSet___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 792, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___TupleSet___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 13, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_tuple_set */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 796, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___TupleSet___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___TupleSet))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.TupleSet", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___TupleSet___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 795, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___TupleSet_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___TupleSetObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___TupleSetObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___TupleSetObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___TupleSetObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___TupleSetObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___TupleSetObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___TupleSet_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___TupleSet))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.TupleSet", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___TupleSet_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___TupleGet_____init__(PyObject *cpy_r_self, PyObject *cpy_r_src, CPyTagged cpy_r_index, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    char cpy_r_r5;
    char cpy_r_r6;
    int64_t cpy_r_r7;
    char cpy_r_r8;
    int64_t cpy_r_r9;
    char cpy_r_r10;
    char cpy_r_r11;
    char cpy_r_r12;
    char cpy_r_r13;
    char cpy_r_r14;
    char cpy_r_r15;
    char cpy_r_r16;
    PyObject *cpy_r_r17;
    PyObject *cpy_r_r18;
    PyObject *cpy_r_r19;
    PyObject *cpy_r_r20;
    PyObject *cpy_r_r21;
    char cpy_r_r22;
    char cpy_r_r23;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL17;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 805, CPyStatic_ops___globals);
        goto CPyL16;
    }
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___TupleGetObject *)cpy_r_self)->_src = cpy_r_src;
    CPyTagged_INCREF(cpy_r_index);
    ((mypyc___ir___ops___TupleGetObject *)cpy_r_self)->_index = cpy_r_index;
    cpy_r_r1 = ((mypyc___ir___ops___ValueObject *)cpy_r_src)->_type;
    cpy_r_r2 = (PyObject *)CPyType_rtypes___RTuple;
    cpy_r_r3 = (CPyPtr)&((PyObject *)cpy_r_r1)->ob_type;
    cpy_r_r4 = *(PyObject * *)cpy_r_r3;
    cpy_r_r5 = cpy_r_r4 == cpy_r_r2;
    if (cpy_r_r5) goto CPyL6;
    PyErr_SetString(PyExc_AssertionError, "TupleGet only operates on tuples");
    cpy_r_r6 = 0;
    if (unlikely(!cpy_r_r6)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 808, CPyStatic_ops___globals);
        goto CPyL16;
    }
    CPy_Unreachable();
CPyL6: ;
    cpy_r_r7 = cpy_r_index & 1;
    cpy_r_r8 = cpy_r_r7 == 0;
    cpy_r_r9 = 0 & 1;
    cpy_r_r10 = cpy_r_r9 == 0;
    cpy_r_r11 = cpy_r_r8 & cpy_r_r10;
    if (!cpy_r_r11) goto CPyL8;
    cpy_r_r12 = (Py_ssize_t)cpy_r_index >= (Py_ssize_t)0;
    cpy_r_r13 = cpy_r_r12;
    goto CPyL9;
CPyL8: ;
    cpy_r_r14 = CPyTagged_IsLt_(cpy_r_index, 0);
    cpy_r_r15 = cpy_r_r14 ^ 1;
    cpy_r_r13 = cpy_r_r15;
CPyL9: ;
    if (cpy_r_r13) goto CPyL12;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r16 = 0;
    if (unlikely(!cpy_r_r16)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 809, CPyStatic_ops___globals);
        goto CPyL16;
    }
    CPy_Unreachable();
CPyL12: ;
    cpy_r_r17 = ((mypyc___ir___ops___ValueObject *)cpy_r_src)->_type;
    if (likely(Py_TYPE(cpy_r_r17) == CPyType_rtypes___RTuple))
        cpy_r_r18 = cpy_r_r17;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__init__", 810, CPyStatic_ops___globals, "mypyc.ir.rtypes.RTuple", cpy_r_r17);
        goto CPyL16;
    }
    cpy_r_r19 = ((mypyc___ir___rtypes___RTupleObject *)cpy_r_r18)->_types;
    CPy_INCREF(cpy_r_r19);
    cpy_r_r20 = CPySequenceTuple_GetItem(cpy_r_r19, cpy_r_index);
    CPy_DECREF(cpy_r_r19);
    if (unlikely(cpy_r_r20 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 810, CPyStatic_ops___globals);
        goto CPyL16;
    }
    if (likely(PyObject_TypeCheck(cpy_r_r20, CPyType_rtypes___RType)))
        cpy_r_r21 = cpy_r_r20;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "__init__", 810, CPyStatic_ops___globals, "mypyc.ir.rtypes.RType", cpy_r_r20);
        goto CPyL16;
    }
    CPy_DECREF(((mypyc___ir___ops___TupleGetObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___TupleGetObject *)cpy_r_self)->_type = cpy_r_r21;
    return 1;
CPyL16: ;
    cpy_r_r23 = 2;
    return cpy_r_r23;
CPyL17: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___TupleGet_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"src", "index", "line", 0};
    PyObject *obj_src;
    PyObject *obj_index;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OO|O", "__init__", kwlist, &obj_src, &obj_index, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___TupleGet))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.TupleGet", obj_self); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    CPyTagged arg_index;
    if (likely(PyLong_Check(obj_index)))
        arg_index = CPyTagged_BorrowFromObject(obj_index);
    else {
        CPy_TypeError("int", obj_index); goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___TupleGet_____init__(arg_self, arg_src, arg_index, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 804, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___TupleGet___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___TupleGetObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 813, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___TupleGet___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___TupleGet))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.TupleGet", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___TupleGet___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 812, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___TupleGet___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 12, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_tuple_get */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 816, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___TupleGet___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___TupleGet))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.TupleGet", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___TupleGet___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 815, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___TupleGet_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___TupleGetObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___TupleGetObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___TupleGetObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___TupleGetObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___TupleGetObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___TupleGetObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___TupleGet_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___TupleGet))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.TupleGet", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___TupleGet_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Cast_____init__(PyObject *cpy_r_self, PyObject *cpy_r_src, PyObject *cpy_r_typ, CPyTagged cpy_r_line, char cpy_r_borrow) {
    char cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    if (cpy_r_borrow != 2) goto CPyL2;
    cpy_r_borrow = 0;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 830, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___CastObject *)cpy_r_self)->_src = cpy_r_src;
    CPy_INCREF(cpy_r_typ);
    CPy_DECREF(((mypyc___ir___ops___CastObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___CastObject *)cpy_r_self)->_type = cpy_r_typ;
    ((mypyc___ir___ops___CastObject *)cpy_r_self)->_is_borrowed = cpy_r_borrow;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___Cast_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"src", "typ", "line", "borrow", 0};
    PyObject *obj_src;
    PyObject *obj_typ;
    PyObject *obj_line;
    PyObject *obj_borrow = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO|$O", "__init__", kwlist, &obj_src, &obj_typ, &obj_line, &obj_borrow)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Cast))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Cast", obj_self); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    PyObject *arg_typ;
    if (likely(PyObject_TypeCheck(obj_typ, CPyType_rtypes___RType)))
        arg_typ = obj_typ;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_typ); 
        goto fail;
    }
    CPyTagged arg_line;
    if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char arg_borrow;
    if (obj_borrow == NULL) {
        arg_borrow = 2;
    } else if (unlikely(!PyBool_Check(obj_borrow))) {
        CPy_TypeError("bool", obj_borrow); goto fail;
    } else
        arg_borrow = obj_borrow == Py_True;
    char retval = CPyDef_ops___Cast_____init__(arg_self, arg_src, arg_typ, arg_line, arg_borrow);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 829, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Cast___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___CastObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 836, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___Cast___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Cast))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Cast", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Cast___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 835, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Cast___stolen(PyObject *cpy_r_self) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    CPyPtr cpy_r_r4;
    CPyPtr cpy_r_r5;
    PyObject *cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___CastObject *)cpy_r_self)->_is_borrowed;
    if (!cpy_r_r0) goto CPyL3;
CPyL1: ;
    cpy_r_r1 = PyList_New(0);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 840, CPyStatic_ops___globals);
        goto CPyL5;
    }
    return cpy_r_r1;
CPyL3: ;
    cpy_r_r2 = ((mypyc___ir___ops___CastObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r2);
    cpy_r_r3 = PyList_New(1);
    if (unlikely(cpy_r_r3 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 841, CPyStatic_ops___globals);
        goto CPyL6;
    }
    cpy_r_r4 = (CPyPtr)&((PyListObject *)cpy_r_r3)->ob_item;
    cpy_r_r5 = *(CPyPtr *)cpy_r_r4;
    *(PyObject * *)cpy_r_r5 = cpy_r_r2;
    return cpy_r_r3;
CPyL5: ;
    cpy_r_r6 = NULL;
    return cpy_r_r6;
CPyL6: ;
    CPy_DecRef(cpy_r_r2);
    goto CPyL5;
}

PyObject *CPyPy_ops___Cast___stolen(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":stolen", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Cast))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Cast", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Cast___stolen(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 838, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Cast___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 18, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_cast */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 844, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Cast___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Cast))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Cast", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Cast___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 843, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Cast_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___CastObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___CastObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___CastObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___CastObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___CastObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___CastObject *)cpy_r___mypyc_self__)->_error_kind = 2;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___Cast_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Cast))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Cast", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Cast_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Box_____init__(PyObject *cpy_r_self, PyObject *cpy_r_src, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    char cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    char cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    char cpy_r_r12;
    char cpy_r_r13;
    char cpy_r_r14;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL15;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 857, CPyStatic_ops___globals);
        goto CPyL14;
    }
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___BoxObject *)cpy_r_self)->_src = cpy_r_src;
    cpy_r_r1 = CPyStatic_rtypes___object_rprimitive;
    if (likely(cpy_r_r1 != NULL)) goto CPyL6;
    PyErr_SetString(PyExc_NameError, "value for final name \"object_rprimitive\" was not set");
    cpy_r_r2 = 0;
    if (unlikely(!cpy_r_r2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 859, CPyStatic_ops___globals);
        goto CPyL14;
    }
    CPy_Unreachable();
CPyL6: ;
    CPy_INCREF(cpy_r_r1);
    CPy_DECREF(((mypyc___ir___ops___BoxObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___BoxObject *)cpy_r_self)->_type = cpy_r_r1;
    cpy_r_r4 = ((mypyc___ir___ops___BoxObject *)cpy_r_self)->_src;
    cpy_r_r5 = ((mypyc___ir___ops___ValueObject *)cpy_r_r4)->_type;
    CPy_INCREF(cpy_r_r5);
    cpy_r_r6 = CPyDef_rtypes___is_none_rprimitive(cpy_r_r5);
    CPy_DECREF(cpy_r_r5);
    if (unlikely(cpy_r_r6 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 862, CPyStatic_ops___globals);
        goto CPyL14;
    }
    if (cpy_r_r6) goto CPyL12;
    cpy_r_r7 = ((mypyc___ir___ops___BoxObject *)cpy_r_self)->_src;
    cpy_r_r8 = ((mypyc___ir___ops___ValueObject *)cpy_r_r7)->_type;
    CPy_INCREF(cpy_r_r8);
    cpy_r_r9 = CPyDef_rtypes___is_bool_rprimitive(cpy_r_r8);
    CPy_DECREF(cpy_r_r8);
    if (unlikely(cpy_r_r9 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 863, CPyStatic_ops___globals);
        goto CPyL14;
    }
    if (cpy_r_r9) goto CPyL12;
    cpy_r_r10 = ((mypyc___ir___ops___BoxObject *)cpy_r_self)->_src;
    cpy_r_r11 = ((mypyc___ir___ops___ValueObject *)cpy_r_r10)->_type;
    CPy_INCREF(cpy_r_r11);
    cpy_r_r12 = CPyDef_rtypes___is_bit_rprimitive(cpy_r_r11);
    CPy_DECREF(cpy_r_r11);
    if (unlikely(cpy_r_r12 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 864, CPyStatic_ops___globals);
        goto CPyL14;
    }
    if (!cpy_r_r12) goto CPyL13;
CPyL12: ;
    ((mypyc___ir___ops___BoxObject *)cpy_r_self)->_is_borrowed = 1;
CPyL13: ;
    return 1;
CPyL14: ;
    cpy_r_r14 = 2;
    return cpy_r_r14;
CPyL15: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___Box_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"src", "line", 0};
    PyObject *obj_src;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O|O", "__init__", kwlist, &obj_src, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Box))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Box", obj_self); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Box_____init__(arg_self, arg_src, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 856, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Box___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___BoxObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 869, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___Box___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Box))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Box", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Box___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 868, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Box___stolen(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___BoxObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 872, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___Box___stolen(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":stolen", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Box))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Box", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Box___stolen(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 871, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Box___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 19, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_box */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 875, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Box___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Box))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Box", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Box___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 874, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Box_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___BoxObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___BoxObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___BoxObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___BoxObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___BoxObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___BoxObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___Box_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Box))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Box", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Box_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Unbox_____init__(PyObject *cpy_r_self, PyObject *cpy_r_src, PyObject *cpy_r_typ, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___UnboxObject *)cpy_r_self)->_src = cpy_r_src;
    CPy_INCREF(cpy_r_typ);
    CPy_DECREF(((mypyc___ir___ops___UnboxObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___UnboxObject *)cpy_r_self)->_type = cpy_r_typ;
    cpy_r_r1 = ((mypyc___ir___rtypes___RTypeObject *)cpy_r_typ)->_error_overlap;
    if (cpy_r_r1) goto CPyL2;
CPyL1: ;
    CPyTagged_DECREF(((mypyc___ir___ops___UnboxObject *)cpy_r_self)->_error_kind);
    ((mypyc___ir___ops___UnboxObject *)cpy_r_self)->_error_kind = 2;
    goto CPyL3;
CPyL2: ;
    CPyTagged_DECREF(((mypyc___ir___ops___UnboxObject *)cpy_r_self)->_error_kind);
    ((mypyc___ir___ops___UnboxObject *)cpy_r_self)->_error_kind = 8;
CPyL3: ;
    cpy_r_r4 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    if (unlikely(cpy_r_r4 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 892, CPyStatic_ops___globals);
        goto CPyL5;
    }
    return 1;
CPyL5: ;
    cpy_r_r5 = 2;
    return cpy_r_r5;
}

PyObject *CPyPy_ops___Unbox_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"src", "typ", "line", 0};
    PyObject *obj_src;
    PyObject *obj_typ;
    PyObject *obj_line;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO", "__init__", kwlist, &obj_src, &obj_typ, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Unbox))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Unbox", obj_self); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    PyObject *arg_typ;
    if (likely(PyObject_TypeCheck(obj_typ, CPyType_rtypes___RType)))
        arg_typ = obj_typ;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_typ); 
        goto fail;
    }
    CPyTagged arg_line;
    if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Unbox_____init__(arg_self, arg_src, arg_typ, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 885, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Unbox___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___UnboxObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 895, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___Unbox___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Unbox))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Unbox", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Unbox___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 894, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Unbox___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 20, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_unbox */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 898, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Unbox___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Unbox))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Unbox", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Unbox___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 897, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Unbox_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___UnboxObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___UnboxObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___UnboxObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___UnboxObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___UnboxObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___Unbox_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Unbox))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Unbox", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Unbox_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___RaiseStandardError_____init__(PyObject *cpy_r_self, PyObject *cpy_r_class_name, PyObject *cpy_r_value, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 921, CPyStatic_ops___globals);
        goto CPyL5;
    }
    CPy_INCREF(cpy_r_class_name);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r_self)->_class_name = cpy_r_class_name;
    CPy_INCREF(cpy_r_value);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r_self)->_value = cpy_r_value;
    cpy_r_r1 = CPyStatic_rtypes___bool_rprimitive;
    if (likely(cpy_r_r1 != NULL)) goto CPyL4;
    PyErr_SetString(PyExc_NameError, "value for final name \"bool_rprimitive\" was not set");
    cpy_r_r2 = 0;
    if (unlikely(!cpy_r_r2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 924, CPyStatic_ops___globals);
        goto CPyL5;
    }
    CPy_Unreachable();
CPyL4: ;
    CPy_INCREF(cpy_r_r1);
    CPy_DECREF(((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r_self)->_type = cpy_r_r1;
    return 1;
CPyL5: ;
    cpy_r_r4 = 2;
    return cpy_r_r4;
}

PyObject *CPyPy_ops___RaiseStandardError_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"class_name", "value", "line", 0};
    PyObject *obj_class_name;
    PyObject *obj_value;
    PyObject *obj_line;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO", "__init__", kwlist, &obj_class_name, &obj_value, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___RaiseStandardError))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.RaiseStandardError", obj_self); 
        goto fail;
    }
    PyObject *arg_class_name;
    if (likely(PyUnicode_Check(obj_class_name)))
        arg_class_name = obj_class_name;
    else {
        CPy_TypeError("str", obj_class_name); 
        goto fail;
    }
    PyObject *arg_value;
    if (PyUnicode_Check(obj_value))
        arg_value = obj_value;
    else {
        arg_value = NULL;
    }
    if (arg_value != NULL) goto __LL9871;
    if (PyObject_TypeCheck(obj_value, CPyType_ops___Value))
        arg_value = obj_value;
    else {
        arg_value = NULL;
    }
    if (arg_value != NULL) goto __LL9871;
    if (obj_value == Py_None)
        arg_value = obj_value;
    else {
        arg_value = NULL;
    }
    if (arg_value != NULL) goto __LL9871;
    CPy_TypeError("union[str, mypyc.ir.ops.Value, None]", obj_value); 
    goto fail;
__LL9871: ;
    CPyTagged arg_line;
    if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___RaiseStandardError_____init__(arg_self, arg_class_name, arg_value, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 920, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___RaiseStandardError___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 927, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___RaiseStandardError___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___RaiseStandardError))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.RaiseStandardError", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___RaiseStandardError___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 926, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___RaiseStandardError___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 21, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_raise_standard_error */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 930, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___RaiseStandardError___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___RaiseStandardError))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.RaiseStandardError", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___RaiseStandardError___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 929, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___RaiseStandardError_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject *cpy_r_r9;
    char cpy_r_r10;
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_error_kind = 4;
    cpy_r_r3 = CPyStatics[1544]; /* 'ValueError' */
    CPy_INCREF(cpy_r_r3);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_VALUE_ERROR = cpy_r_r3;
    cpy_r_r4 = CPyStatics[23]; /* 'AssertionError' */
    CPy_INCREF(cpy_r_r4);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_ASSERTION_ERROR = cpy_r_r4;
    cpy_r_r5 = CPyStatics[75]; /* 'StopIteration' */
    CPy_INCREF(cpy_r_r5);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_STOP_ITERATION = cpy_r_r5;
    cpy_r_r6 = CPyStatics[7811]; /* 'UnboundLocalError' */
    CPy_INCREF(cpy_r_r6);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_UNBOUND_LOCAL_ERROR = cpy_r_r6;
    cpy_r_r7 = CPyStatics[718]; /* 'RuntimeError' */
    CPy_INCREF(cpy_r_r7);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_RUNTIME_ERROR = cpy_r_r7;
    cpy_r_r8 = CPyStatics[7812]; /* 'NameError' */
    CPy_INCREF(cpy_r_r8);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_NAME_ERROR = cpy_r_r8;
    cpy_r_r9 = CPyStatics[7813]; /* 'ZeroDivisionError' */
    CPy_INCREF(cpy_r_r9);
    ((mypyc___ir___ops___RaiseStandardErrorObject *)cpy_r___mypyc_self__)->_ZERO_DIVISION_ERROR = cpy_r_r9;
    return 1;
CPyL4: ;
    cpy_r_r10 = 2;
    return cpy_r_r10;
}

PyObject *CPyPy_ops___RaiseStandardError_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___RaiseStandardError))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.RaiseStandardError", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___RaiseStandardError_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___CallC_____init__(PyObject *cpy_r_self, PyObject *cpy_r_function_name, PyObject *cpy_r_args, PyObject *cpy_r_ret_type, PyObject *cpy_r_steals, char cpy_r_is_borrowed, CPyTagged cpy_r_error_kind, CPyTagged cpy_r_line, CPyTagged cpy_r_var_arg_idx) {
    char cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    if (cpy_r_var_arg_idx != CPY_INT_TAG) goto CPyL5;
    cpy_r_var_arg_idx = -2;
CPyL2: ;
    CPyTagged_INCREF(cpy_r_error_kind);
    CPyTagged_DECREF(((mypyc___ir___ops___CallCObject *)cpy_r_self)->_error_kind);
    ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_error_kind = cpy_r_error_kind;
    cpy_r_r1 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    if (unlikely(cpy_r_r1 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 957, CPyStatic_ops___globals);
        goto CPyL6;
    }
    CPy_INCREF(cpy_r_function_name);
    ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_function_name = cpy_r_function_name;
    CPy_INCREF(cpy_r_args);
    ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_args = cpy_r_args;
    CPy_INCREF(cpy_r_ret_type);
    CPy_DECREF(((mypyc___ir___ops___CallCObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_type = cpy_r_ret_type;
    CPy_INCREF(cpy_r_steals);
    ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_steals = cpy_r_steals;
    ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_is_borrowed = cpy_r_is_borrowed;
    ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_var_arg_idx = cpy_r_var_arg_idx;
    return 1;
CPyL4: ;
    cpy_r_r4 = 2;
    return cpy_r_r4;
CPyL5: ;
    CPyTagged_INCREF(cpy_r_var_arg_idx);
    goto CPyL2;
CPyL6: ;
    CPyTagged_DecRef(cpy_r_var_arg_idx);
    goto CPyL4;
}

PyObject *CPyPy_ops___CallC_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"function_name", "args", "ret_type", "steals", "is_borrowed", "error_kind", "line", "var_arg_idx", 0};
    PyObject *obj_function_name;
    PyObject *obj_args;
    PyObject *obj_ret_type;
    PyObject *obj_steals;
    PyObject *obj_is_borrowed;
    PyObject *obj_error_kind;
    PyObject *obj_line;
    PyObject *obj_var_arg_idx = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO|O", "__init__", kwlist, &obj_function_name, &obj_args, &obj_ret_type, &obj_steals, &obj_is_borrowed, &obj_error_kind, &obj_line, &obj_var_arg_idx)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___CallC))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.CallC", obj_self); 
        goto fail;
    }
    PyObject *arg_function_name;
    if (likely(PyUnicode_Check(obj_function_name)))
        arg_function_name = obj_function_name;
    else {
        CPy_TypeError("str", obj_function_name); 
        goto fail;
    }
    PyObject *arg_args;
    if (likely(PyList_Check(obj_args)))
        arg_args = obj_args;
    else {
        CPy_TypeError("list", obj_args); 
        goto fail;
    }
    PyObject *arg_ret_type;
    if (likely(PyObject_TypeCheck(obj_ret_type, CPyType_rtypes___RType)))
        arg_ret_type = obj_ret_type;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_ret_type); 
        goto fail;
    }
    PyObject *arg_steals;
    if (PyBool_Check(obj_steals))
        arg_steals = obj_steals;
    else {
        arg_steals = NULL;
    }
    if (arg_steals != NULL) goto __LL9872;
    if (PyList_Check(obj_steals))
        arg_steals = obj_steals;
    else {
        arg_steals = NULL;
    }
    if (arg_steals != NULL) goto __LL9872;
    CPy_TypeError("union[bool, list]", obj_steals); 
    goto fail;
__LL9872: ;
    char arg_is_borrowed;
    if (unlikely(!PyBool_Check(obj_is_borrowed))) {
        CPy_TypeError("bool", obj_is_borrowed); goto fail;
    } else
        arg_is_borrowed = obj_is_borrowed == Py_True;
    CPyTagged arg_error_kind;
    if (likely(PyLong_Check(obj_error_kind)))
        arg_error_kind = CPyTagged_BorrowFromObject(obj_error_kind);
    else {
        CPy_TypeError("int", obj_error_kind); goto fail;
    }
    CPyTagged arg_line;
    if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    CPyTagged arg_var_arg_idx;
    if (obj_var_arg_idx == NULL) {
        arg_var_arg_idx = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_var_arg_idx)))
        arg_var_arg_idx = CPyTagged_BorrowFromObject(obj_var_arg_idx);
    else {
        CPy_TypeError("int", obj_var_arg_idx); goto fail;
    }
    char retval = CPyDef_ops___CallC_____init__(arg_self, arg_function_name, arg_args, arg_ret_type, arg_steals, arg_is_borrowed, arg_error_kind, arg_line, arg_var_arg_idx);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 945, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___CallC___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    cpy_r_r0 = ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_args;
    CPy_INCREF(cpy_r_r0);
    return cpy_r_r0;
}

PyObject *CPyPy_ops___CallC___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___CallC))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.CallC", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___CallC___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 966, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___CallC___stolen(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    int32_t cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    CPyPtr cpy_r_r7;
    int64_t cpy_r_r8;
    CPyTagged cpy_r_r9;
    PyObject *cpy_r_r10;
    CPyPtr cpy_r_r11;
    int64_t cpy_r_r12;
    CPyTagged cpy_r_r13;
    char cpy_r_r14;
    char cpy_r_r15;
    PyObject *cpy_r_r16;
    PyObject *cpy_r_r17;
    CPyTagged cpy_r_r18;
    PyObject *cpy_r_r19;
    PyObject *cpy_r_r20;
    CPyTagged cpy_r_r21;
    CPyPtr cpy_r_r22;
    int64_t cpy_r_r23;
    CPyTagged cpy_r_r24;
    char cpy_r_r25;
    CPyPtr cpy_r_r26;
    int64_t cpy_r_r27;
    CPyTagged cpy_r_r28;
    char cpy_r_r29;
    PyObject *cpy_r_r30;
    PyObject *cpy_r_r31;
    PyObject *cpy_r_arg;
    PyObject *cpy_r_r32;
    char cpy_r_r33;
    char cpy_r_steal;
    int32_t cpy_r_r34;
    char cpy_r_r35;
    CPyTagged cpy_r_r36;
    CPyTagged cpy_r_r37;
    PyObject *cpy_r_r38;
    char cpy_r_r39;
    PyObject *cpy_r_r40;
    PyObject *cpy_r_r41;
    PyObject *cpy_r_r42;
    PyObject *cpy_r_r43;
    cpy_r_r0 = ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_steals;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = (PyObject *)&PyList_Type;
    cpy_r_r2 = PyObject_IsInstance(cpy_r_r0, cpy_r_r1);
    CPy_DECREF(cpy_r_r0);
    cpy_r_r3 = cpy_r_r2 >= 0;
    if (unlikely(!cpy_r_r3)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 970, CPyStatic_ops___globals);
        goto CPyL24;
    }
    cpy_r_r4 = cpy_r_r2;
    if (!cpy_r_r4) goto CPyL17;
    cpy_r_r5 = ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_steals;
    if (likely(PyList_Check(cpy_r_r5)))
        cpy_r_r6 = cpy_r_r5;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "stolen", 971, CPyStatic_ops___globals, "list", cpy_r_r5);
        goto CPyL24;
    }
    cpy_r_r7 = (CPyPtr)&((PyVarObject *)cpy_r_r6)->ob_size;
    cpy_r_r8 = *(int64_t *)cpy_r_r7;
    cpy_r_r9 = cpy_r_r8 << 1;
    cpy_r_r10 = ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_args;
    cpy_r_r11 = (CPyPtr)&((PyVarObject *)cpy_r_r10)->ob_size;
    cpy_r_r12 = *(int64_t *)cpy_r_r11;
    cpy_r_r13 = cpy_r_r12 << 1;
    cpy_r_r14 = cpy_r_r9 == cpy_r_r13;
    if (cpy_r_r14) goto CPyL6;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r15 = 0;
    if (unlikely(!cpy_r_r15)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 971, CPyStatic_ops___globals);
        goto CPyL24;
    }
    CPy_Unreachable();
CPyL6: ;
    cpy_r_r16 = PyList_New(0);
    if (unlikely(cpy_r_r16 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 972, CPyStatic_ops___globals);
        goto CPyL24;
    }
    cpy_r_r17 = ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_args;
    CPy_INCREF(cpy_r_r17);
    cpy_r_r18 = 0;
    cpy_r_r19 = ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_steals;
    CPy_INCREF(cpy_r_r19);
    if (likely(PyList_Check(cpy_r_r19)))
        cpy_r_r20 = cpy_r_r19;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "stolen", 972, CPyStatic_ops___globals, "list", cpy_r_r19);
        goto CPyL25;
    }
    cpy_r_r21 = 0;
CPyL9: ;
    cpy_r_r22 = (CPyPtr)&((PyVarObject *)cpy_r_r17)->ob_size;
    cpy_r_r23 = *(int64_t *)cpy_r_r22;
    cpy_r_r24 = cpy_r_r23 << 1;
    cpy_r_r25 = (Py_ssize_t)cpy_r_r18 < (Py_ssize_t)cpy_r_r24;
    if (!cpy_r_r25) goto CPyL26;
    cpy_r_r26 = (CPyPtr)&((PyVarObject *)cpy_r_r20)->ob_size;
    cpy_r_r27 = *(int64_t *)cpy_r_r26;
    cpy_r_r28 = cpy_r_r27 << 1;
    cpy_r_r29 = (Py_ssize_t)cpy_r_r21 < (Py_ssize_t)cpy_r_r28;
    if (!cpy_r_r29) goto CPyL26;
    cpy_r_r30 = CPyList_GetItemUnsafe(cpy_r_r17, cpy_r_r18);
    if (likely(PyObject_TypeCheck(cpy_r_r30, CPyType_ops___Value)))
        cpy_r_r31 = cpy_r_r30;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "stolen", 972, CPyStatic_ops___globals, "mypyc.ir.ops.Value", cpy_r_r30);
        goto CPyL27;
    }
    cpy_r_arg = cpy_r_r31;
    cpy_r_r32 = CPyList_GetItemUnsafe(cpy_r_r20, cpy_r_r21);
    if (unlikely(!PyBool_Check(cpy_r_r32))) {
        CPy_TypeError("bool", cpy_r_r32); cpy_r_r33 = 2;
    } else
        cpy_r_r33 = cpy_r_r32 == Py_True;
    CPy_DECREF(cpy_r_r32);
    if (unlikely(cpy_r_r33 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 972, CPyStatic_ops___globals);
        goto CPyL28;
    }
    cpy_r_steal = cpy_r_r33;
    if (!cpy_r_steal) goto CPyL29;
    cpy_r_r34 = PyList_Append(cpy_r_r16, cpy_r_arg);
    CPy_DECREF(cpy_r_arg);
    cpy_r_r35 = cpy_r_r34 >= 0;
    if (unlikely(!cpy_r_r35)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 972, CPyStatic_ops___globals);
        goto CPyL27;
    }
CPyL15: ;
    cpy_r_r36 = cpy_r_r18 + 2;
    cpy_r_r18 = cpy_r_r36;
    cpy_r_r37 = cpy_r_r21 + 2;
    cpy_r_r21 = cpy_r_r37;
    goto CPyL9;
CPyL16: ;
    return cpy_r_r16;
CPyL17: ;
    cpy_r_r38 = ((mypyc___ir___ops___CallCObject *)cpy_r_self)->_steals;
    CPy_INCREF(cpy_r_r38);
    if (unlikely(!PyBool_Check(cpy_r_r38))) {
        CPy_TypeError("bool", cpy_r_r38); cpy_r_r39 = 2;
    } else
        cpy_r_r39 = cpy_r_r38 == Py_True;
    CPy_DECREF(cpy_r_r38);
    if (unlikely(cpy_r_r39 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 974, CPyStatic_ops___globals);
        goto CPyL24;
    }
    if (cpy_r_r39) goto CPyL21;
    cpy_r_r40 = PyList_New(0);
    if (unlikely(cpy_r_r40 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 974, CPyStatic_ops___globals);
        goto CPyL24;
    }
    cpy_r_r41 = cpy_r_r40;
    goto CPyL23;
CPyL21: ;
    cpy_r_r42 = CPyDef_ops___CallC___sources(cpy_r_self);
    if (unlikely(cpy_r_r42 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 974, CPyStatic_ops___globals);
        goto CPyL24;
    }
    cpy_r_r41 = cpy_r_r42;
CPyL23: ;
    return cpy_r_r41;
CPyL24: ;
    cpy_r_r43 = NULL;
    return cpy_r_r43;
CPyL25: ;
    CPy_DecRef(cpy_r_r16);
    CPy_DecRef(cpy_r_r17);
    goto CPyL24;
CPyL26: ;
    CPy_DECREF(cpy_r_r17);
    CPy_DECREF(cpy_r_r20);
    goto CPyL16;
CPyL27: ;
    CPy_DecRef(cpy_r_r16);
    CPy_DecRef(cpy_r_r17);
    CPy_DecRef(cpy_r_r20);
    goto CPyL24;
CPyL28: ;
    CPy_DecRef(cpy_r_r16);
    CPy_DecRef(cpy_r_r17);
    CPy_DecRef(cpy_r_r20);
    CPy_DecRef(cpy_r_arg);
    goto CPyL24;
CPyL29: ;
    CPy_DECREF(cpy_r_arg);
    goto CPyL15;
}

PyObject *CPyPy_ops___CallC___stolen(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":stolen", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___CallC))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.CallC", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___CallC___stolen(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 969, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___CallC___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 22, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_call_c */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 977, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___CallC___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___CallC))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.CallC", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___CallC___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 976, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___CallC_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___CallCObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___CallCObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___CallCObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___CallCObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___CallCObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___CallC_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___CallC))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.CallC", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___CallC_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Truncate_____init__(PyObject *cpy_r_self, PyObject *cpy_r_src, PyObject *cpy_r_dst_type, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL5;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 992, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___TruncateObject *)cpy_r_self)->_src = cpy_r_src;
    CPy_INCREF(cpy_r_dst_type);
    CPy_DECREF(((mypyc___ir___ops___TruncateObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___TruncateObject *)cpy_r_self)->_type = cpy_r_dst_type;
    cpy_r_r2 = ((mypyc___ir___ops___ValueObject *)cpy_r_src)->_type;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___TruncateObject *)cpy_r_self)->_src_type = cpy_r_r2;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
CPyL5: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___Truncate_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"src", "dst_type", "line", 0};
    PyObject *obj_src;
    PyObject *obj_dst_type;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OO|O", "__init__", kwlist, &obj_src, &obj_dst_type, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Truncate))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Truncate", obj_self); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    PyObject *arg_dst_type;
    if (likely(PyObject_TypeCheck(obj_dst_type, CPyType_rtypes___RType)))
        arg_dst_type = obj_dst_type;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_dst_type); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Truncate_____init__(arg_self, arg_src, arg_dst_type, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 991, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Truncate___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___TruncateObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 998, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___Truncate___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Truncate))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Truncate", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Truncate___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 997, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Truncate___stolen(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 1001, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Truncate___stolen(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":stolen", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Truncate))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Truncate", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Truncate___stolen(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 1000, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Truncate___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 23, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_truncate */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1004, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Truncate___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Truncate))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Truncate", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Truncate___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1003, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Truncate_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___TruncateObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___TruncateObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___TruncateObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___TruncateObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___TruncateObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___TruncateObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___Truncate_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Truncate))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Truncate", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Truncate_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Extend_____init__(PyObject *cpy_r_self, PyObject *cpy_r_src, PyObject *cpy_r_dst_type, char cpy_r_signed, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL5;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1022, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___ExtendObject *)cpy_r_self)->_src = cpy_r_src;
    CPy_INCREF(cpy_r_dst_type);
    CPy_DECREF(((mypyc___ir___ops___ExtendObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___ExtendObject *)cpy_r_self)->_type = cpy_r_dst_type;
    cpy_r_r2 = ((mypyc___ir___ops___ValueObject *)cpy_r_src)->_type;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___ExtendObject *)cpy_r_self)->_src_type = cpy_r_r2;
    ((mypyc___ir___ops___ExtendObject *)cpy_r_self)->_signed = cpy_r_signed;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
CPyL5: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___Extend_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"src", "dst_type", "signed", "line", 0};
    PyObject *obj_src;
    PyObject *obj_dst_type;
    PyObject *obj_signed;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO|O", "__init__", kwlist, &obj_src, &obj_dst_type, &obj_signed, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Extend))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Extend", obj_self); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    PyObject *arg_dst_type;
    if (likely(PyObject_TypeCheck(obj_dst_type, CPyType_rtypes___RType)))
        arg_dst_type = obj_dst_type;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_dst_type); 
        goto fail;
    }
    char arg_signed;
    if (unlikely(!PyBool_Check(obj_signed))) {
        CPy_TypeError("bool", obj_signed); goto fail;
    } else
        arg_signed = obj_signed == Py_True;
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___Extend_____init__(arg_self, arg_src, arg_dst_type, arg_signed, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1021, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Extend___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___ExtendObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1029, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___Extend___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Extend))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Extend", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Extend___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1028, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Extend___stolen(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 1032, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Extend___stolen(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":stolen", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Extend))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Extend", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Extend___stolen(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 1031, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___Extend___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 24, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_extend */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1035, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___Extend___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___Extend))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.Extend", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___Extend___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1034, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___Extend_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___ExtendObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___ExtendObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___ExtendObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___ExtendObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___ExtendObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___ExtendObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___Extend_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___Extend))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.Extend", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___Extend_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadGlobal_____init__(PyObject *cpy_r_self, PyObject *cpy_r_type, PyObject *cpy_r_identifier, CPyTagged cpy_r_line, PyObject *cpy_r_ann) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL7;
    cpy_r_line = -2;
CPyL2: ;
    if (cpy_r_ann != NULL) goto CPyL8;
    cpy_r_r0 = Py_None;
    CPy_INCREF(cpy_r_r0);
    cpy_r_ann = cpy_r_r0;
CPyL4: ;
    cpy_r_r1 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r1 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1050, CPyStatic_ops___globals);
        goto CPyL9;
    }
    CPy_INCREF(cpy_r_identifier);
    ((mypyc___ir___ops___LoadGlobalObject *)cpy_r_self)->_identifier = cpy_r_identifier;
    CPy_INCREF(cpy_r_type);
    CPy_DECREF(((mypyc___ir___ops___LoadGlobalObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___LoadGlobalObject *)cpy_r_self)->_type = cpy_r_type;
    ((mypyc___ir___ops___LoadGlobalObject *)cpy_r_self)->_ann = cpy_r_ann;
    return 1;
CPyL6: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
CPyL7: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
CPyL8: ;
    CPy_INCREF(cpy_r_ann);
    goto CPyL4;
CPyL9: ;
    CPy_DecRef(cpy_r_ann);
    goto CPyL6;
}

PyObject *CPyPy_ops___LoadGlobal_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"type", "identifier", "line", "ann", 0};
    PyObject *obj_type;
    PyObject *obj_identifier;
    PyObject *obj_line = NULL;
    PyObject *obj_ann = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OO|OO", "__init__", kwlist, &obj_type, &obj_identifier, &obj_line, &obj_ann)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadGlobal))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadGlobal", obj_self); 
        goto fail;
    }
    PyObject *arg_type;
    if (likely(PyObject_TypeCheck(obj_type, CPyType_rtypes___RType)))
        arg_type = obj_type;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_type); 
        goto fail;
    }
    PyObject *arg_identifier;
    if (likely(PyUnicode_Check(obj_identifier)))
        arg_identifier = obj_identifier;
    else {
        CPy_TypeError("str", obj_identifier); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    PyObject *arg_ann;
    if (obj_ann == NULL) {
        arg_ann = NULL;
    } else {
        arg_ann = obj_ann; 
    }
    char retval = CPyDef_ops___LoadGlobal_____init__(arg_self, arg_type, arg_identifier, arg_line, arg_ann);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1049, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadGlobal___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = PyList_New(0);
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1056, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___LoadGlobal___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadGlobal))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadGlobal", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadGlobal___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1055, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadGlobal___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 25, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_load_global */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1059, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___LoadGlobal___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadGlobal))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadGlobal", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadGlobal___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1058, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadGlobal_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___LoadGlobalObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___LoadGlobalObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___LoadGlobalObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___LoadGlobalObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___LoadGlobalObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___LoadGlobalObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    ((mypyc___ir___ops___LoadGlobalObject *)cpy_r___mypyc_self__)->_is_borrowed = 1;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___LoadGlobal_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___LoadGlobal))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadGlobal", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___LoadGlobal_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___IntOp_____init__(PyObject *cpy_r_self, PyObject *cpy_r_type, PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL5;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1105, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_INCREF(cpy_r_type);
    CPy_DECREF(((mypyc___ir___ops___IntOpObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___IntOpObject *)cpy_r_self)->_type = cpy_r_type;
    CPy_INCREF(cpy_r_lhs);
    ((mypyc___ir___ops___IntOpObject *)cpy_r_self)->_lhs = cpy_r_lhs;
    CPy_INCREF(cpy_r_rhs);
    ((mypyc___ir___ops___IntOpObject *)cpy_r_self)->_rhs = cpy_r_rhs;
    CPyTagged_INCREF(cpy_r_op);
    ((mypyc___ir___ops___IntOpObject *)cpy_r_self)->_op = cpy_r_op;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
CPyL5: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___IntOp_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"type", "lhs", "rhs", "op", "line", 0};
    PyObject *obj_type;
    PyObject *obj_lhs;
    PyObject *obj_rhs;
    PyObject *obj_op;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOOO|O", "__init__", kwlist, &obj_type, &obj_lhs, &obj_rhs, &obj_op, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___IntOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.IntOp", obj_self); 
        goto fail;
    }
    PyObject *arg_type;
    if (likely(PyObject_TypeCheck(obj_type, CPyType_rtypes___RType)))
        arg_type = obj_type;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_type); 
        goto fail;
    }
    PyObject *arg_lhs;
    if (likely(PyObject_TypeCheck(obj_lhs, CPyType_ops___Value)))
        arg_lhs = obj_lhs;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_lhs); 
        goto fail;
    }
    PyObject *arg_rhs;
    if (likely(PyObject_TypeCheck(obj_rhs, CPyType_ops___Value)))
        arg_rhs = obj_rhs;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_rhs); 
        goto fail;
    }
    CPyTagged arg_op;
    if (likely(PyLong_Check(obj_op)))
        arg_op = CPyTagged_BorrowFromObject(obj_op);
    else {
        CPy_TypeError("int", obj_op); goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___IntOp_____init__(arg_self, arg_type, arg_lhs, arg_rhs, arg_op, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1104, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___IntOp___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    CPyPtr cpy_r_r3;
    CPyPtr cpy_r_r4;
    CPyPtr cpy_r_r5;
    PyObject *cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___IntOpObject *)cpy_r_self)->_lhs;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = ((mypyc___ir___ops___IntOpObject *)cpy_r_self)->_rhs;
    CPy_INCREF(cpy_r_r1);
    cpy_r_r2 = PyList_New(2);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1112, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r3 = (CPyPtr)&((PyListObject *)cpy_r_r2)->ob_item;
    cpy_r_r4 = *(CPyPtr *)cpy_r_r3;
    *(PyObject * *)cpy_r_r4 = cpy_r_r0;
    cpy_r_r5 = cpy_r_r4 + 8;
    *(PyObject * *)cpy_r_r5 = cpy_r_r1;
    return cpy_r_r2;
CPyL2: ;
    cpy_r_r6 = NULL;
    return cpy_r_r6;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    CPy_DecRef(cpy_r_r1);
    goto CPyL2;
}

PyObject *CPyPy_ops___IntOp___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___IntOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.IntOp", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___IntOp___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1111, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___IntOp___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 26, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_int_op */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1115, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___IntOp___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___IntOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.IntOp", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___IntOp___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1114, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___IntOp_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject *cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    PyObject *cpy_r_r12;
    PyObject *cpy_r_r13;
    PyObject *cpy_r_r14;
    PyObject *cpy_r_r15;
    PyObject *cpy_r_r16;
    PyObject *cpy_r_r17;
    PyObject *cpy_r_r18;
    PyObject *cpy_r_r19;
    PyObject *cpy_r_r20;
    PyObject *cpy_r_r21;
    PyObject *cpy_r_r22;
    PyObject *cpy_r_r23;
    char cpy_r_r24;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL5;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_ADD = 0;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_SUB = 2;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_MUL = 4;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_DIV = 6;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_MOD = 8;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_AND = 400;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_OR = 402;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_XOR = 404;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_LEFT_SHIFT = 406;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_RIGHT_SHIFT = 408;
    cpy_r_r3 = CPyStatics[886]; /* '+' */
    cpy_r_r4 = CPyStatics[1198]; /* '-' */
    cpy_r_r5 = CPyStatics[282]; /* '*' */
    cpy_r_r6 = CPyStatics[1594]; /* '/' */
    cpy_r_r7 = CPyStatics[1183]; /* '%' */
    cpy_r_r8 = CPyStatics[1596]; /* '&' */
    cpy_r_r9 = CPyStatics[885]; /* '|' */
    cpy_r_r10 = CPyStatics[1597]; /* '^' */
    cpy_r_r11 = CPyStatics[1598]; /* '<<' */
    cpy_r_r12 = CPyStatics[1599]; /* '>>' */
    cpy_r_r13 = CPyStatics[9015]; /* 0 */
    cpy_r_r14 = CPyStatics[9016]; /* 1 */
    cpy_r_r15 = CPyStatics[9018]; /* 2 */
    cpy_r_r16 = CPyStatics[9026]; /* 3 */
    cpy_r_r17 = CPyStatics[9025]; /* 4 */
    cpy_r_r18 = CPyStatics[9048]; /* 200 */
    cpy_r_r19 = CPyStatics[9049]; /* 201 */
    cpy_r_r20 = CPyStatics[9050]; /* 202 */
    cpy_r_r21 = CPyStatics[9051]; /* 203 */
    cpy_r_r22 = CPyStatics[9052]; /* 204 */
    cpy_r_r23 = CPyDict_Build(10, cpy_r_r13, cpy_r_r3, cpy_r_r14, cpy_r_r4, cpy_r_r15, cpy_r_r5, cpy_r_r16, cpy_r_r6, cpy_r_r17, cpy_r_r7, cpy_r_r18, cpy_r_r8, cpy_r_r19, cpy_r_r9, cpy_r_r20, cpy_r_r10, cpy_r_r21, cpy_r_r11, cpy_r_r22, cpy_r_r12);
    if (cpy_r_r23 == NULL) goto CPyL5;
    ((mypyc___ir___ops___IntOpObject *)cpy_r___mypyc_self__)->_op_str = cpy_r_r23;
    return 1;
CPyL5: ;
    cpy_r_r24 = 2;
    return cpy_r_r24;
}

PyObject *CPyPy_ops___IntOp_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___IntOp))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.IntOp", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___IntOp_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___ComparisonOp_____init__(PyObject *cpy_r_self, PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL8;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1168, CPyStatic_ops___globals);
        goto CPyL7;
    }
    cpy_r_r1 = CPyStatic_rtypes___bit_rprimitive;
    if (likely(cpy_r_r1 != NULL)) goto CPyL6;
    PyErr_SetString(PyExc_NameError, "value for final name \"bit_rprimitive\" was not set");
    cpy_r_r2 = 0;
    if (unlikely(!cpy_r_r2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1169, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_Unreachable();
CPyL6: ;
    CPy_INCREF(cpy_r_r1);
    CPy_DECREF(((mypyc___ir___ops___ComparisonOpObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r_self)->_type = cpy_r_r1;
    CPy_INCREF(cpy_r_lhs);
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r_self)->_lhs = cpy_r_lhs;
    CPy_INCREF(cpy_r_rhs);
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r_self)->_rhs = cpy_r_rhs;
    CPyTagged_INCREF(cpy_r_op);
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r_self)->_op = cpy_r_op;
    return 1;
CPyL7: ;
    cpy_r_r4 = 2;
    return cpy_r_r4;
CPyL8: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___ComparisonOp_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"lhs", "rhs", "op", "line", 0};
    PyObject *obj_lhs;
    PyObject *obj_rhs;
    PyObject *obj_op;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO|O", "__init__", kwlist, &obj_lhs, &obj_rhs, &obj_op, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___ComparisonOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.ComparisonOp", obj_self); 
        goto fail;
    }
    PyObject *arg_lhs;
    if (likely(PyObject_TypeCheck(obj_lhs, CPyType_ops___Value)))
        arg_lhs = obj_lhs;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_lhs); 
        goto fail;
    }
    PyObject *arg_rhs;
    if (likely(PyObject_TypeCheck(obj_rhs, CPyType_ops___Value)))
        arg_rhs = obj_rhs;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_rhs); 
        goto fail;
    }
    CPyTagged arg_op;
    if (likely(PyLong_Check(obj_op)))
        arg_op = CPyTagged_BorrowFromObject(obj_op);
    else {
        CPy_TypeError("int", obj_op); goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___ComparisonOp_____init__(arg_self, arg_lhs, arg_rhs, arg_op, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1167, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___ComparisonOp___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    CPyPtr cpy_r_r3;
    CPyPtr cpy_r_r4;
    CPyPtr cpy_r_r5;
    PyObject *cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___ComparisonOpObject *)cpy_r_self)->_lhs;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = ((mypyc___ir___ops___ComparisonOpObject *)cpy_r_self)->_rhs;
    CPy_INCREF(cpy_r_r1);
    cpy_r_r2 = PyList_New(2);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1175, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r3 = (CPyPtr)&((PyListObject *)cpy_r_r2)->ob_item;
    cpy_r_r4 = *(CPyPtr *)cpy_r_r3;
    *(PyObject * *)cpy_r_r4 = cpy_r_r0;
    cpy_r_r5 = cpy_r_r4 + 8;
    *(PyObject * *)cpy_r_r5 = cpy_r_r1;
    return cpy_r_r2;
CPyL2: ;
    cpy_r_r6 = NULL;
    return cpy_r_r6;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    CPy_DecRef(cpy_r_r1);
    goto CPyL2;
}

PyObject *CPyPy_ops___ComparisonOp___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___ComparisonOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.ComparisonOp", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___ComparisonOp___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1174, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___ComparisonOp___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 27, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_comparison_op */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1178, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___ComparisonOp___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___ComparisonOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.ComparisonOp", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___ComparisonOp___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1177, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___ComparisonOp_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject *cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    PyObject *cpy_r_r12;
    PyObject *cpy_r_r13;
    PyObject *cpy_r_r14;
    PyObject *cpy_r_r15;
    PyObject *cpy_r_r16;
    PyObject *cpy_r_r17;
    PyObject *cpy_r_r18;
    PyObject *cpy_r_r19;
    PyObject *cpy_r_r20;
    PyObject *cpy_r_r21;
    PyObject *cpy_r_r22;
    PyObject *cpy_r_r23;
    PyObject *cpy_r_r24;
    PyObject *cpy_r_r25;
    PyObject *cpy_r_r26;
    PyObject *cpy_r_r27;
    PyObject *cpy_r_r28;
    PyObject *cpy_r_r29;
    PyObject *cpy_r_r30;
    PyObject *cpy_r_r31;
    PyObject *cpy_r_r32;
    PyObject *cpy_r_r33;
    PyObject *cpy_r_r34;
    PyObject *cpy_r_r35;
    PyObject *cpy_r_r36;
    PyObject *cpy_r_r37;
    PyObject *cpy_r_r38;
    PyObject *cpy_r_r39;
    PyObject *cpy_r_r40;
    PyObject *cpy_r_r41;
    PyObject *cpy_r_r42;
    PyObject *cpy_r_r43;
    PyObject *cpy_r_r44;
    PyObject *cpy_r_r45;
    PyObject *cpy_r_r46;
    PyObject *cpy_r_r47;
    PyObject *cpy_r_r48;
    PyObject *cpy_r_r49;
    char cpy_r_r50;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL7;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_EQ = 200;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_NEQ = 202;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_SLT = 204;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_SGT = 206;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_SLE = 208;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_SGE = 210;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_ULT = 212;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_UGT = 214;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_ULE = 216;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_UGE = 218;
    cpy_r_r3 = CPyStatics[860]; /* '==' */
    cpy_r_r4 = CPyStatics[863]; /* '!=' */
    cpy_r_r5 = CPyStatics[2465]; /* '<' */
    cpy_r_r6 = CPyStatics[840]; /* '>' */
    cpy_r_r7 = CPyStatics[2470]; /* '<=' */
    cpy_r_r8 = CPyStatics[2468]; /* '>=' */
    cpy_r_r9 = CPyStatics[2465]; /* '<' */
    cpy_r_r10 = CPyStatics[840]; /* '>' */
    cpy_r_r11 = CPyStatics[2470]; /* '<=' */
    cpy_r_r12 = CPyStatics[2468]; /* '>=' */
    cpy_r_r13 = CPyStatics[9029]; /* 100 */
    cpy_r_r14 = CPyStatics[9053]; /* 101 */
    cpy_r_r15 = CPyStatics[9054]; /* 102 */
    cpy_r_r16 = CPyStatics[9055]; /* 103 */
    cpy_r_r17 = CPyStatics[9056]; /* 104 */
    cpy_r_r18 = CPyStatics[9057]; /* 105 */
    cpy_r_r19 = CPyStatics[9058]; /* 106 */
    cpy_r_r20 = CPyStatics[9059]; /* 107 */
    cpy_r_r21 = CPyStatics[9060]; /* 108 */
    cpy_r_r22 = CPyStatics[9061]; /* 109 */
    cpy_r_r23 = CPyDict_Build(10, cpy_r_r13, cpy_r_r3, cpy_r_r14, cpy_r_r4, cpy_r_r15, cpy_r_r5, cpy_r_r16, cpy_r_r6, cpy_r_r17, cpy_r_r7, cpy_r_r18, cpy_r_r8, cpy_r_r19, cpy_r_r9, cpy_r_r20, cpy_r_r10, cpy_r_r21, cpy_r_r11, cpy_r_r22, cpy_r_r12);
    if (cpy_r_r23 == NULL) goto CPyL7;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_op_str = cpy_r_r23;
    cpy_r_r24 = CPyStatics[860]; /* '==' */
    cpy_r_r25 = CPyStatics[863]; /* '!=' */
    cpy_r_r26 = CPyStatics[2465]; /* '<' */
    cpy_r_r27 = CPyStatics[840]; /* '>' */
    cpy_r_r28 = CPyStatics[2470]; /* '<=' */
    cpy_r_r29 = CPyStatics[2468]; /* '>=' */
    cpy_r_r30 = CPyStatics[9029]; /* 100 */
    cpy_r_r31 = CPyStatics[9053]; /* 101 */
    cpy_r_r32 = CPyStatics[9054]; /* 102 */
    cpy_r_r33 = CPyStatics[9055]; /* 103 */
    cpy_r_r34 = CPyStatics[9056]; /* 104 */
    cpy_r_r35 = CPyStatics[9057]; /* 105 */
    cpy_r_r36 = CPyDict_Build(6, cpy_r_r24, cpy_r_r30, cpy_r_r25, cpy_r_r31, cpy_r_r26, cpy_r_r32, cpy_r_r27, cpy_r_r33, cpy_r_r28, cpy_r_r34, cpy_r_r29, cpy_r_r35);
    if (cpy_r_r36 == NULL) goto CPyL7;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_signed_ops = cpy_r_r36;
    cpy_r_r37 = CPyStatics[860]; /* '==' */
    cpy_r_r38 = CPyStatics[863]; /* '!=' */
    cpy_r_r39 = CPyStatics[2465]; /* '<' */
    cpy_r_r40 = CPyStatics[840]; /* '>' */
    cpy_r_r41 = CPyStatics[2470]; /* '<=' */
    cpy_r_r42 = CPyStatics[2468]; /* '>=' */
    cpy_r_r43 = CPyStatics[9029]; /* 100 */
    cpy_r_r44 = CPyStatics[9053]; /* 101 */
    cpy_r_r45 = CPyStatics[9058]; /* 106 */
    cpy_r_r46 = CPyStatics[9059]; /* 107 */
    cpy_r_r47 = CPyStatics[9060]; /* 108 */
    cpy_r_r48 = CPyStatics[9061]; /* 109 */
    cpy_r_r49 = CPyDict_Build(6, cpy_r_r37, cpy_r_r43, cpy_r_r38, cpy_r_r44, cpy_r_r39, cpy_r_r45, cpy_r_r40, cpy_r_r46, cpy_r_r41, cpy_r_r47, cpy_r_r42, cpy_r_r48);
    if (cpy_r_r49 == NULL) goto CPyL7;
    ((mypyc___ir___ops___ComparisonOpObject *)cpy_r___mypyc_self__)->_unsigned_ops = cpy_r_r49;
    return 1;
CPyL7: ;
    cpy_r_r50 = 2;
    return cpy_r_r50;
}

PyObject *CPyPy_ops___ComparisonOp_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___ComparisonOp))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.ComparisonOp", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___ComparisonOp_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___FloatOp_____init__(PyObject *cpy_r_self, PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL8;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1201, CPyStatic_ops___globals);
        goto CPyL7;
    }
    cpy_r_r1 = CPyStatic_rtypes___float_rprimitive;
    if (likely(cpy_r_r1 != NULL)) goto CPyL6;
    PyErr_SetString(PyExc_NameError, "value for final name \"float_rprimitive\" was not set");
    cpy_r_r2 = 0;
    if (unlikely(!cpy_r_r2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1202, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_Unreachable();
CPyL6: ;
    CPy_INCREF(cpy_r_r1);
    CPy_DECREF(((mypyc___ir___ops___FloatOpObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___FloatOpObject *)cpy_r_self)->_type = cpy_r_r1;
    CPy_INCREF(cpy_r_lhs);
    ((mypyc___ir___ops___FloatOpObject *)cpy_r_self)->_lhs = cpy_r_lhs;
    CPy_INCREF(cpy_r_rhs);
    ((mypyc___ir___ops___FloatOpObject *)cpy_r_self)->_rhs = cpy_r_rhs;
    CPyTagged_INCREF(cpy_r_op);
    ((mypyc___ir___ops___FloatOpObject *)cpy_r_self)->_op = cpy_r_op;
    return 1;
CPyL7: ;
    cpy_r_r4 = 2;
    return cpy_r_r4;
CPyL8: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___FloatOp_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"lhs", "rhs", "op", "line", 0};
    PyObject *obj_lhs;
    PyObject *obj_rhs;
    PyObject *obj_op;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO|O", "__init__", kwlist, &obj_lhs, &obj_rhs, &obj_op, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___FloatOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatOp", obj_self); 
        goto fail;
    }
    PyObject *arg_lhs;
    if (likely(PyObject_TypeCheck(obj_lhs, CPyType_ops___Value)))
        arg_lhs = obj_lhs;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_lhs); 
        goto fail;
    }
    PyObject *arg_rhs;
    if (likely(PyObject_TypeCheck(obj_rhs, CPyType_ops___Value)))
        arg_rhs = obj_rhs;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_rhs); 
        goto fail;
    }
    CPyTagged arg_op;
    if (likely(PyLong_Check(obj_op)))
        arg_op = CPyTagged_BorrowFromObject(obj_op);
    else {
        CPy_TypeError("int", obj_op); goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___FloatOp_____init__(arg_self, arg_lhs, arg_rhs, arg_op, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1200, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___FloatOp___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    CPyPtr cpy_r_r3;
    CPyPtr cpy_r_r4;
    CPyPtr cpy_r_r5;
    PyObject *cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___FloatOpObject *)cpy_r_self)->_lhs;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = ((mypyc___ir___ops___FloatOpObject *)cpy_r_self)->_rhs;
    CPy_INCREF(cpy_r_r1);
    cpy_r_r2 = PyList_New(2);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1208, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r3 = (CPyPtr)&((PyListObject *)cpy_r_r2)->ob_item;
    cpy_r_r4 = *(CPyPtr *)cpy_r_r3;
    *(PyObject * *)cpy_r_r4 = cpy_r_r0;
    cpy_r_r5 = cpy_r_r4 + 8;
    *(PyObject * *)cpy_r_r5 = cpy_r_r1;
    return cpy_r_r2;
CPyL2: ;
    cpy_r_r6 = NULL;
    return cpy_r_r6;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    CPy_DecRef(cpy_r_r1);
    goto CPyL2;
}

PyObject *CPyPy_ops___FloatOp___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___FloatOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatOp", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___FloatOp___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1207, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___FloatOp___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 28, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_float_op */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1211, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___FloatOp___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___FloatOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatOp", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___FloatOp___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1210, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___FloatOp_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject *cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    PyObject *cpy_r_r12;
    PyObject *cpy_r_r13;
    char cpy_r_r14;
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL5;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->_ADD = 0;
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->_SUB = 2;
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->_MUL = 4;
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->_DIV = 6;
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->_MOD = 8;
    cpy_r_r3 = CPyStatics[886]; /* '+' */
    cpy_r_r4 = CPyStatics[1198]; /* '-' */
    cpy_r_r5 = CPyStatics[282]; /* '*' */
    cpy_r_r6 = CPyStatics[1594]; /* '/' */
    cpy_r_r7 = CPyStatics[1183]; /* '%' */
    cpy_r_r8 = CPyStatics[9015]; /* 0 */
    cpy_r_r9 = CPyStatics[9016]; /* 1 */
    cpy_r_r10 = CPyStatics[9018]; /* 2 */
    cpy_r_r11 = CPyStatics[9026]; /* 3 */
    cpy_r_r12 = CPyStatics[9025]; /* 4 */
    cpy_r_r13 = CPyDict_Build(5, cpy_r_r8, cpy_r_r3, cpy_r_r9, cpy_r_r4, cpy_r_r10, cpy_r_r5, cpy_r_r11, cpy_r_r6, cpy_r_r12, cpy_r_r7);
    if (cpy_r_r13 == NULL) goto CPyL5;
    ((mypyc___ir___ops___FloatOpObject *)cpy_r___mypyc_self__)->_op_str = cpy_r_r13;
    return 1;
CPyL5: ;
    cpy_r_r14 = 2;
    return cpy_r_r14;
}

PyObject *CPyPy_ops___FloatOp_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___FloatOp))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatOp", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___FloatOp_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___FloatNeg_____init__(PyObject *cpy_r_self, PyObject *cpy_r_src, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL8;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1225, CPyStatic_ops___globals);
        goto CPyL7;
    }
    cpy_r_r1 = CPyStatic_rtypes___float_rprimitive;
    if (likely(cpy_r_r1 != NULL)) goto CPyL6;
    PyErr_SetString(PyExc_NameError, "value for final name \"float_rprimitive\" was not set");
    cpy_r_r2 = 0;
    if (unlikely(!cpy_r_r2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1226, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_Unreachable();
CPyL6: ;
    CPy_INCREF(cpy_r_r1);
    CPy_DECREF(((mypyc___ir___ops___FloatNegObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___FloatNegObject *)cpy_r_self)->_type = cpy_r_r1;
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___FloatNegObject *)cpy_r_self)->_src = cpy_r_src;
    return 1;
CPyL7: ;
    cpy_r_r4 = 2;
    return cpy_r_r4;
CPyL8: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___FloatNeg_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"src", "line", 0};
    PyObject *obj_src;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O|O", "__init__", kwlist, &obj_src, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___FloatNeg))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatNeg", obj_self); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___FloatNeg_____init__(arg_self, arg_src, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1224, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___FloatNeg___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___FloatNegObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1230, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___FloatNeg___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___FloatNeg))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatNeg", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___FloatNeg___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1229, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___FloatNeg___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 29, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_float_neg */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1233, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___FloatNeg___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___FloatNeg))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatNeg", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___FloatNeg___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1232, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___FloatNeg_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___FloatNegObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___FloatNegObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___FloatNegObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___FloatNegObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___FloatNegObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___FloatNegObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___FloatNeg_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___FloatNeg))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatNeg", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___FloatNeg_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___FloatComparisonOp_____init__(PyObject *cpy_r_self, PyObject *cpy_r_lhs, PyObject *cpy_r_rhs, CPyTagged cpy_r_op, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL8;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1251, CPyStatic_ops___globals);
        goto CPyL7;
    }
    cpy_r_r1 = CPyStatic_rtypes___bit_rprimitive;
    if (likely(cpy_r_r1 != NULL)) goto CPyL6;
    PyErr_SetString(PyExc_NameError, "value for final name \"bit_rprimitive\" was not set");
    cpy_r_r2 = 0;
    if (unlikely(!cpy_r_r2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1252, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_Unreachable();
CPyL6: ;
    CPy_INCREF(cpy_r_r1);
    CPy_DECREF(((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r_self)->_type = cpy_r_r1;
    CPy_INCREF(cpy_r_lhs);
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r_self)->_lhs = cpy_r_lhs;
    CPy_INCREF(cpy_r_rhs);
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r_self)->_rhs = cpy_r_rhs;
    CPyTagged_INCREF(cpy_r_op);
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r_self)->_op = cpy_r_op;
    return 1;
CPyL7: ;
    cpy_r_r4 = 2;
    return cpy_r_r4;
CPyL8: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___FloatComparisonOp_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"lhs", "rhs", "op", "line", 0};
    PyObject *obj_lhs;
    PyObject *obj_rhs;
    PyObject *obj_op;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO|O", "__init__", kwlist, &obj_lhs, &obj_rhs, &obj_op, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___FloatComparisonOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatComparisonOp", obj_self); 
        goto fail;
    }
    PyObject *arg_lhs;
    if (likely(PyObject_TypeCheck(obj_lhs, CPyType_ops___Value)))
        arg_lhs = obj_lhs;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_lhs); 
        goto fail;
    }
    PyObject *arg_rhs;
    if (likely(PyObject_TypeCheck(obj_rhs, CPyType_ops___Value)))
        arg_rhs = obj_rhs;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_rhs); 
        goto fail;
    }
    CPyTagged arg_op;
    if (likely(PyLong_Check(obj_op)))
        arg_op = CPyTagged_BorrowFromObject(obj_op);
    else {
        CPy_TypeError("int", obj_op); goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___FloatComparisonOp_____init__(arg_self, arg_lhs, arg_rhs, arg_op, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1250, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___FloatComparisonOp___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    CPyPtr cpy_r_r3;
    CPyPtr cpy_r_r4;
    CPyPtr cpy_r_r5;
    PyObject *cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r_self)->_lhs;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r_self)->_rhs;
    CPy_INCREF(cpy_r_r1);
    cpy_r_r2 = PyList_New(2);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1258, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r3 = (CPyPtr)&((PyListObject *)cpy_r_r2)->ob_item;
    cpy_r_r4 = *(CPyPtr *)cpy_r_r3;
    *(PyObject * *)cpy_r_r4 = cpy_r_r0;
    cpy_r_r5 = cpy_r_r4 + 8;
    *(PyObject * *)cpy_r_r5 = cpy_r_r1;
    return cpy_r_r2;
CPyL2: ;
    cpy_r_r6 = NULL;
    return cpy_r_r6;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    CPy_DecRef(cpy_r_r1);
    goto CPyL2;
}

PyObject *CPyPy_ops___FloatComparisonOp___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___FloatComparisonOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatComparisonOp", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___FloatComparisonOp___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1257, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___FloatComparisonOp___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 30, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_float_comparison_op */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1261, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___FloatComparisonOp___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___FloatComparisonOp))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatComparisonOp", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___FloatComparisonOp___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1260, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___FloatComparisonOp_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject *cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    PyObject *cpy_r_r12;
    PyObject *cpy_r_r13;
    PyObject *cpy_r_r14;
    PyObject *cpy_r_r15;
    char cpy_r_r16;
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL5;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_EQ = 400;
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_NEQ = 402;
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_LT = 404;
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_GT = 406;
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_LE = 408;
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_GE = 410;
    cpy_r_r3 = CPyStatics[860]; /* '==' */
    cpy_r_r4 = CPyStatics[863]; /* '!=' */
    cpy_r_r5 = CPyStatics[2465]; /* '<' */
    cpy_r_r6 = CPyStatics[840]; /* '>' */
    cpy_r_r7 = CPyStatics[2470]; /* '<=' */
    cpy_r_r8 = CPyStatics[2468]; /* '>=' */
    cpy_r_r9 = CPyStatics[9048]; /* 200 */
    cpy_r_r10 = CPyStatics[9049]; /* 201 */
    cpy_r_r11 = CPyStatics[9050]; /* 202 */
    cpy_r_r12 = CPyStatics[9051]; /* 203 */
    cpy_r_r13 = CPyStatics[9052]; /* 204 */
    cpy_r_r14 = CPyStatics[9062]; /* 205 */
    cpy_r_r15 = CPyDict_Build(6, cpy_r_r9, cpy_r_r3, cpy_r_r10, cpy_r_r4, cpy_r_r11, cpy_r_r5, cpy_r_r12, cpy_r_r6, cpy_r_r13, cpy_r_r7, cpy_r_r14, cpy_r_r8);
    if (cpy_r_r15 == NULL) goto CPyL5;
    ((mypyc___ir___ops___FloatComparisonOpObject *)cpy_r___mypyc_self__)->_op_str = cpy_r_r15;
    return 1;
CPyL5: ;
    cpy_r_r16 = 2;
    return cpy_r_r16;
}

PyObject *CPyPy_ops___FloatComparisonOp_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___FloatComparisonOp))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatComparisonOp", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___FloatComparisonOp_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadMem_____init__(PyObject *cpy_r_self, PyObject *cpy_r_type, PyObject *cpy_r_src, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    char cpy_r_r6;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL9;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1280, CPyStatic_ops___globals);
        goto CPyL8;
    }
    CPy_INCREF(cpy_r_type);
    CPy_DECREF(((mypyc___ir___ops___LoadMemObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___LoadMemObject *)cpy_r_self)->_type = cpy_r_type;
    cpy_r_r2 = ((mypyc___ir___ops___ValueObject *)cpy_r_src)->_type;
    CPy_INCREF(cpy_r_r2);
    cpy_r_r3 = CPyDef_rtypes___is_pointer_rprimitive(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(cpy_r_r3 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1284, CPyStatic_ops___globals);
        goto CPyL8;
    }
    if (cpy_r_r3) goto CPyL7;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r4 = 0;
    if (unlikely(!cpy_r_r4)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1284, CPyStatic_ops___globals);
        goto CPyL8;
    }
    CPy_Unreachable();
CPyL7: ;
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___LoadMemObject *)cpy_r_self)->_src = cpy_r_src;
    ((mypyc___ir___ops___LoadMemObject *)cpy_r_self)->_is_borrowed = 1;
    return 1;
CPyL8: ;
    cpy_r_r6 = 2;
    return cpy_r_r6;
CPyL9: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___LoadMem_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"type", "src", "line", 0};
    PyObject *obj_type;
    PyObject *obj_src;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OO|O", "__init__", kwlist, &obj_type, &obj_src, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadMem))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadMem", obj_self); 
        goto fail;
    }
    PyObject *arg_type;
    if (likely(PyObject_TypeCheck(obj_type, CPyType_rtypes___RType)))
        arg_type = obj_type;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_type); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___LoadMem_____init__(arg_self, arg_type, arg_src, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1279, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadMem___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___LoadMemObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1289, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___LoadMem___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadMem))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadMem", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadMem___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1288, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadMem___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 31, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_load_mem */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1292, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___LoadMem___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadMem))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadMem", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadMem___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1291, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadMem_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___LoadMemObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___LoadMemObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___LoadMemObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___LoadMemObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___LoadMemObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___LoadMemObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___LoadMem_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___LoadMem))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadMem", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___LoadMem_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___SetMem_____init__(PyObject *cpy_r_self, PyObject *cpy_r_type, PyObject *cpy_r_dest, PyObject *cpy_r_src, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL8;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___Op_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1307, CPyStatic_ops___globals);
        goto CPyL7;
    }
    cpy_r_r1 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r1 != NULL)) goto CPyL6;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r2 = 0;
    if (unlikely(!cpy_r_r2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1308, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_Unreachable();
CPyL6: ;
    CPy_INCREF(cpy_r_r1);
    CPy_DECREF(((mypyc___ir___ops___SetMemObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___SetMemObject *)cpy_r_self)->_type = cpy_r_r1;
    CPy_INCREF(cpy_r_type);
    ((mypyc___ir___ops___SetMemObject *)cpy_r_self)->_dest_type = cpy_r_type;
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___SetMemObject *)cpy_r_self)->_src = cpy_r_src;
    CPy_INCREF(cpy_r_dest);
    ((mypyc___ir___ops___SetMemObject *)cpy_r_self)->_dest = cpy_r_dest;
    return 1;
CPyL7: ;
    cpy_r_r4 = 2;
    return cpy_r_r4;
CPyL8: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___SetMem_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"type", "dest", "src", "line", 0};
    PyObject *obj_type;
    PyObject *obj_dest;
    PyObject *obj_src;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO|O", "__init__", kwlist, &obj_type, &obj_dest, &obj_src, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___SetMem))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.SetMem", obj_self); 
        goto fail;
    }
    PyObject *arg_type;
    if (likely(PyObject_TypeCheck(obj_type, CPyType_rtypes___RType)))
        arg_type = obj_type;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_type); 
        goto fail;
    }
    PyObject *arg_dest;
    if (likely(PyObject_TypeCheck(obj_dest, CPyType_ops___Value)))
        arg_dest = obj_dest;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_dest); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___SetMem_____init__(arg_self, arg_type, arg_dest, arg_src, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1306, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___SetMem___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    CPyPtr cpy_r_r3;
    CPyPtr cpy_r_r4;
    CPyPtr cpy_r_r5;
    PyObject *cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___SetMemObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = ((mypyc___ir___ops___SetMemObject *)cpy_r_self)->_dest;
    CPy_INCREF(cpy_r_r1);
    cpy_r_r2 = PyList_New(2);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1314, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r3 = (CPyPtr)&((PyListObject *)cpy_r_r2)->ob_item;
    cpy_r_r4 = *(CPyPtr *)cpy_r_r3;
    *(PyObject * *)cpy_r_r4 = cpy_r_r0;
    cpy_r_r5 = cpy_r_r4 + 8;
    *(PyObject * *)cpy_r_r5 = cpy_r_r1;
    return cpy_r_r2;
CPyL2: ;
    cpy_r_r6 = NULL;
    return cpy_r_r6;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    CPy_DecRef(cpy_r_r1);
    goto CPyL2;
}

PyObject *CPyPy_ops___SetMem___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___SetMem))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.SetMem", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___SetMem___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1313, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___SetMem___stolen(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___SetMemObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 1317, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___SetMem___stolen(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":stolen", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___SetMem))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.SetMem", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___SetMem___stolen(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "stolen", 1316, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___SetMem___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 32, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_set_mem */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1320, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___SetMem___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___SetMem))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.SetMem", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___SetMem___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1319, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___SetMem_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    ((mypyc___ir___ops___SetMemObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___SetMemObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___SetMemObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___SetMemObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
}

PyObject *CPyPy_ops___SetMem_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___SetMem))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.SetMem", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___SetMem_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___GetElementPtr_____init__(PyObject *cpy_r_self, PyObject *cpy_r_src, PyObject *cpy_r_src_type, PyObject *cpy_r_field, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL8;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1333, CPyStatic_ops___globals);
        goto CPyL7;
    }
    cpy_r_r1 = CPyStatic_rtypes___pointer_rprimitive;
    if (likely(cpy_r_r1 != NULL)) goto CPyL6;
    PyErr_SetString(PyExc_NameError, "value for final name \"pointer_rprimitive\" was not set");
    cpy_r_r2 = 0;
    if (unlikely(!cpy_r_r2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1334, CPyStatic_ops___globals);
        goto CPyL7;
    }
    CPy_Unreachable();
CPyL6: ;
    CPy_INCREF(cpy_r_r1);
    CPy_DECREF(((mypyc___ir___ops___GetElementPtrObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___GetElementPtrObject *)cpy_r_self)->_type = cpy_r_r1;
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___GetElementPtrObject *)cpy_r_self)->_src = cpy_r_src;
    CPy_INCREF(cpy_r_src_type);
    ((mypyc___ir___ops___GetElementPtrObject *)cpy_r_self)->_src_type = cpy_r_src_type;
    CPy_INCREF(cpy_r_field);
    ((mypyc___ir___ops___GetElementPtrObject *)cpy_r_self)->_field = cpy_r_field;
    return 1;
CPyL7: ;
    cpy_r_r4 = 2;
    return cpy_r_r4;
CPyL8: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___GetElementPtr_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"src", "src_type", "field", "line", 0};
    PyObject *obj_src;
    PyObject *obj_src_type;
    PyObject *obj_field;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OOO|O", "__init__", kwlist, &obj_src, &obj_src_type, &obj_field, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___GetElementPtr))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.GetElementPtr", obj_self); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyObject_TypeCheck(obj_src, CPyType_ops___Value)))
        arg_src = obj_src;
    else {
        CPy_TypeError("mypyc.ir.ops.Value", obj_src); 
        goto fail;
    }
    PyObject *arg_src_type;
    if (likely(PyObject_TypeCheck(obj_src_type, CPyType_rtypes___RType)))
        arg_src_type = obj_src_type;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_src_type); 
        goto fail;
    }
    PyObject *arg_field;
    if (likely(PyUnicode_Check(obj_field)))
        arg_field = obj_field;
    else {
        CPy_TypeError("str", obj_field); 
        goto fail;
    }
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___GetElementPtr_____init__(arg_self, arg_src, arg_src_type, arg_field, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1332, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___GetElementPtr___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    CPyPtr cpy_r_r3;
    PyObject *cpy_r_r4;
    cpy_r_r0 = ((mypyc___ir___ops___GetElementPtrObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = PyList_New(1);
    if (unlikely(cpy_r_r1 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1340, CPyStatic_ops___globals);
        goto CPyL3;
    }
    cpy_r_r2 = (CPyPtr)&((PyListObject *)cpy_r_r1)->ob_item;
    cpy_r_r3 = *(CPyPtr *)cpy_r_r2;
    *(PyObject * *)cpy_r_r3 = cpy_r_r0;
    return cpy_r_r1;
CPyL2: ;
    cpy_r_r4 = NULL;
    return cpy_r_r4;
CPyL3: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL2;
}

PyObject *CPyPy_ops___GetElementPtr___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___GetElementPtr))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.GetElementPtr", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___GetElementPtr___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1339, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___GetElementPtr___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 33, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_get_element_ptr */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1343, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___GetElementPtr___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___GetElementPtr))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.GetElementPtr", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___GetElementPtr___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1342, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___GetElementPtr_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___GetElementPtrObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___GetElementPtrObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___GetElementPtrObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___GetElementPtrObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___GetElementPtrObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___GetElementPtrObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___GetElementPtr_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___GetElementPtr))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.GetElementPtr", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___GetElementPtr_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadAddress_____init__(PyObject *cpy_r_self, PyObject *cpy_r_type, PyObject *cpy_r_src, CPyTagged cpy_r_line) {
    char cpy_r_r0;
    char cpy_r_r1;
    char cpy_r_r2;
    if (cpy_r_line != CPY_INT_TAG) goto CPyL5;
    cpy_r_line = -2;
CPyL2: ;
    cpy_r_r0 = CPyDef_ops___RegisterOp_____init__(cpy_r_self, cpy_r_line);
    CPyTagged_DECREF(cpy_r_line);
    if (unlikely(cpy_r_r0 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1360, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_INCREF(cpy_r_type);
    CPy_DECREF(((mypyc___ir___ops___LoadAddressObject *)cpy_r_self)->_type);
    ((mypyc___ir___ops___LoadAddressObject *)cpy_r_self)->_type = cpy_r_type;
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___LoadAddressObject *)cpy_r_self)->_src = cpy_r_src;
    return 1;
CPyL4: ;
    cpy_r_r2 = 2;
    return cpy_r_r2;
CPyL5: ;
    CPyTagged_INCREF(cpy_r_line);
    goto CPyL2;
}

PyObject *CPyPy_ops___LoadAddress_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"type", "src", "line", 0};
    PyObject *obj_type;
    PyObject *obj_src;
    PyObject *obj_line = NULL;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "OO|O", "__init__", kwlist, &obj_type, &obj_src, &obj_line)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadAddress))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadAddress", obj_self); 
        goto fail;
    }
    PyObject *arg_type;
    if (likely(PyObject_TypeCheck(obj_type, CPyType_rtypes___RType)))
        arg_type = obj_type;
    else {
        CPy_TypeError("mypyc.ir.rtypes.RType", obj_type); 
        goto fail;
    }
    PyObject *arg_src;
    if (PyUnicode_Check(obj_src))
        arg_src = obj_src;
    else {
        arg_src = NULL;
    }
    if (arg_src != NULL) goto __LL9873;
    if (Py_TYPE(obj_src) == CPyType_ops___Register)
        arg_src = obj_src;
    else {
        arg_src = NULL;
    }
    if (arg_src != NULL) goto __LL9873;
    if (Py_TYPE(obj_src) == CPyType_ops___LoadStatic)
        arg_src = obj_src;
    else {
        arg_src = NULL;
    }
    if (arg_src != NULL) goto __LL9873;
    CPy_TypeError("union[str, mypyc.ir.ops.Register, mypyc.ir.ops.LoadStatic]", obj_src); 
    goto fail;
__LL9873: ;
    CPyTagged arg_line;
    if (obj_line == NULL) {
        arg_line = CPY_INT_TAG;
    } else if (likely(PyLong_Check(obj_line)))
        arg_line = CPyTagged_BorrowFromObject(obj_line);
    else {
        CPy_TypeError("int", obj_line); goto fail;
    }
    char retval = CPyDef_ops___LoadAddress_____init__(arg_self, arg_type, arg_src, arg_line);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1359, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadAddress___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    CPyPtr cpy_r_r2;
    PyObject *cpy_r_r3;
    char cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    CPyPtr cpy_r_r8;
    CPyPtr cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    cpy_r_r0 = ((mypyc___ir___ops___LoadAddressObject *)cpy_r_self)->_src;
    cpy_r_r1 = (PyObject *)CPyType_ops___Register;
    cpy_r_r2 = (CPyPtr)&((PyObject *)cpy_r_r0)->ob_type;
    cpy_r_r3 = *(PyObject * *)cpy_r_r2;
    cpy_r_r4 = cpy_r_r3 == cpy_r_r1;
    if (!cpy_r_r4) goto CPyL4;
    cpy_r_r5 = ((mypyc___ir___ops___LoadAddressObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r5);
    if (likely(Py_TYPE(cpy_r_r5) == CPyType_ops___Register))
        cpy_r_r6 = cpy_r_r5;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "sources", 1366, CPyStatic_ops___globals, "mypyc.ir.ops.Register", cpy_r_r5);
        goto CPyL6;
    }
    cpy_r_r7 = PyList_New(1);
    if (unlikely(cpy_r_r7 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1366, CPyStatic_ops___globals);
        goto CPyL7;
    }
    cpy_r_r8 = (CPyPtr)&((PyListObject *)cpy_r_r7)->ob_item;
    cpy_r_r9 = *(CPyPtr *)cpy_r_r8;
    *(PyObject * *)cpy_r_r9 = cpy_r_r6;
    return cpy_r_r7;
CPyL4: ;
    cpy_r_r10 = PyList_New(0);
    if (unlikely(cpy_r_r10 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1368, CPyStatic_ops___globals);
        goto CPyL6;
    }
    return cpy_r_r10;
CPyL6: ;
    cpy_r_r11 = NULL;
    return cpy_r_r11;
CPyL7: ;
    CPy_DecRef(cpy_r_r6);
    goto CPyL6;
}

PyObject *CPyPy_ops___LoadAddress___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadAddress))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadAddress", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadAddress___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1364, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___LoadAddress___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 34, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_load_address */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1371, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___LoadAddress___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___LoadAddress))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadAddress", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___LoadAddress___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1370, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___LoadAddress_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___LoadAddressObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___LoadAddressObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___LoadAddressObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___LoadAddressObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___LoadAddressObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___LoadAddressObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    ((mypyc___ir___ops___LoadAddressObject *)cpy_r___mypyc_self__)->_is_borrowed = 1;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___LoadAddress_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___LoadAddress))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadAddress", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___LoadAddress_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___KeepAlive_____init__(PyObject *cpy_r_self, PyObject *cpy_r_src) {
    CPyPtr cpy_r_r0;
    int64_t cpy_r_r1;
    CPyTagged cpy_r_r2;
    char cpy_r_r3;
    char cpy_r_r4;
    char cpy_r_r5;
    cpy_r_r0 = (CPyPtr)&((PyVarObject *)cpy_r_src)->ob_size;
    cpy_r_r1 = *(int64_t *)cpy_r_r0;
    cpy_r_r2 = cpy_r_r1 << 1;
    cpy_r_r3 = cpy_r_r2 != 0;
    if (cpy_r_r3) goto CPyL3;
    PyErr_SetNone(PyExc_AssertionError);
    cpy_r_r4 = 0;
    if (unlikely(!cpy_r_r4)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1395, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_src);
    ((mypyc___ir___ops___KeepAliveObject *)cpy_r_self)->_src = cpy_r_src;
    return 1;
CPyL4: ;
    cpy_r_r5 = 2;
    return cpy_r_r5;
}

PyObject *CPyPy_ops___KeepAlive_____init__(PyObject *self, PyObject *args, PyObject *kw) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"src", 0};
    PyObject *obj_src;
    if (!CPyArg_ParseTupleAndKeywords(args, kw, "O", "__init__", kwlist, &obj_src)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___KeepAlive))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.KeepAlive", obj_self); 
        goto fail;
    }
    PyObject *arg_src;
    if (likely(PyList_Check(obj_src)))
        arg_src = obj_src;
    else {
        CPy_TypeError("list", obj_src); 
        goto fail;
    }
    char retval = CPyDef_ops___KeepAlive_____init__(arg_self, arg_src);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = Py_None;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__init__", 1394, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___KeepAlive___sources(PyObject *cpy_r_self) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject **cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    cpy_r_r0 = ((mypyc___ir___ops___KeepAliveObject *)cpy_r_self)->_src;
    CPy_INCREF(cpy_r_r0);
    cpy_r_r1 = CPyStatics[362]; /* 'copy' */
    PyObject *cpy_r_r2[1] = {cpy_r_r0};
    cpy_r_r3 = (PyObject **)&cpy_r_r2;
    cpy_r_r4 = PyObject_VectorcallMethod(cpy_r_r1, cpy_r_r3, 9223372036854775809ULL, 0);
    if (unlikely(cpy_r_r4 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1399, CPyStatic_ops___globals);
        goto CPyL4;
    }
    CPy_DECREF(cpy_r_r0);
    if (likely(PyList_Check(cpy_r_r4)))
        cpy_r_r5 = cpy_r_r4;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "sources", 1399, CPyStatic_ops___globals, "list", cpy_r_r4);
        goto CPyL3;
    }
    return cpy_r_r5;
CPyL3: ;
    cpy_r_r6 = NULL;
    return cpy_r_r6;
CPyL4: ;
    CPy_DecRef(cpy_r_r0);
    goto CPyL3;
}

PyObject *CPyPy_ops___KeepAlive___sources(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":sources", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___KeepAlive))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.KeepAlive", obj_self); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___KeepAlive___sources(arg_self);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "sources", 1398, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___KeepAlive___accept(PyObject *cpy_r_self, PyObject *cpy_r_visitor) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    cpy_r_r0 = CPY_GET_METHOD_TRAIT(cpy_r_visitor, CPyType_ops___OpVisitor, 35, mypyc___ir___ops___OpVisitorObject, PyObject * (*)(PyObject *, PyObject *))(cpy_r_visitor, cpy_r_self); /* visit_keep_alive */
    if (unlikely(cpy_r_r0 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1402, CPyStatic_ops___globals);
        goto CPyL2;
    }
    return cpy_r_r0;
CPyL2: ;
    cpy_r_r1 = NULL;
    return cpy_r_r1;
}

PyObject *CPyPy_ops___KeepAlive___accept(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"visitor", 0};
    static CPyArg_Parser parser = {"O:accept", kwlist, 0};
    PyObject *obj_visitor;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_visitor)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(Py_TYPE(obj_self) == CPyType_ops___KeepAlive))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.KeepAlive", obj_self); 
        goto fail;
    }
    PyObject *arg_visitor;
    if (likely(PyObject_TypeCheck(obj_visitor, CPyType_ops___OpVisitor)))
        arg_visitor = obj_visitor;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_visitor); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___KeepAlive___accept(arg_self, arg_visitor);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "accept", 1401, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops___KeepAlive_____mypyc_defaults_setup(PyObject *cpy_r___mypyc_self__) {
    PyObject *cpy_r_r0;
    char cpy_r_r1;
    PyObject *cpy_r_r2;
    char cpy_r_r3;
    ((mypyc___ir___ops___KeepAliveObject *)cpy_r___mypyc_self__)->_line = -2;
    cpy_r_r0 = CPyStatic_rtypes___void_rtype;
    if (likely(cpy_r_r0 != NULL)) goto CPyL3;
    PyErr_SetString(PyExc_NameError, "value for final name \"void_rtype\" was not set");
    cpy_r_r1 = 0;
    if (!cpy_r_r1) goto CPyL4;
    CPy_Unreachable();
CPyL3: ;
    CPy_INCREF(cpy_r_r0);
    ((mypyc___ir___ops___KeepAliveObject *)cpy_r___mypyc_self__)->_type = cpy_r_r0;
    ((mypyc___ir___ops___KeepAliveObject *)cpy_r___mypyc_self__)->_is_borrowed = 0;
    ((mypyc___ir___ops___KeepAliveObject *)cpy_r___mypyc_self__)->_error_kind = -2;
    cpy_r_r2 = Py_None;
    CPy_INCREF(cpy_r_r2);
    ((mypyc___ir___ops___KeepAliveObject *)cpy_r___mypyc_self__)->__type = cpy_r_r2;
    ((mypyc___ir___ops___KeepAliveObject *)cpy_r___mypyc_self__)->_error_kind = 0;
    return 1;
CPyL4: ;
    cpy_r_r3 = 2;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___KeepAlive_____mypyc_defaults_setup(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj___mypyc_self__ = self;
    static const char * const kwlist[] = {0};
    static CPyArg_Parser parser = {":__mypyc_defaults_setup", kwlist, 0};
    if (!CPyArg_ParseStackAndKeywordsNoArgs(args, nargs, kwnames, &parser)) {
        return NULL;
    }
    PyObject *arg___mypyc_self__;
    if (likely(Py_TYPE(obj___mypyc_self__) == CPyType_ops___KeepAlive))
        arg___mypyc_self__ = obj___mypyc_self__;
    else {
        CPy_TypeError("mypyc.ir.ops.KeepAlive", obj___mypyc_self__); 
        goto fail;
    }
    char retval = CPyDef_ops___KeepAlive_____mypyc_defaults_setup(arg___mypyc_self__);
    if (retval == 2) {
        return NULL;
    }
    PyObject *retbox = retval ? Py_True : Py_False;
    CPy_INCREF(retbox);
    return retbox;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "__mypyc_defaults_setup", -1, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_goto(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_goto", 1411, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_goto", 1411, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_goto(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_goto", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___Goto))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.Goto", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_goto(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_goto", 1410, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_branch(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_branch", 1415, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_branch", 1415, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_branch(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_branch", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___Branch))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.Branch", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_branch(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_branch", 1414, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_return(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_return", 1419, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_return", 1419, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_return(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_return", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___Return))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.Return", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_return(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_return", 1418, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_unreachable(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_unreachable", 1423, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_unreachable", 1423, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_unreachable(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_unreachable", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___Unreachable))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.Unreachable", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_unreachable(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_unreachable", 1422, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_assign(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_assign", 1427, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_assign", 1427, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_assign(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_assign", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___Assign))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.Assign", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_assign(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_assign", 1426, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_assign_multi(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_assign_multi", 1431, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_assign_multi", 1431, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_assign_multi(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_assign_multi", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___AssignMulti))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.AssignMulti", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_assign_multi(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_assign_multi", 1430, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_load_error_value(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_error_value", 1435, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_error_value", 1435, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_load_error_value(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_load_error_value", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___LoadErrorValue))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadErrorValue", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_load_error_value(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_error_value", 1434, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_load_literal(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_literal", 1439, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_literal", 1439, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_load_literal(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_load_literal", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___LoadLiteral))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadLiteral", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_load_literal(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_literal", 1438, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_get_attr(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_get_attr", 1443, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_get_attr", 1443, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_get_attr(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_get_attr", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___GetAttr))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.GetAttr", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_get_attr(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_get_attr", 1442, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_set_attr(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_set_attr", 1447, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_set_attr", 1447, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_set_attr(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_set_attr", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___SetAttr))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.SetAttr", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_set_attr(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_set_attr", 1446, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_load_static(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_static", 1451, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_static", 1451, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_load_static(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_load_static", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___LoadStatic))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadStatic", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_load_static(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_static", 1450, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_init_static(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_init_static", 1455, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_init_static", 1455, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_init_static(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_init_static", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___InitStatic))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.InitStatic", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_init_static(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_init_static", 1454, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_tuple_get(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_tuple_get", 1459, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_tuple_get", 1459, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_tuple_get(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_tuple_get", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___TupleGet))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.TupleGet", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_tuple_get(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_tuple_get", 1458, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_tuple_set(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_tuple_set", 1463, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_tuple_set", 1463, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_tuple_set(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_tuple_set", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___TupleSet))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.TupleSet", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_tuple_set(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_tuple_set", 1462, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_inc_ref(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_inc_ref", 1466, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_inc_ref", 1466, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_inc_ref(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_inc_ref", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___IncRef))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.IncRef", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_inc_ref(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_inc_ref", 1465, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_dec_ref(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_dec_ref", 1469, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_dec_ref", 1469, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_dec_ref(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_dec_ref", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___DecRef))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.DecRef", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_dec_ref(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_dec_ref", 1468, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_call(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_call", 1473, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_call", 1473, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_call(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_call", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___Call))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.Call", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_call(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_call", 1472, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_method_call(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_method_call", 1477, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_method_call", 1477, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_method_call(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_method_call", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___MethodCall))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.MethodCall", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_method_call(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_method_call", 1476, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_cast(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_cast", 1481, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_cast", 1481, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_cast(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_cast", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___Cast))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.Cast", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_cast(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_cast", 1480, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_box(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_box", 1485, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_box", 1485, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_box(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_box", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___Box))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.Box", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_box(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_box", 1484, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_unbox(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_unbox", 1489, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_unbox", 1489, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_unbox(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_unbox", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___Unbox))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.Unbox", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_unbox(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_unbox", 1488, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_raise_standard_error(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_raise_standard_error", 1493, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_raise_standard_error", 1493, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_raise_standard_error(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_raise_standard_error", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___RaiseStandardError))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.RaiseStandardError", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_raise_standard_error(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_raise_standard_error", 1492, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_call_c(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_call_c", 1497, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_call_c", 1497, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_call_c(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_call_c", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___CallC))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.CallC", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_call_c(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_call_c", 1496, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_truncate(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_truncate", 1501, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_truncate", 1501, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_truncate(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_truncate", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___Truncate))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.Truncate", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_truncate(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_truncate", 1500, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_extend(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_extend", 1505, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_extend", 1505, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_extend(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_extend", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___Extend))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.Extend", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_extend(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_extend", 1504, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_load_global(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_global", 1509, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_global", 1509, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_load_global(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_load_global", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___LoadGlobal))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadGlobal", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_load_global(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_global", 1508, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_int_op(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_int_op", 1513, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_int_op", 1513, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_int_op(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_int_op", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___IntOp))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.IntOp", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_int_op(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_int_op", 1512, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_comparison_op(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_comparison_op", 1517, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_comparison_op", 1517, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_comparison_op(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_comparison_op", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___ComparisonOp))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.ComparisonOp", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_comparison_op(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_comparison_op", 1516, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_float_op(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_float_op", 1521, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_float_op", 1521, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_float_op(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_float_op", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___FloatOp))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatOp", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_float_op(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_float_op", 1520, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_float_neg(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_float_neg", 1525, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_float_neg", 1525, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_float_neg(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_float_neg", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___FloatNeg))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatNeg", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_float_neg(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_float_neg", 1524, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_float_comparison_op(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_float_comparison_op", 1529, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_float_comparison_op", 1529, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_float_comparison_op(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_float_comparison_op", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___FloatComparisonOp))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.FloatComparisonOp", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_float_comparison_op(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_float_comparison_op", 1528, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_load_mem(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_mem", 1533, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_mem", 1533, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_load_mem(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_load_mem", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___LoadMem))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadMem", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_load_mem(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_mem", 1532, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_set_mem(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_set_mem", 1537, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_set_mem", 1537, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_set_mem(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_set_mem", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___SetMem))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.SetMem", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_set_mem(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_set_mem", 1536, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_get_element_ptr(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_get_element_ptr", 1541, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_get_element_ptr", 1541, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_get_element_ptr(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_get_element_ptr", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___GetElementPtr))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.GetElementPtr", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_get_element_ptr(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_get_element_ptr", 1540, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_load_address(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_address", 1545, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_address", 1545, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_load_address(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_load_address", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___LoadAddress))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.LoadAddress", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_load_address(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_load_address", 1544, CPyStatic_ops___globals);
    return NULL;
}

PyObject *CPyDef_ops___OpVisitor___visit_keep_alive(PyObject *cpy_r_self, PyObject *cpy_r_op) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    PyObject *cpy_r_r2;
    PyObject *cpy_r_r3;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = CPyStatics[1325]; /* 'NotImplementedError' */
    cpy_r_r2 = CPyObject_GetAttr(cpy_r_r0, cpy_r_r1);
    if (unlikely(cpy_r_r2 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_keep_alive", 1549, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Raise(cpy_r_r2);
    CPy_DECREF(cpy_r_r2);
    if (unlikely(!0)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "visit_keep_alive", 1549, CPyStatic_ops___globals);
        goto CPyL3;
    }
    CPy_Unreachable();
CPyL3: ;
    cpy_r_r3 = NULL;
    return cpy_r_r3;
}

PyObject *CPyPy_ops___OpVisitor___visit_keep_alive(PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames) {
    PyObject *obj_self = self;
    static const char * const kwlist[] = {"op", 0};
    static CPyArg_Parser parser = {"O:visit_keep_alive", kwlist, 0};
    PyObject *obj_op;
    if (!CPyArg_ParseStackAndKeywordsOneArg(args, nargs, kwnames, &parser, &obj_op)) {
        return NULL;
    }
    PyObject *arg_self;
    if (likely(PyObject_TypeCheck(obj_self, CPyType_ops___OpVisitor)))
        arg_self = obj_self;
    else {
        CPy_TypeError("mypyc.ir.ops.OpVisitor", obj_self); 
        goto fail;
    }
    PyObject *arg_op;
    if (likely(Py_TYPE(obj_op) == CPyType_ops___KeepAlive))
        arg_op = obj_op;
    else {
        CPy_TypeError("mypyc.ir.ops.KeepAlive", obj_op); 
        goto fail;
    }
    PyObject *retval = CPyDef_ops___OpVisitor___visit_keep_alive(arg_self, arg_op);
    return retval;
fail: ;
    CPy_AddTraceback("mypyc/ir/ops.py", "visit_keep_alive", 1548, CPyStatic_ops___globals);
    return NULL;
}

char CPyDef_ops_____top_level__(void) {
    PyObject *cpy_r_r0;
    PyObject *cpy_r_r1;
    char cpy_r_r2;
    PyObject *cpy_r_r3;
    PyObject *cpy_r_r4;
    PyObject *cpy_r_r5;
    PyObject *cpy_r_r6;
    PyObject *cpy_r_r7;
    PyObject *cpy_r_r8;
    PyObject *cpy_r_r9;
    PyObject *cpy_r_r10;
    PyObject *cpy_r_r11;
    PyObject *cpy_r_r12;
    PyObject *cpy_r_r13;
    PyObject *cpy_r_r14;
    PyObject *cpy_r_r15;
    PyObject *cpy_r_r16;
    PyObject *cpy_r_r17;
    PyObject *cpy_r_r18;
    PyObject *cpy_r_r19;
    PyObject *cpy_r_r20;
    PyObject *cpy_r_r21;
    PyObject *cpy_r_r22;
    PyObject *cpy_r_r23;
    PyObject *cpy_r_r24;
    PyObject *cpy_r_r25;
    PyObject *cpy_r_r26;
    PyObject *cpy_r_r27;
    char cpy_r_r28;
    PyObject *cpy_r_r29;
    PyObject *cpy_r_r30;
    PyObject *cpy_r_r31;
    PyObject *cpy_r_r32;
    PyObject **cpy_r_r34;
    PyObject *cpy_r_r35;
    PyObject *cpy_r_r36;
    PyObject *cpy_r_r37;
    int32_t cpy_r_r38;
    char cpy_r_r39;
    PyObject *cpy_r_r40;
    PyObject *cpy_r_r41;
    PyObject *cpy_r_r42;
    PyObject *cpy_r_r43;
    char cpy_r_r44;
    PyObject *cpy_r_r45;
    PyObject *cpy_r_r46;
    PyObject *cpy_r_r47;
    PyObject *cpy_r_r48;
    PyObject *cpy_r_r49;
    PyObject *cpy_r_r50;
    int32_t cpy_r_r51;
    char cpy_r_r52;
    PyObject *cpy_r_r53;
    PyObject *cpy_r_r54;
    int32_t cpy_r_r55;
    char cpy_r_r56;
    PyObject *cpy_r_r57;
    PyObject *cpy_r_r58;
    PyObject *cpy_r_r59;
    int32_t cpy_r_r60;
    char cpy_r_r61;
    PyObject *cpy_r_r62;
    PyObject *cpy_r_r63;
    PyObject *cpy_r_r64;
    int32_t cpy_r_r65;
    char cpy_r_r66;
    PyObject *cpy_r_r67;
    PyObject *cpy_r_r68;
    PyObject *cpy_r_r69;
    int32_t cpy_r_r70;
    char cpy_r_r71;
    PyObject *cpy_r_r72;
    PyObject *cpy_r_r73;
    PyObject *cpy_r_r74;
    int32_t cpy_r_r75;
    char cpy_r_r76;
    PyObject *cpy_r_r77;
    PyObject *cpy_r_r78;
    PyObject *cpy_r_r79;
    int32_t cpy_r_r80;
    char cpy_r_r81;
    PyObject *cpy_r_r82;
    PyObject *cpy_r_r83;
    PyObject *cpy_r_r84;
    int32_t cpy_r_r85;
    char cpy_r_r86;
    PyObject *cpy_r_r87;
    PyObject *cpy_r_r88;
    PyObject *cpy_r_r89;
    PyObject *cpy_r_r90;
    char cpy_r_r91;
    PyObject *cpy_r_r92;
    PyObject *cpy_r_r93;
    PyObject *cpy_r_r94;
    PyObject *cpy_r_r95;
    PyObject *cpy_r_r96;
    int32_t cpy_r_r97;
    char cpy_r_r98;
    PyObject *cpy_r_r99;
    PyObject *cpy_r_r100;
    int32_t cpy_r_r101;
    char cpy_r_r102;
    PyObject *cpy_r_r103;
    PyObject *cpy_r_r104;
    PyObject *cpy_r_r105;
    PyObject *cpy_r_r106;
    PyObject *cpy_r_r107;
    char cpy_r_r108;
    PyObject *cpy_r_r109;
    PyObject *cpy_r_r110;
    PyObject *cpy_r_r111;
    PyObject *cpy_r_r112;
    PyObject *cpy_r_r113;
    PyObject *cpy_r_r114;
    PyObject *cpy_r_r115;
    int32_t cpy_r_r116;
    char cpy_r_r117;
    PyObject *cpy_r_r118;
    PyObject *cpy_r_r119;
    int32_t cpy_r_r120;
    char cpy_r_r121;
    PyObject *cpy_r_r122;
    PyObject *cpy_r_r123;
    PyObject *cpy_r_r124;
    PyObject *cpy_r_r125;
    PyObject *cpy_r_r126;
    char cpy_r_r127;
    PyObject *cpy_r_r128;
    PyObject *cpy_r_r129;
    PyObject *cpy_r_r130;
    PyObject *cpy_r_r131;
    PyObject *cpy_r_r132;
    PyObject *cpy_r_r133;
    int32_t cpy_r_r134;
    char cpy_r_r135;
    PyObject *cpy_r_r136;
    PyObject *cpy_r_r137;
    int32_t cpy_r_r138;
    char cpy_r_r139;
    PyObject *cpy_r_r140;
    PyObject *cpy_r_r141;
    PyObject *cpy_r_r142;
    PyObject *cpy_r_r143;
    PyObject *cpy_r_r144;
    char cpy_r_r145;
    PyObject *cpy_r_r146;
    PyObject *cpy_r_r147;
    PyObject *cpy_r_r148;
    PyObject *cpy_r_r149;
    PyObject *cpy_r_r150;
    PyObject *cpy_r_r151;
    int32_t cpy_r_r152;
    char cpy_r_r153;
    PyObject *cpy_r_r154;
    PyObject *cpy_r_r155;
    int32_t cpy_r_r156;
    char cpy_r_r157;
    PyObject *cpy_r_r158;
    PyObject *cpy_r_r159;
    PyObject *cpy_r_r160;
    PyObject *cpy_r_r161;
    PyObject *cpy_r_r162;
    char cpy_r_r163;
    PyObject *cpy_r_r164;
    PyObject *cpy_r_r165;
    PyObject *cpy_r_r166;
    PyObject *cpy_r_r167;
    PyObject *cpy_r_r168;
    int32_t cpy_r_r169;
    char cpy_r_r170;
    PyObject *cpy_r_r171;
    PyObject *cpy_r_r172;
    int32_t cpy_r_r173;
    char cpy_r_r174;
    PyObject *cpy_r_r175;
    PyObject *cpy_r_r176;
    PyObject *cpy_r_r177;
    PyObject *cpy_r_r178;
    PyObject *cpy_r_r179;
    char cpy_r_r180;
    PyObject *cpy_r_r181;
    PyObject *cpy_r_r182;
    PyObject *cpy_r_r183;
    PyObject *cpy_r_r184;
    PyObject *cpy_r_r185;
    PyObject *cpy_r_r186;
    int32_t cpy_r_r187;
    char cpy_r_r188;
    PyObject *cpy_r_r189;
    PyObject *cpy_r_r190;
    int32_t cpy_r_r191;
    char cpy_r_r192;
    PyObject *cpy_r_r193;
    PyObject *cpy_r_r194;
    PyObject *cpy_r_r195;
    PyObject *cpy_r_r196;
    PyObject *cpy_r_r197;
    char cpy_r_r198;
    PyObject *cpy_r_r199;
    PyObject *cpy_r_r200;
    PyObject *cpy_r_r201;
    PyObject *cpy_r_r202;
    PyObject *cpy_r_r203;
    PyObject *cpy_r_r204;
    PyObject *cpy_r_r205;
    PyObject *cpy_r_r206;
    int32_t cpy_r_r207;
    char cpy_r_r208;
    PyObject *cpy_r_r209;
    PyObject *cpy_r_r210;
    int32_t cpy_r_r211;
    char cpy_r_r212;
    PyObject *cpy_r_r213;
    PyObject *cpy_r_r214;
    PyObject *cpy_r_r215;
    PyObject *cpy_r_r216;
    PyObject *cpy_r_r217;
    char cpy_r_r218;
    PyObject *cpy_r_r219;
    PyObject *cpy_r_r220;
    PyObject *cpy_r_r221;
    PyObject *cpy_r_r222;
    PyObject *cpy_r_r223;
    PyObject *cpy_r_r224;
    PyObject *cpy_r_r225;
    PyObject *cpy_r_r226;
    int32_t cpy_r_r227;
    char cpy_r_r228;
    PyObject *cpy_r_r229;
    PyObject *cpy_r_r230;
    int32_t cpy_r_r231;
    char cpy_r_r232;
    PyObject *cpy_r_r233;
    PyObject *cpy_r_r234;
    PyObject *cpy_r_r235;
    PyObject *cpy_r_r236;
    PyObject *cpy_r_r237;
    char cpy_r_r238;
    PyObject *cpy_r_r239;
    PyObject *cpy_r_r240;
    PyObject *cpy_r_r241;
    PyObject *cpy_r_r242;
    PyObject *cpy_r_r243;
    int32_t cpy_r_r244;
    char cpy_r_r245;
    PyObject *cpy_r_r246;
    PyObject *cpy_r_r247;
    int32_t cpy_r_r248;
    char cpy_r_r249;
    PyObject *cpy_r_r250;
    PyObject *cpy_r_r251;
    PyObject *cpy_r_r252;
    PyObject *cpy_r_r253;
    PyObject *cpy_r_r254;
    char cpy_r_r255;
    PyObject *cpy_r_r256;
    PyObject *cpy_r_r257;
    PyObject *cpy_r_r258;
    PyObject *cpy_r_r259;
    PyObject *cpy_r_r260;
    PyObject *cpy_r_r261;
    PyObject *cpy_r_r262;
    int32_t cpy_r_r263;
    char cpy_r_r264;
    PyObject *cpy_r_r265;
    PyObject *cpy_r_r266;
    int32_t cpy_r_r267;
    char cpy_r_r268;
    PyObject *cpy_r_r269;
    PyObject *cpy_r_r270;
    PyObject *cpy_r_r271;
    PyObject *cpy_r_r272;
    PyObject *cpy_r_r273;
    char cpy_r_r274;
    PyObject *cpy_r_r275;
    PyObject *cpy_r_r276;
    PyObject *cpy_r_r277;
    PyObject *cpy_r_r278;
    PyObject *cpy_r_r279;
    PyObject *cpy_r_r280;
    PyObject *cpy_r_r281;
    PyObject *cpy_r_r282;
    PyObject *cpy_r_r283;
    PyObject *cpy_r_r284;
    PyObject *cpy_r_r285;
    PyObject *cpy_r_r286;
    PyObject *cpy_r_r287;
    PyObject *cpy_r_r288;
    PyObject *cpy_r_r289;
    int32_t cpy_r_r290;
    char cpy_r_r291;
    PyObject *cpy_r_r292;
    PyObject *cpy_r_r293;
    int32_t cpy_r_r294;
    char cpy_r_r295;
    PyObject *cpy_r_r296;
    PyObject *cpy_r_r297;
    PyObject *cpy_r_r298;
    int32_t cpy_r_r299;
    char cpy_r_r300;
    PyObject *cpy_r_r301;
    PyObject *cpy_r_r302;
    PyObject *cpy_r_r303;
    int32_t cpy_r_r304;
    char cpy_r_r305;
    PyObject *cpy_r_r306;
    PyObject *cpy_r_r307;
    PyObject *cpy_r_r308;
    PyObject *cpy_r_r309;
    PyObject *cpy_r_r310;
    char cpy_r_r311;
    PyObject *cpy_r_r312;
    PyObject *cpy_r_r313;
    PyObject *cpy_r_r314;
    PyObject *cpy_r_r315;
    PyObject *cpy_r_r316;
    PyObject *cpy_r_r317;
    PyObject *cpy_r_r318;
    int32_t cpy_r_r319;
    char cpy_r_r320;
    PyObject *cpy_r_r321;
    PyObject *cpy_r_r322;
    int32_t cpy_r_r323;
    char cpy_r_r324;
    PyObject *cpy_r_r325;
    PyObject *cpy_r_r326;
    PyObject *cpy_r_r327;
    PyObject *cpy_r_r328;
    PyObject *cpy_r_r329;
    char cpy_r_r330;
    PyObject *cpy_r_r331;
    PyObject *cpy_r_r332;
    PyObject *cpy_r_r333;
    PyObject *cpy_r_r334;
    PyObject *cpy_r_r335;
    PyObject *cpy_r_r336;
    int32_t cpy_r_r337;
    char cpy_r_r338;
    PyObject *cpy_r_r339;
    PyObject *cpy_r_r340;
    int32_t cpy_r_r341;
    char cpy_r_r342;
    PyObject *cpy_r_r343;
    PyObject *cpy_r_r344;
    PyObject *cpy_r_r345;
    PyObject *cpy_r_r346;
    PyObject *cpy_r_r347;
    char cpy_r_r348;
    PyObject *cpy_r_r349;
    PyObject *cpy_r_r350;
    PyObject *cpy_r_r351;
    PyObject *cpy_r_r352;
    PyObject *cpy_r_r353;
    PyObject *cpy_r_r354;
    PyObject *cpy_r_r355;
    int32_t cpy_r_r356;
    char cpy_r_r357;
    PyObject *cpy_r_r358;
    PyObject *cpy_r_r359;
    int32_t cpy_r_r360;
    char cpy_r_r361;
    PyObject *cpy_r_r362;
    PyObject *cpy_r_r363;
    PyObject *cpy_r_r364;
    PyObject *cpy_r_r365;
    PyObject *cpy_r_r366;
    char cpy_r_r367;
    PyObject *cpy_r_r368;
    PyObject *cpy_r_r369;
    PyObject *cpy_r_r370;
    PyObject *cpy_r_r371;
    PyObject *cpy_r_r372;
    PyObject *cpy_r_r373;
    PyObject *cpy_r_r374;
    PyObject *cpy_r_r375;
    PyObject *cpy_r_r376;
    int32_t cpy_r_r377;
    char cpy_r_r378;
    PyObject *cpy_r_r379;
    PyObject *cpy_r_r380;
    int32_t cpy_r_r381;
    char cpy_r_r382;
    PyObject *cpy_r_r383;
    PyObject *cpy_r_r384;
    PyObject *cpy_r_r385;
    PyObject *cpy_r_r386;
    PyObject *cpy_r_r387;
    char cpy_r_r388;
    PyObject *cpy_r_r389;
    PyObject *cpy_r_r390;
    PyObject *cpy_r_r391;
    PyObject *cpy_r_r392;
    PyObject *cpy_r_r393;
    PyObject *cpy_r_r394;
    PyObject *cpy_r_r395;
    PyObject *cpy_r_r396;
    PyObject *cpy_r_r397;
    PyObject *cpy_r_r398;
    int32_t cpy_r_r399;
    char cpy_r_r400;
    PyObject *cpy_r_r401;
    PyObject *cpy_r_r402;
    int32_t cpy_r_r403;
    char cpy_r_r404;
    PyObject *cpy_r_r405;
    PyObject *cpy_r_r406;
    PyObject *cpy_r_r407;
    PyObject *cpy_r_r408;
    PyObject *cpy_r_r409;
    char cpy_r_r410;
    PyObject *cpy_r_r411;
    PyObject *cpy_r_r412;
    PyObject *cpy_r_r413;
    PyObject *cpy_r_r414;
    PyObject *cpy_r_r415;
    PyObject *cpy_r_r416;
    PyObject *cpy_r_r417;
    PyObject *cpy_r_r418;
    PyObject *cpy_r_r419;
    int32_t cpy_r_r420;
    char cpy_r_r421;
    PyObject *cpy_r_r422;
    PyObject *cpy_r_r423;
    int32_t cpy_r_r424;
    char cpy_r_r425;
    PyObject *cpy_r_r426;
    PyObject *cpy_r_r427;
    PyObject *cpy_r_r428;
    PyObject *cpy_r_r429;
    PyObject *cpy_r_r430;
    char cpy_r_r431;
    PyObject *cpy_r_r432;
    PyObject *cpy_r_r433;
    PyObject *cpy_r_r434;
    PyObject *cpy_r_r435;
    PyObject *cpy_r_r436;
    PyObject *cpy_r_r437;
    PyObject *cpy_r_r438;
    PyObject *cpy_r_r439;
    PyObject *cpy_r_r440;
    PyObject *cpy_r_r441;
    PyObject *cpy_r_r442;
    int32_t cpy_r_r443;
    char cpy_r_r444;
    PyObject *cpy_r_r445;
    PyObject *cpy_r_r446;
    int32_t cpy_r_r447;
    char cpy_r_r448;
    PyObject *cpy_r_r449;
    PyObject *cpy_r_r450;
    PyObject *cpy_r_r451;
    PyObject *cpy_r_r452;
    PyObject *cpy_r_r453;
    char cpy_r_r454;
    PyObject *cpy_r_r455;
    PyObject *cpy_r_r456;
    PyObject *cpy_r_r457;
    PyObject *cpy_r_r458;
    PyObject *cpy_r_r459;
    PyObject *cpy_r_r460;
    PyObject *cpy_r_r461;
    PyObject *cpy_r_r462;
    PyObject *cpy_r_r463;
    int32_t cpy_r_r464;
    char cpy_r_r465;
    PyObject *cpy_r_r466;
    PyObject *cpy_r_r467;
    int32_t cpy_r_r468;
    char cpy_r_r469;
    PyObject *cpy_r_r470;
    PyObject *cpy_r_r471;
    PyObject *cpy_r_r472;
    PyObject *cpy_r_r473;
    PyObject *cpy_r_r474;
    char cpy_r_r475;
    PyObject *cpy_r_r476;
    PyObject *cpy_r_r477;
    PyObject *cpy_r_r478;
    PyObject *cpy_r_r479;
    PyObject *cpy_r_r480;
    PyObject *cpy_r_r481;
    PyObject *cpy_r_r482;
    PyObject *cpy_r_r483;
    PyObject *cpy_r_r484;
    PyObject *cpy_r_r485;
    int32_t cpy_r_r486;
    char cpy_r_r487;
    PyObject *cpy_r_r488;
    PyObject *cpy_r_r489;
    int32_t cpy_r_r490;
    char cpy_r_r491;
    PyObject *cpy_r_r492;
    PyObject *cpy_r_r493;
    PyObject *cpy_r_r494;
    PyObject *cpy_r_r495;
    PyObject *cpy_r_r496;
    char cpy_r_r497;
    PyObject *cpy_r_r498;
    PyObject *cpy_r_r499;
    PyObject *cpy_r_r500;
    PyObject *cpy_r_r501;
    PyObject *cpy_r_r502;
    PyObject *cpy_r_r503;
    PyObject *cpy_r_r504;
    PyObject *cpy_r_r505;
    PyObject *cpy_r_r506;
    PyObject *cpy_r_r507;
    PyObject *cpy_r_r508;
    int32_t cpy_r_r509;
    char cpy_r_r510;
    PyObject *cpy_r_r511;
    PyObject *cpy_r_r512;
    int32_t cpy_r_r513;
    char cpy_r_r514;
    PyObject *cpy_r_r515;
    PyObject *cpy_r_r516;
    PyObject *cpy_r_r517;
    PyObject *cpy_r_r518;
    PyObject *cpy_r_r519;
    char cpy_r_r520;
    PyObject *cpy_r_r521;
    PyObject *cpy_r_r522;
    PyObject *cpy_r_r523;
    PyObject *cpy_r_r524;
    PyObject *cpy_r_r525;
    PyObject *cpy_r_r526;
    PyObject *cpy_r_r527;
    PyObject *cpy_r_r528;
    PyObject *cpy_r_r529;
    PyObject *cpy_r_r530;
    PyObject *cpy_r_r531;
    PyObject *cpy_r_r532;
    PyObject *cpy_r_r533;
    int32_t cpy_r_r534;
    char cpy_r_r535;
    PyObject *cpy_r_r536;
    PyObject *cpy_r_r537;
    int32_t cpy_r_r538;
    char cpy_r_r539;
    PyObject *cpy_r_r540;
    PyObject *cpy_r_r541;
    PyObject *cpy_r_r542;
    int32_t cpy_r_r543;
    char cpy_r_r544;
    PyObject *cpy_r_r545;
    PyObject *cpy_r_r546;
    PyObject *cpy_r_r547;
    int32_t cpy_r_r548;
    char cpy_r_r549;
    PyObject *cpy_r_r550;
    PyObject *cpy_r_r551;
    PyObject *cpy_r_r552;
    int32_t cpy_r_r553;
    char cpy_r_r554;
    PyObject *cpy_r_r555;
    PyObject *cpy_r_r556;
    PyObject *cpy_r_r557;
    PyObject *cpy_r_r558;
    PyObject *cpy_r_r559;
    char cpy_r_r560;
    PyObject *cpy_r_r561;
    PyObject *cpy_r_r562;
    PyObject *cpy_r_r563;
    PyObject *cpy_r_r564;
    PyObject *cpy_r_r565;
    PyObject *cpy_r_r566;
    PyObject *cpy_r_r567;
    PyObject *cpy_r_r568;
    PyObject *cpy_r_r569;
    PyObject *cpy_r_r570;
    PyObject *cpy_r_r571;
    PyObject *cpy_r_r572;
    PyObject *cpy_r_r573;
    int32_t cpy_r_r574;
    char cpy_r_r575;
    PyObject *cpy_r_r576;
    PyObject *cpy_r_r577;
    int32_t cpy_r_r578;
    char cpy_r_r579;
    PyObject *cpy_r_r580;
    PyObject *cpy_r_r581;
    PyObject *cpy_r_r582;
    PyObject *cpy_r_r583;
    PyObject *cpy_r_r584;
    char cpy_r_r585;
    PyObject *cpy_r_r586;
    PyObject *cpy_r_r587;
    PyObject *cpy_r_r588;
    PyObject *cpy_r_r589;
    PyObject *cpy_r_r590;
    PyObject *cpy_r_r591;
    PyObject *cpy_r_r592;
    PyObject *cpy_r_r593;
    PyObject *cpy_r_r594;
    PyObject *cpy_r_r595;
    PyObject *cpy_r_r596;
    PyObject *cpy_r_r597;
    int32_t cpy_r_r598;
    char cpy_r_r599;
    PyObject *cpy_r_r600;
    PyObject *cpy_r_r601;
    int32_t cpy_r_r602;
    char cpy_r_r603;
    PyObject *cpy_r_r604;
    PyObject *cpy_r_r605;
    PyObject *cpy_r_r606;
    PyObject *cpy_r_r607;
    PyObject *cpy_r_r608;
    char cpy_r_r609;
    PyObject *cpy_r_r610;
    PyObject *cpy_r_r611;
    PyObject *cpy_r_r612;
    PyObject *cpy_r_r613;
    PyObject *cpy_r_r614;
    PyObject *cpy_r_r615;
    PyObject *cpy_r_r616;
    PyObject *cpy_r_r617;
    PyObject *cpy_r_r618;
    PyObject *cpy_r_r619;
    int32_t cpy_r_r620;
    char cpy_r_r621;
    PyObject *cpy_r_r622;
    PyObject *cpy_r_r623;
    int32_t cpy_r_r624;
    char cpy_r_r625;
    PyObject *cpy_r_r626;
    PyObject *cpy_r_r627;
    PyObject *cpy_r_r628;
    PyObject *cpy_r_r629;
    PyObject *cpy_r_r630;
    char cpy_r_r631;
    PyObject *cpy_r_r632;
    PyObject *cpy_r_r633;
    PyObject *cpy_r_r634;
    PyObject *cpy_r_r635;
    PyObject *cpy_r_r636;
    PyObject *cpy_r_r637;
    PyObject *cpy_r_r638;
    PyObject *cpy_r_r639;
    PyObject *cpy_r_r640;
    PyObject *cpy_r_r641;
    int32_t cpy_r_r642;
    char cpy_r_r643;
    PyObject *cpy_r_r644;
    PyObject *cpy_r_r645;
    int32_t cpy_r_r646;
    char cpy_r_r647;
    PyObject *cpy_r_r648;
    PyObject *cpy_r_r649;
    PyObject *cpy_r_r650;
    PyObject *cpy_r_r651;
    PyObject *cpy_r_r652;
    char cpy_r_r653;
    PyObject *cpy_r_r654;
    PyObject *cpy_r_r655;
    PyObject *cpy_r_r656;
    PyObject *cpy_r_r657;
    PyObject *cpy_r_r658;
    PyObject *cpy_r_r659;
    PyObject *cpy_r_r660;
    PyObject *cpy_r_r661;
    PyObject *cpy_r_r662;
    int32_t cpy_r_r663;
    char cpy_r_r664;
    PyObject *cpy_r_r665;
    PyObject *cpy_r_r666;
    int32_t cpy_r_r667;
    char cpy_r_r668;
    PyObject *cpy_r_r669;
    PyObject *cpy_r_r670;
    PyObject *cpy_r_r671;
    PyObject *cpy_r_r672;
    PyObject *cpy_r_r673;
    char cpy_r_r674;
    PyObject *cpy_r_r675;
    PyObject *cpy_r_r676;
    PyObject *cpy_r_r677;
    PyObject *cpy_r_r678;
    PyObject *cpy_r_r679;
    PyObject *cpy_r_r680;
    PyObject *cpy_r_r681;
    PyObject *cpy_r_r682;
    PyObject *cpy_r_r683;
    int32_t cpy_r_r684;
    char cpy_r_r685;
    PyObject *cpy_r_r686;
    PyObject *cpy_r_r687;
    int32_t cpy_r_r688;
    char cpy_r_r689;
    PyObject *cpy_r_r690;
    PyObject *cpy_r_r691;
    PyObject *cpy_r_r692;
    PyObject *cpy_r_r693;
    PyObject *cpy_r_r694;
    char cpy_r_r695;
    PyObject *cpy_r_r696;
    PyObject *cpy_r_r697;
    PyObject *cpy_r_r698;
    PyObject *cpy_r_r699;
    PyObject *cpy_r_r700;
    PyObject *cpy_r_r701;
    PyObject *cpy_r_r702;
    PyObject *cpy_r_r703;
    int32_t cpy_r_r704;
    char cpy_r_r705;
    PyObject *cpy_r_r706;
    PyObject *cpy_r_r707;
    int32_t cpy_r_r708;
    char cpy_r_r709;
    PyObject *cpy_r_r710;
    PyObject *cpy_r_r711;
    PyObject *cpy_r_r712;
    PyObject *cpy_r_r713;
    PyObject *cpy_r_r714;
    char cpy_r_r715;
    PyObject *cpy_r_r716;
    PyObject *cpy_r_r717;
    PyObject *cpy_r_r718;
    PyObject *cpy_r_r719;
    PyObject *cpy_r_r720;
    PyObject *cpy_r_r721;
    PyObject *cpy_r_r722;
    PyObject *cpy_r_r723;
    PyObject *cpy_r_r724;
    PyObject *cpy_r_r725;
    PyObject *cpy_r_r726;
    PyObject *cpy_r_r727;
    PyObject *cpy_r_r728;
    PyObject *cpy_r_r729;
    PyObject *cpy_r_r730;
    PyObject *cpy_r_r731;
    PyObject *cpy_r_r732;
    int32_t cpy_r_r733;
    char cpy_r_r734;
    PyObject *cpy_r_r735;
    PyObject *cpy_r_r736;
    int32_t cpy_r_r737;
    char cpy_r_r738;
    PyObject *cpy_r_r739;
    PyObject *cpy_r_r740;
    PyObject *cpy_r_r741;
    int32_t cpy_r_r742;
    char cpy_r_r743;
    PyObject *cpy_r_r744;
    PyObject *cpy_r_r745;
    PyObject *cpy_r_r746;
    int32_t cpy_r_r747;
    char cpy_r_r748;
    PyObject *cpy_r_r749;
    PyObject *cpy_r_r750;
    PyObject *cpy_r_r751;
    int32_t cpy_r_r752;
    char cpy_r_r753;
    PyObject *cpy_r_r754;
    PyObject *cpy_r_r755;
    PyObject *cpy_r_r756;
    int32_t cpy_r_r757;
    char cpy_r_r758;
    PyObject *cpy_r_r759;
    PyObject *cpy_r_r760;
    PyObject *cpy_r_r761;
    int32_t cpy_r_r762;
    char cpy_r_r763;
    PyObject *cpy_r_r764;
    PyObject *cpy_r_r765;
    PyObject *cpy_r_r766;
    int32_t cpy_r_r767;
    char cpy_r_r768;
    PyObject *cpy_r_r769;
    PyObject *cpy_r_r770;
    PyObject *cpy_r_r771;
    int32_t cpy_r_r772;
    char cpy_r_r773;
    PyObject *cpy_r_r774;
    PyObject *cpy_r_r775;
    PyObject *cpy_r_r776;
    PyObject *cpy_r_r777;
    PyObject *cpy_r_r778;
    PyObject *cpy_r_r779;
    PyObject *cpy_r_r780;
    PyObject *cpy_r_r781;
    PyObject *cpy_r_r782;
    tuple_T2OO cpy_r_r783;
    PyObject *cpy_r_r784;
    PyObject *cpy_r_r785;
    PyObject *cpy_r_r786;
    PyObject *cpy_r_r787;
    int32_t cpy_r_r788;
    char cpy_r_r789;
    PyObject *cpy_r_r790;
    PyObject *cpy_r_r791;
    PyObject *cpy_r_r792;
    PyObject *cpy_r_r793;
    PyObject *cpy_r_r794;
    char cpy_r_r795;
    PyObject *cpy_r_r796;
    PyObject *cpy_r_r797;
    PyObject *cpy_r_r798;
    PyObject *cpy_r_r799;
    PyObject *cpy_r_r800;
    PyObject *cpy_r_r801;
    PyObject *cpy_r_r802;
    PyObject *cpy_r_r803;
    PyObject *cpy_r_r804;
    PyObject *cpy_r_r805;
    PyObject *cpy_r_r806;
    int32_t cpy_r_r807;
    char cpy_r_r808;
    PyObject *cpy_r_r809;
    PyObject *cpy_r_r810;
    int32_t cpy_r_r811;
    char cpy_r_r812;
    PyObject *cpy_r_r813;
    PyObject *cpy_r_r814;
    PyObject *cpy_r_r815;
    PyObject *cpy_r_r816;
    PyObject *cpy_r_r817;
    char cpy_r_r818;
    PyObject *cpy_r_r819;
    PyObject *cpy_r_r820;
    PyObject *cpy_r_r821;
    PyObject *cpy_r_r822;
    PyObject *cpy_r_r823;
    PyObject *cpy_r_r824;
    PyObject *cpy_r_r825;
    PyObject *cpy_r_r826;
    PyObject *cpy_r_r827;
    PyObject *cpy_r_r828;
    int32_t cpy_r_r829;
    char cpy_r_r830;
    PyObject *cpy_r_r831;
    PyObject *cpy_r_r832;
    int32_t cpy_r_r833;
    char cpy_r_r834;
    PyObject *cpy_r_r835;
    PyObject *cpy_r_r836;
    PyObject *cpy_r_r837;
    PyObject *cpy_r_r838;
    PyObject *cpy_r_r839;
    char cpy_r_r840;
    PyObject *cpy_r_r841;
    PyObject *cpy_r_r842;
    PyObject *cpy_r_r843;
    PyObject *cpy_r_r844;
    PyObject *cpy_r_r845;
    PyObject *cpy_r_r846;
    PyObject *cpy_r_r847;
    PyObject *cpy_r_r848;
    PyObject *cpy_r_r849;
    PyObject *cpy_r_r850;
    PyObject *cpy_r_r851;
    int32_t cpy_r_r852;
    char cpy_r_r853;
    PyObject *cpy_r_r854;
    PyObject *cpy_r_r855;
    int32_t cpy_r_r856;
    char cpy_r_r857;
    PyObject *cpy_r_r858;
    PyObject *cpy_r_r859;
    PyObject *cpy_r_r860;
    PyObject *cpy_r_r861;
    PyObject *cpy_r_r862;
    char cpy_r_r863;
    PyObject *cpy_r_r864;
    PyObject *cpy_r_r865;
    PyObject *cpy_r_r866;
    PyObject *cpy_r_r867;
    PyObject *cpy_r_r868;
    PyObject *cpy_r_r869;
    PyObject *cpy_r_r870;
    PyObject *cpy_r_r871;
    PyObject *cpy_r_r872;
    PyObject *cpy_r_r873;
    PyObject *cpy_r_r874;
    int32_t cpy_r_r875;
    char cpy_r_r876;
    PyObject *cpy_r_r877;
    PyObject *cpy_r_r878;
    int32_t cpy_r_r879;
    char cpy_r_r880;
    PyObject *cpy_r_r881;
    PyObject *cpy_r_r882;
    PyObject *cpy_r_r883;
    PyObject *cpy_r_r884;
    PyObject *cpy_r_r885;
    char cpy_r_r886;
    PyObject *cpy_r_r887;
    PyObject *cpy_r_r888;
    PyObject *cpy_r_r889;
    PyObject *cpy_r_r890;
    PyObject *cpy_r_r891;
    PyObject *cpy_r_r892;
    PyObject *cpy_r_r893;
    PyObject *cpy_r_r894;
    PyObject *cpy_r_r895;
    PyObject *cpy_r_r896;
    PyObject *cpy_r_r897;
    PyObject *cpy_r_r898;
    PyObject *cpy_r_r899;
    PyObject *cpy_r_r900;
    PyObject *cpy_r_r901;
    PyObject *cpy_r_r902;
    PyObject *cpy_r_r903;
    PyObject *cpy_r_r904;
    PyObject *cpy_r_r905;
    PyObject *cpy_r_r906;
    PyObject *cpy_r_r907;
    PyObject *cpy_r_r908;
    int32_t cpy_r_r909;
    char cpy_r_r910;
    PyObject *cpy_r_r911;
    PyObject *cpy_r_r912;
    int32_t cpy_r_r913;
    char cpy_r_r914;
    PyObject *cpy_r_r915;
    PyObject *cpy_r_r916;
    PyObject *cpy_r_r917;
    int32_t cpy_r_r918;
    char cpy_r_r919;
    PyObject *cpy_r_r920;
    PyObject *cpy_r_r921;
    PyObject *cpy_r_r922;
    int32_t cpy_r_r923;
    char cpy_r_r924;
    PyObject *cpy_r_r925;
    PyObject *cpy_r_r926;
    PyObject *cpy_r_r927;
    int32_t cpy_r_r928;
    char cpy_r_r929;
    PyObject *cpy_r_r930;
    PyObject *cpy_r_r931;
    PyObject *cpy_r_r932;
    int32_t cpy_r_r933;
    char cpy_r_r934;
    PyObject *cpy_r_r935;
    PyObject *cpy_r_r936;
    PyObject *cpy_r_r937;
    int32_t cpy_r_r938;
    char cpy_r_r939;
    PyObject *cpy_r_r940;
    PyObject *cpy_r_r941;
    PyObject *cpy_r_r942;
    int32_t cpy_r_r943;
    char cpy_r_r944;
    PyObject *cpy_r_r945;
    PyObject *cpy_r_r946;
    PyObject *cpy_r_r947;
    int32_t cpy_r_r948;
    char cpy_r_r949;
    PyObject *cpy_r_r950;
    PyObject *cpy_r_r951;
    PyObject *cpy_r_r952;
    int32_t cpy_r_r953;
    char cpy_r_r954;
    PyObject *cpy_r_r955;
    PyObject *cpy_r_r956;
    PyObject *cpy_r_r957;
    int32_t cpy_r_r958;
    char cpy_r_r959;
    PyObject *cpy_r_r960;
    PyObject *cpy_r_r961;
    PyObject *cpy_r_r962;
    int32_t cpy_r_r963;
    char cpy_r_r964;
    PyObject *cpy_r_r965;
    PyObject *cpy_r_r966;
    PyObject *cpy_r_r967;
    PyObject *cpy_r_r968;
    PyObject *cpy_r_r969;
    PyObject *cpy_r_r970;
    PyObject *cpy_r_r971;
    PyObject *cpy_r_r972;
    PyObject *cpy_r_r973;
    PyObject *cpy_r_r974;
    PyObject *cpy_r_r975;
    PyObject *cpy_r_r976;
    PyObject *cpy_r_r977;
    PyObject *cpy_r_r978;
    PyObject *cpy_r_r979;
    PyObject *cpy_r_r980;
    PyObject *cpy_r_r981;
    PyObject *cpy_r_r982;
    PyObject *cpy_r_r983;
    PyObject *cpy_r_r984;
    PyObject *cpy_r_r985;
    PyObject *cpy_r_r986;
    PyObject *cpy_r_r987;
    int32_t cpy_r_r988;
    char cpy_r_r989;
    PyObject *cpy_r_r990;
    PyObject *cpy_r_r991;
    char cpy_r_r992;
    CPyTagged cpy_r_r993;
    int64_t cpy_r_r994;
    CPyTagged cpy_r_r995;
    PyObject *cpy_r_r996;
    tuple_T4CIOO cpy_r_r997;
    CPyTagged cpy_r_r998;
    char cpy_r_r999;
    PyObject *cpy_r_r1000;
    PyObject *cpy_r_r1001;
    CPyTagged cpy_r_r1002;
    PyObject *cpy_r_r1003;
    CPyTagged cpy_r_op_id;
    PyObject *cpy_r_op;
    PyObject *cpy_r_r1004;
    int32_t cpy_r_r1005;
    char cpy_r_r1006;
    char cpy_r_r1007;
    char cpy_r_r1008;
    PyObject *cpy_r_r1009;
    PyObject *cpy_r_r1010;
    int32_t cpy_r_r1011;
    char cpy_r_r1012;
    PyObject *cpy_r_r1013;
    PyObject *cpy_r_r1014;
    PyObject *cpy_r_r1015;
    PyObject *cpy_r_r1016;
    PyObject *cpy_r_r1017;
    char cpy_r_r1018;
    PyObject *cpy_r_r1019;
    PyObject *cpy_r_r1020;
    PyObject *cpy_r_r1021;
    PyObject *cpy_r_r1022;
    PyObject *cpy_r_r1023;
    PyObject *cpy_r_r1024;
    PyObject *cpy_r_r1025;
    PyObject *cpy_r_r1026;
    PyObject *cpy_r_r1027;
    PyObject *cpy_r_r1028;
    PyObject *cpy_r_r1029;
    PyObject *cpy_r_r1030;
    PyObject *cpy_r_r1031;
    PyObject *cpy_r_r1032;
    PyObject *cpy_r_r1033;
    PyObject *cpy_r_r1034;
    PyObject *cpy_r_r1035;
    PyObject *cpy_r_r1036;
    PyObject *cpy_r_r1037;
    PyObject *cpy_r_r1038;
    PyObject *cpy_r_r1039;
    PyObject *cpy_r_r1040;
    PyObject *cpy_r_r1041;
    PyObject *cpy_r_r1042;
    int32_t cpy_r_r1043;
    char cpy_r_r1044;
    PyObject *cpy_r_r1045;
    PyObject *cpy_r_r1046;
    int32_t cpy_r_r1047;
    char cpy_r_r1048;
    PyObject *cpy_r_r1049;
    PyObject *cpy_r_r1050;
    PyObject *cpy_r_r1051;
    int32_t cpy_r_r1052;
    char cpy_r_r1053;
    PyObject *cpy_r_r1054;
    PyObject *cpy_r_r1055;
    PyObject *cpy_r_r1056;
    int32_t cpy_r_r1057;
    char cpy_r_r1058;
    PyObject *cpy_r_r1059;
    PyObject *cpy_r_r1060;
    PyObject *cpy_r_r1061;
    int32_t cpy_r_r1062;
    char cpy_r_r1063;
    PyObject *cpy_r_r1064;
    PyObject *cpy_r_r1065;
    PyObject *cpy_r_r1066;
    int32_t cpy_r_r1067;
    char cpy_r_r1068;
    PyObject *cpy_r_r1069;
    PyObject *cpy_r_r1070;
    PyObject *cpy_r_r1071;
    int32_t cpy_r_r1072;
    char cpy_r_r1073;
    PyObject *cpy_r_r1074;
    PyObject *cpy_r_r1075;
    PyObject *cpy_r_r1076;
    int32_t cpy_r_r1077;
    char cpy_r_r1078;
    PyObject *cpy_r_r1079;
    PyObject *cpy_r_r1080;
    PyObject *cpy_r_r1081;
    int32_t cpy_r_r1082;
    char cpy_r_r1083;
    PyObject *cpy_r_r1084;
    PyObject *cpy_r_r1085;
    PyObject *cpy_r_r1086;
    int32_t cpy_r_r1087;
    char cpy_r_r1088;
    PyObject *cpy_r_r1089;
    PyObject *cpy_r_r1090;
    PyObject *cpy_r_r1091;
    int32_t cpy_r_r1092;
    char cpy_r_r1093;
    PyObject *cpy_r_r1094;
    PyObject *cpy_r_r1095;
    PyObject *cpy_r_r1096;
    int32_t cpy_r_r1097;
    char cpy_r_r1098;
    PyObject *cpy_r_r1099;
    PyObject *cpy_r_r1100;
    PyObject *cpy_r_r1101;
    PyObject *cpy_r_r1102;
    PyObject *cpy_r_r1103;
    PyObject *cpy_r_r1104;
    PyObject *cpy_r_r1105;
    PyObject *cpy_r_r1106;
    PyObject *cpy_r_r1107;
    PyObject *cpy_r_r1108;
    PyObject *cpy_r_r1109;
    PyObject *cpy_r_r1110;
    PyObject *cpy_r_r1111;
    PyObject *cpy_r_r1112;
    PyObject *cpy_r_r1113;
    PyObject *cpy_r_r1114;
    PyObject *cpy_r_r1115;
    PyObject *cpy_r_r1116;
    PyObject *cpy_r_r1117;
    PyObject *cpy_r_r1118;
    PyObject *cpy_r_r1119;
    PyObject *cpy_r_r1120;
    PyObject *cpy_r_r1121;
    int32_t cpy_r_r1122;
    char cpy_r_r1123;
    PyObject *cpy_r_r1124;
    PyObject *cpy_r_r1125;
    PyObject *cpy_r_r1126;
    PyObject *cpy_r_r1127;
    PyObject *cpy_r_r1128;
    PyObject *cpy_r_r1129;
    PyObject *cpy_r_r1130;
    PyObject *cpy_r_r1131;
    PyObject *cpy_r_r1132;
    PyObject *cpy_r_r1133;
    PyObject *cpy_r_r1134;
    PyObject *cpy_r_r1135;
    PyObject *cpy_r_r1136;
    PyObject *cpy_r_r1137;
    PyObject *cpy_r_r1138;
    int32_t cpy_r_r1139;
    char cpy_r_r1140;
    PyObject *cpy_r_r1141;
    PyObject *cpy_r_r1142;
    PyObject *cpy_r_r1143;
    PyObject *cpy_r_r1144;
    PyObject *cpy_r_r1145;
    PyObject *cpy_r_r1146;
    PyObject *cpy_r_r1147;
    PyObject *cpy_r_r1148;
    PyObject *cpy_r_r1149;
    PyObject *cpy_r_r1150;
    PyObject *cpy_r_r1151;
    PyObject *cpy_r_r1152;
    PyObject *cpy_r_r1153;
    PyObject *cpy_r_r1154;
    PyObject *cpy_r_r1155;
    int32_t cpy_r_r1156;
    char cpy_r_r1157;
    PyObject *cpy_r_r1158;
    PyObject *cpy_r_r1159;
    PyObject *cpy_r_r1160;
    PyObject *cpy_r_r1161;
    PyObject *cpy_r_r1162;
    char cpy_r_r1163;
    PyObject *cpy_r_r1164;
    PyObject *cpy_r_r1165;
    PyObject *cpy_r_r1166;
    PyObject *cpy_r_r1167;
    PyObject *cpy_r_r1168;
    PyObject *cpy_r_r1169;
    PyObject *cpy_r_r1170;
    PyObject *cpy_r_r1171;
    PyObject *cpy_r_r1172;
    PyObject *cpy_r_r1173;
    PyObject *cpy_r_r1174;
    PyObject *cpy_r_r1175;
    PyObject *cpy_r_r1176;
    PyObject *cpy_r_r1177;
    PyObject *cpy_r_r1178;
    PyObject *cpy_r_r1179;
    PyObject *cpy_r_r1180;
    int32_t cpy_r_r1181;
    char cpy_r_r1182;
    PyObject *cpy_r_r1183;
    PyObject *cpy_r_r1184;
    int32_t cpy_r_r1185;
    char cpy_r_r1186;
    PyObject *cpy_r_r1187;
    PyObject *cpy_r_r1188;
    PyObject *cpy_r_r1189;
    int32_t cpy_r_r1190;
    char cpy_r_r1191;
    PyObject *cpy_r_r1192;
    PyObject *cpy_r_r1193;
    PyObject *cpy_r_r1194;
    int32_t cpy_r_r1195;
    char cpy_r_r1196;
    PyObject *cpy_r_r1197;
    PyObject *cpy_r_r1198;
    PyObject *cpy_r_r1199;
    int32_t cpy_r_r1200;
    char cpy_r_r1201;
    PyObject *cpy_r_r1202;
    PyObject *cpy_r_r1203;
    PyObject *cpy_r_r1204;
    int32_t cpy_r_r1205;
    char cpy_r_r1206;
    PyObject *cpy_r_r1207;
    PyObject *cpy_r_r1208;
    PyObject *cpy_r_r1209;
    int32_t cpy_r_r1210;
    char cpy_r_r1211;
    PyObject *cpy_r_r1212;
    PyObject *cpy_r_r1213;
    PyObject *cpy_r_r1214;
    PyObject *cpy_r_r1215;
    PyObject *cpy_r_r1216;
    PyObject *cpy_r_r1217;
    PyObject *cpy_r_r1218;
    PyObject *cpy_r_r1219;
    PyObject *cpy_r_r1220;
    PyObject *cpy_r_r1221;
    PyObject *cpy_r_r1222;
    PyObject *cpy_r_r1223;
    PyObject *cpy_r_r1224;
    int32_t cpy_r_r1225;
    char cpy_r_r1226;
    PyObject *cpy_r_r1227;
    PyObject *cpy_r_r1228;
    char cpy_r_r1229;
    CPyTagged cpy_r_r1230;
    int64_t cpy_r_r1231;
    CPyTagged cpy_r_r1232;
    PyObject *cpy_r_r1233;
    tuple_T4CIOO cpy_r_r1234;
    CPyTagged cpy_r_r1235;
    char cpy_r_r1236;
    PyObject *cpy_r_r1237;
    PyObject *cpy_r_r1238;
    CPyTagged cpy_r_r1239;
    PyObject *cpy_r_r1240;
    CPyTagged cpy_r_op_id_2;
    PyObject *cpy_r_op_2;
    PyObject *cpy_r_r1241;
    int32_t cpy_r_r1242;
    char cpy_r_r1243;
    char cpy_r_r1244;
    char cpy_r_r1245;
    PyObject *cpy_r_r1246;
    PyObject *cpy_r_r1247;
    int32_t cpy_r_r1248;
    char cpy_r_r1249;
    PyObject *cpy_r_r1250;
    PyObject *cpy_r_r1251;
    PyObject *cpy_r_r1252;
    PyObject *cpy_r_r1253;
    PyObject *cpy_r_r1254;
    char cpy_r_r1255;
    PyObject *cpy_r_r1256;
    PyObject *cpy_r_r1257;
    PyObject *cpy_r_r1258;
    PyObject *cpy_r_r1259;
    PyObject *cpy_r_r1260;
    PyObject *cpy_r_r1261;
    PyObject *cpy_r_r1262;
    PyObject *cpy_r_r1263;
    PyObject *cpy_r_r1264;
    int32_t cpy_r_r1265;
    char cpy_r_r1266;
    PyObject *cpy_r_r1267;
    PyObject *cpy_r_r1268;
    int32_t cpy_r_r1269;
    char cpy_r_r1270;
    PyObject *cpy_r_r1271;
    PyObject *cpy_r_r1272;
    PyObject *cpy_r_r1273;
    PyObject *cpy_r_r1274;
    PyObject *cpy_r_r1275;
    char cpy_r_r1276;
    PyObject *cpy_r_r1277;
    PyObject *cpy_r_r1278;
    PyObject *cpy_r_r1279;
    PyObject *cpy_r_r1280;
    PyObject *cpy_r_r1281;
    PyObject *cpy_r_r1282;
    PyObject *cpy_r_r1283;
    PyObject *cpy_r_r1284;
    PyObject *cpy_r_r1285;
    PyObject *cpy_r_r1286;
    PyObject *cpy_r_r1287;
    PyObject *cpy_r_r1288;
    PyObject *cpy_r_r1289;
    PyObject *cpy_r_r1290;
    PyObject *cpy_r_r1291;
    PyObject *cpy_r_r1292;
    PyObject *cpy_r_r1293;
    PyObject *cpy_r_r1294;
    int32_t cpy_r_r1295;
    char cpy_r_r1296;
    PyObject *cpy_r_r1297;
    PyObject *cpy_r_r1298;
    int32_t cpy_r_r1299;
    char cpy_r_r1300;
    PyObject *cpy_r_r1301;
    PyObject *cpy_r_r1302;
    PyObject *cpy_r_r1303;
    int32_t cpy_r_r1304;
    char cpy_r_r1305;
    PyObject *cpy_r_r1306;
    PyObject *cpy_r_r1307;
    PyObject *cpy_r_r1308;
    int32_t cpy_r_r1309;
    char cpy_r_r1310;
    PyObject *cpy_r_r1311;
    PyObject *cpy_r_r1312;
    PyObject *cpy_r_r1313;
    int32_t cpy_r_r1314;
    char cpy_r_r1315;
    PyObject *cpy_r_r1316;
    PyObject *cpy_r_r1317;
    PyObject *cpy_r_r1318;
    int32_t cpy_r_r1319;
    char cpy_r_r1320;
    PyObject *cpy_r_r1321;
    PyObject *cpy_r_r1322;
    PyObject *cpy_r_r1323;
    int32_t cpy_r_r1324;
    char cpy_r_r1325;
    PyObject *cpy_r_r1326;
    PyObject *cpy_r_r1327;
    PyObject *cpy_r_r1328;
    int32_t cpy_r_r1329;
    char cpy_r_r1330;
    PyObject *cpy_r_r1331;
    PyObject *cpy_r_r1332;
    PyObject *cpy_r_r1333;
    PyObject *cpy_r_r1334;
    PyObject *cpy_r_r1335;
    PyObject *cpy_r_r1336;
    PyObject *cpy_r_r1337;
    PyObject *cpy_r_r1338;
    PyObject *cpy_r_r1339;
    PyObject *cpy_r_r1340;
    PyObject *cpy_r_r1341;
    PyObject *cpy_r_r1342;
    PyObject *cpy_r_r1343;
    PyObject *cpy_r_r1344;
    PyObject *cpy_r_r1345;
    int32_t cpy_r_r1346;
    char cpy_r_r1347;
    PyObject *cpy_r_r1348;
    PyObject *cpy_r_r1349;
    char cpy_r_r1350;
    CPyTagged cpy_r_r1351;
    int64_t cpy_r_r1352;
    CPyTagged cpy_r_r1353;
    PyObject *cpy_r_r1354;
    tuple_T4CIOO cpy_r_r1355;
    CPyTagged cpy_r_r1356;
    char cpy_r_r1357;
    PyObject *cpy_r_r1358;
    PyObject *cpy_r_r1359;
    CPyTagged cpy_r_r1360;
    PyObject *cpy_r_r1361;
    CPyTagged cpy_r_op_id_3;
    PyObject *cpy_r_op_3;
    PyObject *cpy_r_r1362;
    int32_t cpy_r_r1363;
    char cpy_r_r1364;
    char cpy_r_r1365;
    char cpy_r_r1366;
    PyObject *cpy_r_r1367;
    PyObject *cpy_r_r1368;
    int32_t cpy_r_r1369;
    char cpy_r_r1370;
    PyObject *cpy_r_r1371;
    PyObject *cpy_r_r1372;
    PyObject *cpy_r_r1373;
    PyObject *cpy_r_r1374;
    PyObject *cpy_r_r1375;
    char cpy_r_r1376;
    PyObject *cpy_r_r1377;
    PyObject *cpy_r_r1378;
    PyObject *cpy_r_r1379;
    PyObject *cpy_r_r1380;
    PyObject *cpy_r_r1381;
    PyObject *cpy_r_r1382;
    PyObject *cpy_r_r1383;
    PyObject *cpy_r_r1384;
    PyObject *cpy_r_r1385;
    int32_t cpy_r_r1386;
    char cpy_r_r1387;
    PyObject *cpy_r_r1388;
    PyObject *cpy_r_r1389;
    int32_t cpy_r_r1390;
    char cpy_r_r1391;
    PyObject *cpy_r_r1392;
    PyObject *cpy_r_r1393;
    PyObject *cpy_r_r1394;
    PyObject *cpy_r_r1395;
    PyObject *cpy_r_r1396;
    char cpy_r_r1397;
    PyObject *cpy_r_r1398;
    PyObject *cpy_r_r1399;
    PyObject *cpy_r_r1400;
    PyObject *cpy_r_r1401;
    PyObject *cpy_r_r1402;
    PyObject *cpy_r_r1403;
    PyObject *cpy_r_r1404;
    PyObject *cpy_r_r1405;
    PyObject *cpy_r_r1406;
    int32_t cpy_r_r1407;
    char cpy_r_r1408;
    PyObject *cpy_r_r1409;
    PyObject *cpy_r_r1410;
    int32_t cpy_r_r1411;
    char cpy_r_r1412;
    PyObject *cpy_r_r1413;
    PyObject *cpy_r_r1414;
    PyObject *cpy_r_r1415;
    PyObject *cpy_r_r1416;
    PyObject *cpy_r_r1417;
    char cpy_r_r1418;
    PyObject *cpy_r_r1419;
    PyObject *cpy_r_r1420;
    PyObject *cpy_r_r1421;
    PyObject *cpy_r_r1422;
    PyObject *cpy_r_r1423;
    PyObject *cpy_r_r1424;
    PyObject *cpy_r_r1425;
    PyObject *cpy_r_r1426;
    PyObject *cpy_r_r1427;
    PyObject *cpy_r_r1428;
    PyObject *cpy_r_r1429;
    int32_t cpy_r_r1430;
    char cpy_r_r1431;
    PyObject *cpy_r_r1432;
    PyObject *cpy_r_r1433;
    int32_t cpy_r_r1434;
    char cpy_r_r1435;
    PyObject *cpy_r_r1436;
    PyObject *cpy_r_r1437;
    PyObject *cpy_r_r1438;
    PyObject *cpy_r_r1439;
    PyObject *cpy_r_r1440;
    char cpy_r_r1441;
    PyObject *cpy_r_r1442;
    PyObject *cpy_r_r1443;
    PyObject *cpy_r_r1444;
    PyObject *cpy_r_r1445;
    PyObject *cpy_r_r1446;
    PyObject *cpy_r_r1447;
    PyObject *cpy_r_r1448;
    PyObject *cpy_r_r1449;
    PyObject *cpy_r_r1450;
    PyObject *cpy_r_r1451;
    int32_t cpy_r_r1452;
    char cpy_r_r1453;
    PyObject *cpy_r_r1454;
    PyObject *cpy_r_r1455;
    int32_t cpy_r_r1456;
    char cpy_r_r1457;
    PyObject *cpy_r_r1458;
    PyObject *cpy_r_r1459;
    PyObject *cpy_r_r1460;
    PyObject *cpy_r_r1461;
    PyObject *cpy_r_r1462;
    char cpy_r_r1463;
    PyObject *cpy_r_r1464;
    PyObject *cpy_r_r1465;
    PyObject *cpy_r_r1466;
    PyObject *cpy_r_r1467;
    PyObject *cpy_r_r1468;
    PyObject *cpy_r_r1469;
    PyObject *cpy_r_r1470;
    PyObject *cpy_r_r1471;
    PyObject *cpy_r_r1472;
    int32_t cpy_r_r1473;
    char cpy_r_r1474;
    PyObject *cpy_r_r1475;
    PyObject *cpy_r_r1476;
    int32_t cpy_r_r1477;
    char cpy_r_r1478;
    PyObject *cpy_r_r1479;
    PyObject *cpy_r_r1480;
    PyObject *cpy_r_r1481;
    PyObject *cpy_r_r1482;
    PyObject *cpy_r_r1483;
    PyObject *cpy_r_r1484;
    PyObject *cpy_r_r1485;
    PyObject *cpy_r_r1486;
    PyObject *cpy_r_r1487;
    PyObject *cpy_r_r1488;
    PyObject *cpy_r_r1489;
    PyObject *cpy_r_r1490;
    PyObject *cpy_r_r1491;
    PyObject *cpy_r_r1492;
    int32_t cpy_r_r1493;
    char cpy_r_r1494;
    PyObject *cpy_r_r1495;
    PyObject *cpy_r_r1496;
    int32_t cpy_r_r1497;
    char cpy_r_r1498;
    PyObject *cpy_r_r1499;
    PyObject *cpy_r_r1500;
    char cpy_r_r1501;
    PyObject *cpy_r_r1502;
    PyObject *cpy_r_r1503;
    PyObject *cpy_r_r1504;
    PyObject *cpy_r_r1505;
    PyObject *cpy_r_r1506;
    PyObject *cpy_r_r1507;
    PyObject *cpy_r_r1508;
    PyObject *cpy_r_r1509;
    PyObject *cpy_r_r1510;
    PyObject *cpy_r_r1511;
    char cpy_r_r1512;
    PyObject *cpy_r_r1513;
    PyObject *cpy_r_r1514;
    PyObject *cpy_r_r1515;
    PyObject *cpy_r_r1516;
    PyObject *cpy_r_r1517;
    PyObject *cpy_r_r1518;
    PyObject *cpy_r_r1519;
    PyObject *cpy_r_r1520;
    char cpy_r_r1521;
    PyObject *cpy_r_r1522;
    PyObject *cpy_r_r1523;
    PyObject *cpy_r_r1524;
    PyObject **cpy_r_r1526;
    PyObject *cpy_r_r1527;
    PyObject *cpy_r_r1528;
    PyObject *cpy_r_r1529;
    PyObject *cpy_r_r1530;
    PyObject *cpy_r_r1531;
    PyObject *cpy_r_r1532;
    PyObject *cpy_r_r1533;
    int32_t cpy_r_r1534;
    char cpy_r_r1535;
    PyObject *cpy_r_r1536;
    PyObject *cpy_r_r1537;
    int32_t cpy_r_r1538;
    char cpy_r_r1539;
    PyObject *cpy_r_r1540;
    PyObject *cpy_r_r1541;
    int32_t cpy_r_r1542;
    char cpy_r_r1543;
    PyObject *cpy_r_r1544;
    PyObject *cpy_r_r1545;
    int32_t cpy_r_r1546;
    char cpy_r_r1547;
    PyObject *cpy_r_r1548;
    PyObject *cpy_r_r1549;
    int32_t cpy_r_r1550;
    char cpy_r_r1551;
    PyObject **cpy_r_r1553;
    PyObject *cpy_r_r1554;
    PyObject *cpy_r_r1555;
    PyObject *cpy_r_r1556;
    int32_t cpy_r_r1557;
    char cpy_r_r1558;
    PyObject *cpy_r_r1559;
    char cpy_r_r1560;
    cpy_r_r0 = CPyModule_builtins;
    cpy_r_r1 = (PyObject *)&_Py_NoneStruct;
    cpy_r_r2 = cpy_r_r0 != cpy_r_r1;
    if (cpy_r_r2) goto CPyL3;
    cpy_r_r3 = CPyStatics[3]; /* 'builtins' */
    cpy_r_r4 = PyImport_Import(cpy_r_r3);
    if (unlikely(cpy_r_r4 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL419;
    }
    CPyModule_builtins = cpy_r_r4;
    CPy_INCREF(CPyModule_builtins);
    CPy_DECREF(cpy_r_r4);
CPyL3: ;
    cpy_r_r5 = CPyStatics[9065]; /* ('annotations',) */
    cpy_r_r6 = CPyStatics[14]; /* '__future__' */
    cpy_r_r7 = CPyStatic_ops___globals;
    cpy_r_r8 = CPyImport_ImportFromMany(cpy_r_r6, cpy_r_r5, cpy_r_r5, cpy_r_r7);
    if (unlikely(cpy_r_r8 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 12, CPyStatic_ops___globals);
        goto CPyL419;
    }
    CPyModule___future__ = cpy_r_r8;
    CPy_INCREF(CPyModule___future__);
    CPy_DECREF(cpy_r_r8);
    cpy_r_r9 = CPyStatics[9527]; /* ('abstractmethod',) */
    cpy_r_r10 = CPyStatics[602]; /* 'abc' */
    cpy_r_r11 = CPyStatic_ops___globals;
    cpy_r_r12 = CPyImport_ImportFromMany(cpy_r_r10, cpy_r_r9, cpy_r_r9, cpy_r_r11);
    if (unlikely(cpy_r_r12 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 14, CPyStatic_ops___globals);
        goto CPyL419;
    }
    CPyModule_abc = cpy_r_r12;
    CPy_INCREF(CPyModule_abc);
    CPy_DECREF(cpy_r_r12);
    cpy_r_r13 = CPyStatics[10020]; /* ('TYPE_CHECKING', 'Final', 'Generic', 'List',
                                      'NamedTuple', 'Sequence', 'TypeVar', 'Union') */
    cpy_r_r14 = CPyStatics[21]; /* 'typing' */
    cpy_r_r15 = CPyStatic_ops___globals;
    cpy_r_r16 = CPyImport_ImportFromMany(cpy_r_r14, cpy_r_r13, cpy_r_r13, cpy_r_r15);
    if (unlikely(cpy_r_r16 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 15, CPyStatic_ops___globals);
        goto CPyL419;
    }
    CPyModule_typing = cpy_r_r16;
    CPy_INCREF(CPyModule_typing);
    CPy_DECREF(cpy_r_r16);
    cpy_r_r17 = CPyStatics[9554]; /* ('trait',) */
    cpy_r_r18 = CPyStatics[599]; /* 'mypy_extensions' */
    cpy_r_r19 = CPyStatic_ops___globals;
    cpy_r_r20 = CPyImport_ImportFromMany(cpy_r_r18, cpy_r_r17, cpy_r_r17, cpy_r_r19);
    if (unlikely(cpy_r_r20 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 17, CPyStatic_ops___globals);
        goto CPyL419;
    }
    CPyModule_mypy_extensions = cpy_r_r20;
    CPy_INCREF(CPyModule_mypy_extensions);
    CPy_DECREF(cpy_r_r20);
    cpy_r_r21 = CPyStatics[10021]; /* ('RArray', 'RInstance', 'RTuple', 'RType', 'RVoid',
                                      'bit_rprimitive', 'bool_rprimitive',
                                      'float_rprimitive', 'int_rprimitive',
                                      'is_bit_rprimitive', 'is_bool_rprimitive',
                                      'is_int_rprimitive', 'is_none_rprimitive',
                                      'is_pointer_rprimitive', 'is_short_int_rprimitive',
                                      'object_rprimitive', 'pointer_rprimitive',
                                      'short_int_rprimitive', 'void_rtype') */
    cpy_r_r22 = CPyStatics[6676]; /* 'mypyc.ir.rtypes' */
    cpy_r_r23 = CPyStatic_ops___globals;
    cpy_r_r24 = CPyImport_ImportFromMany(cpy_r_r22, cpy_r_r21, cpy_r_r21, cpy_r_r23);
    if (unlikely(cpy_r_r24 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 19, CPyStatic_ops___globals);
        goto CPyL419;
    }
    CPyModule_mypyc___ir___rtypes = cpy_r_r24;
    CPy_INCREF(CPyModule_mypyc___ir___rtypes);
    CPy_DECREF(cpy_r_r24);
    cpy_r_r25 = CPyStatic_ops___globals;
    cpy_r_r26 = CPyStatics[58]; /* 'TYPE_CHECKING' */
    cpy_r_r27 = CPyDict_GetItem(cpy_r_r25, cpy_r_r26);
    if (unlikely(cpy_r_r27 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 41, CPyStatic_ops___globals);
        goto CPyL419;
    }
    if (unlikely(!PyBool_Check(cpy_r_r27))) {
        CPy_TypeError("bool", cpy_r_r27); cpy_r_r28 = 2;
    } else
        cpy_r_r28 = cpy_r_r27 == Py_True;
    CPy_DECREF(cpy_r_r27);
    if (unlikely(cpy_r_r28 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 41, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r29 = CPyStatics[1088]; /* 'T' */
    cpy_r_r30 = CPyStatic_ops___globals;
    cpy_r_r31 = CPyStatics[902]; /* 'TypeVar' */
    cpy_r_r32 = CPyDict_GetItem(cpy_r_r30, cpy_r_r31);
    if (unlikely(cpy_r_r32 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 46, CPyStatic_ops___globals);
        goto CPyL419;
    }
    PyObject *cpy_r_r33[1] = {cpy_r_r29};
    cpy_r_r34 = (PyObject **)&cpy_r_r33;
    cpy_r_r35 = _PyObject_Vectorcall(cpy_r_r32, cpy_r_r34, 1, 0);
    CPy_DECREF(cpy_r_r32);
    if (unlikely(cpy_r_r35 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 46, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r36 = CPyStatic_ops___globals;
    cpy_r_r37 = CPyStatics[1088]; /* 'T' */
    cpy_r_r38 = CPyDict_SetItem(cpy_r_r36, cpy_r_r37, cpy_r_r35);
    CPy_DECREF(cpy_r_r35);
    cpy_r_r39 = cpy_r_r38 >= 0;
    if (unlikely(!cpy_r_r39)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 46, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r40 = NULL;
    cpy_r_r41 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r42 = (PyObject *)CPyType_ops___BasicBlock_template;
    cpy_r_r43 = CPyType_FromTemplate(cpy_r_r42, cpy_r_r40, cpy_r_r41);
    if (unlikely(cpy_r_r43 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 49, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r44 = CPyDef_ops___BasicBlock_trait_vtable_setup();
    if (unlikely(cpy_r_r44 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL420;
    }
    cpy_r_r45 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r46 = CPyStatics[6684]; /* 'label' */
    cpy_r_r47 = CPyStatics[2426]; /* 'ops' */
    cpy_r_r48 = CPyStatics[7821]; /* 'error_handler' */
    cpy_r_r49 = CPyStatics[7822]; /* 'referenced' */
    cpy_r_r50 = PyTuple_Pack(4, cpy_r_r46, cpy_r_r47, cpy_r_r48, cpy_r_r49);
    if (unlikely(cpy_r_r50 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 49, CPyStatic_ops___globals);
        goto CPyL420;
    }
    cpy_r_r51 = PyObject_SetAttr(cpy_r_r43, cpy_r_r45, cpy_r_r50);
    CPy_DECREF(cpy_r_r50);
    cpy_r_r52 = cpy_r_r51 >= 0;
    if (unlikely(!cpy_r_r52)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 49, CPyStatic_ops___globals);
        goto CPyL420;
    }
    CPyType_ops___BasicBlock = (PyTypeObject *)cpy_r_r43;
    CPy_INCREF(CPyType_ops___BasicBlock);
    cpy_r_r53 = CPyStatic_ops___globals;
    cpy_r_r54 = CPyStatics[6665]; /* 'BasicBlock' */
    cpy_r_r55 = CPyDict_SetItem(cpy_r_r53, cpy_r_r54, cpy_r_r43);
    CPy_DECREF(cpy_r_r43);
    cpy_r_r56 = cpy_r_r55 >= 0;
    if (unlikely(!cpy_r_r56)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 49, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r57 = CPyStatic_ops___globals;
    cpy_r_r58 = CPyStatics[7823]; /* 'ERR_NEVER' */
    cpy_r_r59 = CPyStatics[9015]; /* 0 */
    cpy_r_r60 = CPyDict_SetItem(cpy_r_r57, cpy_r_r58, cpy_r_r59);
    cpy_r_r61 = cpy_r_r60 >= 0;
    if (unlikely(!cpy_r_r61)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 102, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r62 = CPyStatic_ops___globals;
    cpy_r_r63 = CPyStatics[7824]; /* 'ERR_MAGIC' */
    cpy_r_r64 = CPyStatics[9016]; /* 1 */
    cpy_r_r65 = CPyDict_SetItem(cpy_r_r62, cpy_r_r63, cpy_r_r64);
    cpy_r_r66 = cpy_r_r65 >= 0;
    if (unlikely(!cpy_r_r66)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 104, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r67 = CPyStatic_ops___globals;
    cpy_r_r68 = CPyStatics[7402]; /* 'ERR_FALSE' */
    cpy_r_r69 = CPyStatics[9018]; /* 2 */
    cpy_r_r70 = CPyDict_SetItem(cpy_r_r67, cpy_r_r68, cpy_r_r69);
    cpy_r_r71 = cpy_r_r70 >= 0;
    if (unlikely(!cpy_r_r71)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 106, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r72 = CPyStatic_ops___globals;
    cpy_r_r73 = CPyStatics[7825]; /* 'ERR_ALWAYS' */
    cpy_r_r74 = CPyStatics[9026]; /* 3 */
    cpy_r_r75 = CPyDict_SetItem(cpy_r_r72, cpy_r_r73, cpy_r_r74);
    cpy_r_r76 = cpy_r_r75 >= 0;
    if (unlikely(!cpy_r_r76)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 108, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r77 = CPyStatic_ops___globals;
    cpy_r_r78 = CPyStatics[7826]; /* 'ERR_MAGIC_OVERLAPPING' */
    cpy_r_r79 = CPyStatics[9025]; /* 4 */
    cpy_r_r80 = CPyDict_SetItem(cpy_r_r77, cpy_r_r78, cpy_r_r79);
    cpy_r_r81 = cpy_r_r80 >= 0;
    if (unlikely(!cpy_r_r81)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 111, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r82 = CPyStatic_ops___globals;
    cpy_r_r83 = CPyStatics[7827]; /* 'NO_TRACEBACK_LINE_NO' */
    cpy_r_r84 = CPyStatics[9063]; /* -10000 */
    cpy_r_r85 = CPyDict_SetItem(cpy_r_r82, cpy_r_r83, cpy_r_r84);
    cpy_r_r86 = cpy_r_r85 >= 0;
    if (unlikely(!cpy_r_r86)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 114, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r87 = NULL;
    cpy_r_r88 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r89 = (PyObject *)CPyType_ops___Value_template;
    cpy_r_r90 = CPyType_FromTemplate(cpy_r_r89, cpy_r_r87, cpy_r_r88);
    if (unlikely(cpy_r_r90 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 117, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r91 = CPyDef_ops___Value_trait_vtable_setup();
    if (unlikely(cpy_r_r91 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL421;
    }
    cpy_r_r92 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r93 = CPyStatics[2272]; /* 'line' */
    cpy_r_r94 = CPyStatics[802]; /* 'type' */
    cpy_r_r95 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r96 = PyTuple_Pack(3, cpy_r_r93, cpy_r_r94, cpy_r_r95);
    if (unlikely(cpy_r_r96 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 117, CPyStatic_ops___globals);
        goto CPyL421;
    }
    cpy_r_r97 = PyObject_SetAttr(cpy_r_r90, cpy_r_r92, cpy_r_r96);
    CPy_DECREF(cpy_r_r96);
    cpy_r_r98 = cpy_r_r97 >= 0;
    if (unlikely(!cpy_r_r98)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 117, CPyStatic_ops___globals);
        goto CPyL421;
    }
    CPyType_ops___Value = (PyTypeObject *)cpy_r_r90;
    CPy_INCREF(CPyType_ops___Value);
    cpy_r_r99 = CPyStatic_ops___globals;
    cpy_r_r100 = CPyStatics[3407]; /* 'Value' */
    cpy_r_r101 = CPyDict_SetItem(cpy_r_r99, cpy_r_r100, cpy_r_r90);
    CPy_DECREF(cpy_r_r90);
    cpy_r_r102 = cpy_r_r101 >= 0;
    if (unlikely(!cpy_r_r102)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 117, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r103 = (PyObject *)CPyType_ops___Value;
    cpy_r_r104 = PyTuple_Pack(1, cpy_r_r103);
    if (unlikely(cpy_r_r104 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 144, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r105 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r106 = (PyObject *)CPyType_ops___Register_template;
    cpy_r_r107 = CPyType_FromTemplate(cpy_r_r106, cpy_r_r104, cpy_r_r105);
    CPy_DECREF(cpy_r_r104);
    if (unlikely(cpy_r_r107 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 144, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r108 = CPyDef_ops___Register_trait_vtable_setup();
    if (unlikely(cpy_r_r108 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL422;
    }
    cpy_r_r109 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r110 = CPyStatics[2329]; /* 'name' */
    cpy_r_r111 = CPyStatics[7829]; /* 'is_arg' */
    cpy_r_r112 = CPyStatics[2272]; /* 'line' */
    cpy_r_r113 = CPyStatics[802]; /* 'type' */
    cpy_r_r114 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r115 = PyTuple_Pack(5, cpy_r_r110, cpy_r_r111, cpy_r_r112, cpy_r_r113, cpy_r_r114);
    if (unlikely(cpy_r_r115 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 144, CPyStatic_ops___globals);
        goto CPyL422;
    }
    cpy_r_r116 = PyObject_SetAttr(cpy_r_r107, cpy_r_r109, cpy_r_r115);
    CPy_DECREF(cpy_r_r115);
    cpy_r_r117 = cpy_r_r116 >= 0;
    if (unlikely(!cpy_r_r117)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 144, CPyStatic_ops___globals);
        goto CPyL422;
    }
    CPyType_ops___Register = (PyTypeObject *)cpy_r_r107;
    CPy_INCREF(CPyType_ops___Register);
    cpy_r_r118 = CPyStatic_ops___globals;
    cpy_r_r119 = CPyStatics[6669]; /* 'Register' */
    cpy_r_r120 = CPyDict_SetItem(cpy_r_r118, cpy_r_r119, cpy_r_r107);
    CPy_DECREF(cpy_r_r107);
    cpy_r_r121 = cpy_r_r120 >= 0;
    if (unlikely(!cpy_r_r121)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 144, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r122 = (PyObject *)CPyType_ops___Value;
    cpy_r_r123 = PyTuple_Pack(1, cpy_r_r122);
    if (unlikely(cpy_r_r123 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 170, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r124 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r125 = (PyObject *)CPyType_ops___Integer_template;
    cpy_r_r126 = CPyType_FromTemplate(cpy_r_r125, cpy_r_r123, cpy_r_r124);
    CPy_DECREF(cpy_r_r123);
    if (unlikely(cpy_r_r126 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 170, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r127 = CPyDef_ops___Integer_trait_vtable_setup();
    if (unlikely(cpy_r_r127 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL423;
    }
    cpy_r_r128 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r129 = CPyStatics[2242]; /* 'value' */
    cpy_r_r130 = CPyStatics[2272]; /* 'line' */
    cpy_r_r131 = CPyStatics[802]; /* 'type' */
    cpy_r_r132 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r133 = PyTuple_Pack(4, cpy_r_r129, cpy_r_r130, cpy_r_r131, cpy_r_r132);
    if (unlikely(cpy_r_r133 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 170, CPyStatic_ops___globals);
        goto CPyL423;
    }
    cpy_r_r134 = PyObject_SetAttr(cpy_r_r126, cpy_r_r128, cpy_r_r133);
    CPy_DECREF(cpy_r_r133);
    cpy_r_r135 = cpy_r_r134 >= 0;
    if (unlikely(!cpy_r_r135)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 170, CPyStatic_ops___globals);
        goto CPyL423;
    }
    CPyType_ops___Integer = (PyTypeObject *)cpy_r_r126;
    CPy_INCREF(CPyType_ops___Integer);
    cpy_r_r136 = CPyStatic_ops___globals;
    cpy_r_r137 = CPyStatics[6704]; /* 'Integer' */
    cpy_r_r138 = CPyDict_SetItem(cpy_r_r136, cpy_r_r137, cpy_r_r126);
    CPy_DECREF(cpy_r_r126);
    cpy_r_r139 = cpy_r_r138 >= 0;
    if (unlikely(!cpy_r_r139)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 170, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r140 = (PyObject *)CPyType_ops___Value;
    cpy_r_r141 = PyTuple_Pack(1, cpy_r_r140);
    if (unlikely(cpy_r_r141 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 200, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r142 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r143 = (PyObject *)CPyType_ops___Float_template;
    cpy_r_r144 = CPyType_FromTemplate(cpy_r_r143, cpy_r_r141, cpy_r_r142);
    CPy_DECREF(cpy_r_r141);
    if (unlikely(cpy_r_r144 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 200, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r145 = CPyDef_ops___Float_trait_vtable_setup();
    if (unlikely(cpy_r_r145 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL424;
    }
    cpy_r_r146 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r147 = CPyStatics[2242]; /* 'value' */
    cpy_r_r148 = CPyStatics[2272]; /* 'line' */
    cpy_r_r149 = CPyStatics[802]; /* 'type' */
    cpy_r_r150 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r151 = PyTuple_Pack(4, cpy_r_r147, cpy_r_r148, cpy_r_r149, cpy_r_r150);
    if (unlikely(cpy_r_r151 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 200, CPyStatic_ops___globals);
        goto CPyL424;
    }
    cpy_r_r152 = PyObject_SetAttr(cpy_r_r144, cpy_r_r146, cpy_r_r151);
    CPy_DECREF(cpy_r_r151);
    cpy_r_r153 = cpy_r_r152 >= 0;
    if (unlikely(!cpy_r_r153)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 200, CPyStatic_ops___globals);
        goto CPyL424;
    }
    CPyType_ops___Float = (PyTypeObject *)cpy_r_r144;
    CPy_INCREF(CPyType_ops___Float);
    cpy_r_r154 = CPyStatic_ops___globals;
    cpy_r_r155 = CPyStatics[6698]; /* 'Float' */
    cpy_r_r156 = CPyDict_SetItem(cpy_r_r154, cpy_r_r155, cpy_r_r144);
    CPy_DECREF(cpy_r_r144);
    cpy_r_r157 = cpy_r_r156 >= 0;
    if (unlikely(!cpy_r_r157)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 200, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r158 = (PyObject *)CPyType_ops___Value;
    cpy_r_r159 = PyTuple_Pack(1, cpy_r_r158);
    if (unlikely(cpy_r_r159 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 214, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r160 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r161 = (PyObject *)CPyType_ops___Op_template;
    cpy_r_r162 = CPyType_FromTemplate(cpy_r_r161, cpy_r_r159, cpy_r_r160);
    CPy_DECREF(cpy_r_r159);
    if (unlikely(cpy_r_r162 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 214, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r163 = CPyDef_ops___Op_trait_vtable_setup();
    if (unlikely(cpy_r_r163 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL425;
    }
    cpy_r_r164 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r165 = CPyStatics[2272]; /* 'line' */
    cpy_r_r166 = CPyStatics[802]; /* 'type' */
    cpy_r_r167 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r168 = PyTuple_Pack(3, cpy_r_r165, cpy_r_r166, cpy_r_r167);
    if (unlikely(cpy_r_r168 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 214, CPyStatic_ops___globals);
        goto CPyL425;
    }
    cpy_r_r169 = PyObject_SetAttr(cpy_r_r162, cpy_r_r164, cpy_r_r168);
    CPy_DECREF(cpy_r_r168);
    cpy_r_r170 = cpy_r_r169 >= 0;
    if (unlikely(!cpy_r_r170)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 214, CPyStatic_ops___globals);
        goto CPyL425;
    }
    CPyType_ops___Op = (PyTypeObject *)cpy_r_r162;
    CPy_INCREF(CPyType_ops___Op);
    cpy_r_r171 = CPyStatic_ops___globals;
    cpy_r_r172 = CPyStatics[6714]; /* 'Op' */
    cpy_r_r173 = CPyDict_SetItem(cpy_r_r171, cpy_r_r172, cpy_r_r162);
    CPy_DECREF(cpy_r_r162);
    cpy_r_r174 = cpy_r_r173 >= 0;
    if (unlikely(!cpy_r_r174)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 214, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r175 = (PyObject *)CPyType_ops___Op;
    cpy_r_r176 = PyTuple_Pack(1, cpy_r_r175);
    if (unlikely(cpy_r_r176 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 254, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r177 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r178 = (PyObject *)CPyType_ops___BaseAssign_template;
    cpy_r_r179 = CPyType_FromTemplate(cpy_r_r178, cpy_r_r176, cpy_r_r177);
    CPy_DECREF(cpy_r_r176);
    if (unlikely(cpy_r_r179 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 254, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r180 = CPyDef_ops___BaseAssign_trait_vtable_setup();
    if (unlikely(cpy_r_r180 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL426;
    }
    cpy_r_r181 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r182 = CPyStatics[2747]; /* 'dest' */
    cpy_r_r183 = CPyStatics[2272]; /* 'line' */
    cpy_r_r184 = CPyStatics[802]; /* 'type' */
    cpy_r_r185 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r186 = PyTuple_Pack(4, cpy_r_r182, cpy_r_r183, cpy_r_r184, cpy_r_r185);
    if (unlikely(cpy_r_r186 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 254, CPyStatic_ops___globals);
        goto CPyL426;
    }
    cpy_r_r187 = PyObject_SetAttr(cpy_r_r179, cpy_r_r181, cpy_r_r186);
    CPy_DECREF(cpy_r_r186);
    cpy_r_r188 = cpy_r_r187 >= 0;
    if (unlikely(!cpy_r_r188)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 254, CPyStatic_ops___globals);
        goto CPyL426;
    }
    CPyType_ops___BaseAssign = (PyTypeObject *)cpy_r_r179;
    CPy_INCREF(CPyType_ops___BaseAssign);
    cpy_r_r189 = CPyStatic_ops___globals;
    cpy_r_r190 = CPyStatics[6754]; /* 'BaseAssign' */
    cpy_r_r191 = CPyDict_SetItem(cpy_r_r189, cpy_r_r190, cpy_r_r179);
    CPy_DECREF(cpy_r_r179);
    cpy_r_r192 = cpy_r_r191 >= 0;
    if (unlikely(!cpy_r_r192)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 254, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r193 = (PyObject *)CPyType_ops___BaseAssign;
    cpy_r_r194 = PyTuple_Pack(1, cpy_r_r193);
    if (unlikely(cpy_r_r194 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 262, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r195 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r196 = (PyObject *)CPyType_ops___Assign_template;
    cpy_r_r197 = CPyType_FromTemplate(cpy_r_r196, cpy_r_r194, cpy_r_r195);
    CPy_DECREF(cpy_r_r194);
    if (unlikely(cpy_r_r197 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 262, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r198 = CPyDef_ops___Assign_trait_vtable_setup();
    if (unlikely(cpy_r_r198 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL427;
    }
    cpy_r_r199 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r200 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r201 = CPyStatics[6937]; /* 'src' */
    cpy_r_r202 = CPyStatics[2747]; /* 'dest' */
    cpy_r_r203 = CPyStatics[2272]; /* 'line' */
    cpy_r_r204 = CPyStatics[802]; /* 'type' */
    cpy_r_r205 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r206 = PyTuple_Pack(6, cpy_r_r200, cpy_r_r201, cpy_r_r202, cpy_r_r203, cpy_r_r204, cpy_r_r205);
    if (unlikely(cpy_r_r206 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 262, CPyStatic_ops___globals);
        goto CPyL427;
    }
    cpy_r_r207 = PyObject_SetAttr(cpy_r_r197, cpy_r_r199, cpy_r_r206);
    CPy_DECREF(cpy_r_r206);
    cpy_r_r208 = cpy_r_r207 >= 0;
    if (unlikely(!cpy_r_r208)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 262, CPyStatic_ops___globals);
        goto CPyL427;
    }
    CPyType_ops___Assign = (PyTypeObject *)cpy_r_r197;
    CPy_INCREF(CPyType_ops___Assign);
    cpy_r_r209 = CPyStatic_ops___globals;
    cpy_r_r210 = CPyStatics[6663]; /* 'Assign' */
    cpy_r_r211 = CPyDict_SetItem(cpy_r_r209, cpy_r_r210, cpy_r_r197);
    CPy_DECREF(cpy_r_r197);
    cpy_r_r212 = cpy_r_r211 >= 0;
    if (unlikely(!cpy_r_r212)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 262, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r213 = (PyObject *)CPyType_ops___BaseAssign;
    cpy_r_r214 = PyTuple_Pack(1, cpy_r_r213);
    if (unlikely(cpy_r_r214 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 281, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r215 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r216 = (PyObject *)CPyType_ops___AssignMulti_template;
    cpy_r_r217 = CPyType_FromTemplate(cpy_r_r216, cpy_r_r214, cpy_r_r215);
    CPy_DECREF(cpy_r_r214);
    if (unlikely(cpy_r_r217 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 281, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r218 = CPyDef_ops___AssignMulti_trait_vtable_setup();
    if (unlikely(cpy_r_r218 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL428;
    }
    cpy_r_r219 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r220 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r221 = CPyStatics[6937]; /* 'src' */
    cpy_r_r222 = CPyStatics[2747]; /* 'dest' */
    cpy_r_r223 = CPyStatics[2272]; /* 'line' */
    cpy_r_r224 = CPyStatics[802]; /* 'type' */
    cpy_r_r225 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r226 = PyTuple_Pack(6, cpy_r_r220, cpy_r_r221, cpy_r_r222, cpy_r_r223, cpy_r_r224, cpy_r_r225);
    if (unlikely(cpy_r_r226 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 281, CPyStatic_ops___globals);
        goto CPyL428;
    }
    cpy_r_r227 = PyObject_SetAttr(cpy_r_r217, cpy_r_r219, cpy_r_r226);
    CPy_DECREF(cpy_r_r226);
    cpy_r_r228 = cpy_r_r227 >= 0;
    if (unlikely(!cpy_r_r228)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 281, CPyStatic_ops___globals);
        goto CPyL428;
    }
    CPyType_ops___AssignMulti = (PyTypeObject *)cpy_r_r217;
    CPy_INCREF(CPyType_ops___AssignMulti);
    cpy_r_r229 = CPyStatic_ops___globals;
    cpy_r_r230 = CPyStatics[6664]; /* 'AssignMulti' */
    cpy_r_r231 = CPyDict_SetItem(cpy_r_r229, cpy_r_r230, cpy_r_r217);
    CPy_DECREF(cpy_r_r217);
    cpy_r_r232 = cpy_r_r231 >= 0;
    if (unlikely(!cpy_r_r232)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 281, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r233 = (PyObject *)CPyType_ops___Op;
    cpy_r_r234 = PyTuple_Pack(1, cpy_r_r233);
    if (unlikely(cpy_r_r234 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 311, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r235 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r236 = (PyObject *)CPyType_ops___ControlOp_template;
    cpy_r_r237 = CPyType_FromTemplate(cpy_r_r236, cpy_r_r234, cpy_r_r235);
    CPy_DECREF(cpy_r_r234);
    if (unlikely(cpy_r_r237 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 311, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r238 = CPyDef_ops___ControlOp_trait_vtable_setup();
    if (unlikely(cpy_r_r238 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL429;
    }
    cpy_r_r239 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r240 = CPyStatics[2272]; /* 'line' */
    cpy_r_r241 = CPyStatics[802]; /* 'type' */
    cpy_r_r242 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r243 = PyTuple_Pack(3, cpy_r_r240, cpy_r_r241, cpy_r_r242);
    if (unlikely(cpy_r_r243 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 311, CPyStatic_ops___globals);
        goto CPyL429;
    }
    cpy_r_r244 = PyObject_SetAttr(cpy_r_r237, cpy_r_r239, cpy_r_r243);
    CPy_DECREF(cpy_r_r243);
    cpy_r_r245 = cpy_r_r244 >= 0;
    if (unlikely(!cpy_r_r245)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 311, CPyStatic_ops___globals);
        goto CPyL429;
    }
    CPyType_ops___ControlOp = (PyTypeObject *)cpy_r_r237;
    CPy_INCREF(CPyType_ops___ControlOp);
    cpy_r_r246 = CPyStatic_ops___globals;
    cpy_r_r247 = CPyStatics[6667]; /* 'ControlOp' */
    cpy_r_r248 = CPyDict_SetItem(cpy_r_r246, cpy_r_r247, cpy_r_r237);
    CPy_DECREF(cpy_r_r237);
    cpy_r_r249 = cpy_r_r248 >= 0;
    if (unlikely(!cpy_r_r249)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 311, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r250 = (PyObject *)CPyType_ops___ControlOp;
    cpy_r_r251 = PyTuple_Pack(1, cpy_r_r250);
    if (unlikely(cpy_r_r251 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 323, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r252 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r253 = (PyObject *)CPyType_ops___Goto_template;
    cpy_r_r254 = CPyType_FromTemplate(cpy_r_r253, cpy_r_r251, cpy_r_r252);
    CPy_DECREF(cpy_r_r251);
    if (unlikely(cpy_r_r254 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 323, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r255 = CPyDef_ops___Goto_trait_vtable_setup();
    if (unlikely(cpy_r_r255 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL430;
    }
    cpy_r_r256 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r257 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r258 = CPyStatics[6684]; /* 'label' */
    cpy_r_r259 = CPyStatics[2272]; /* 'line' */
    cpy_r_r260 = CPyStatics[802]; /* 'type' */
    cpy_r_r261 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r262 = PyTuple_Pack(5, cpy_r_r257, cpy_r_r258, cpy_r_r259, cpy_r_r260, cpy_r_r261);
    if (unlikely(cpy_r_r262 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 323, CPyStatic_ops___globals);
        goto CPyL430;
    }
    cpy_r_r263 = PyObject_SetAttr(cpy_r_r254, cpy_r_r256, cpy_r_r262);
    CPy_DECREF(cpy_r_r262);
    cpy_r_r264 = cpy_r_r263 >= 0;
    if (unlikely(!cpy_r_r264)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 323, CPyStatic_ops___globals);
        goto CPyL430;
    }
    CPyType_ops___Goto = (PyTypeObject *)cpy_r_r254;
    CPy_INCREF(CPyType_ops___Goto);
    cpy_r_r265 = CPyStatic_ops___globals;
    cpy_r_r266 = CPyStatics[6683]; /* 'Goto' */
    cpy_r_r267 = CPyDict_SetItem(cpy_r_r265, cpy_r_r266, cpy_r_r254);
    CPy_DECREF(cpy_r_r254);
    cpy_r_r268 = cpy_r_r267 >= 0;
    if (unlikely(!cpy_r_r268)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 323, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r269 = (PyObject *)CPyType_ops___ControlOp;
    cpy_r_r270 = PyTuple_Pack(1, cpy_r_r269);
    if (unlikely(cpy_r_r270 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 349, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r271 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r272 = (PyObject *)CPyType_ops___Branch_template;
    cpy_r_r273 = CPyType_FromTemplate(cpy_r_r272, cpy_r_r270, cpy_r_r271);
    CPy_DECREF(cpy_r_r270);
    if (unlikely(cpy_r_r273 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 349, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r274 = CPyDef_ops___Branch_trait_vtable_setup();
    if (unlikely(cpy_r_r274 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL431;
    }
    cpy_r_r275 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r276 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r277 = CPyStatics[7831]; /* 'BOOL' */
    cpy_r_r278 = CPyStatics[7832]; /* 'IS_ERROR' */
    cpy_r_r279 = CPyStatics[2242]; /* 'value' */
    cpy_r_r280 = CPyStatics[7833]; /* 'true' */
    cpy_r_r281 = CPyStatics[7834]; /* 'false' */
    cpy_r_r282 = CPyStatics[1628]; /* 'op' */
    cpy_r_r283 = CPyStatics[7835]; /* 'negated' */
    cpy_r_r284 = CPyStatics[7062]; /* 'traceback_entry' */
    cpy_r_r285 = CPyStatics[7412]; /* 'rare' */
    cpy_r_r286 = CPyStatics[2272]; /* 'line' */
    cpy_r_r287 = CPyStatics[802]; /* 'type' */
    cpy_r_r288 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r289 = PyTuple_Pack(13, cpy_r_r276, cpy_r_r277, cpy_r_r278, cpy_r_r279, cpy_r_r280, cpy_r_r281, cpy_r_r282, cpy_r_r283, cpy_r_r284, cpy_r_r285, cpy_r_r286, cpy_r_r287, cpy_r_r288);
    if (unlikely(cpy_r_r289 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 349, CPyStatic_ops___globals);
        goto CPyL431;
    }
    cpy_r_r290 = PyObject_SetAttr(cpy_r_r273, cpy_r_r275, cpy_r_r289);
    CPy_DECREF(cpy_r_r289);
    cpy_r_r291 = cpy_r_r290 >= 0;
    if (unlikely(!cpy_r_r291)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 349, CPyStatic_ops___globals);
        goto CPyL431;
    }
    CPyType_ops___Branch = (PyTypeObject *)cpy_r_r273;
    CPy_INCREF(CPyType_ops___Branch);
    cpy_r_r292 = CPyStatic_ops___globals;
    cpy_r_r293 = CPyStatics[6666]; /* 'Branch' */
    cpy_r_r294 = CPyDict_SetItem(cpy_r_r292, cpy_r_r293, cpy_r_r273);
    CPy_DECREF(cpy_r_r273);
    cpy_r_r295 = cpy_r_r294 >= 0;
    if (unlikely(!cpy_r_r295)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 349, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r296 = (PyObject *)CPyType_ops___Branch;
    cpy_r_r297 = CPyStatics[7831]; /* 'BOOL' */
    cpy_r_r298 = CPyStatics[9029]; /* 100 */
    cpy_r_r299 = PyObject_SetAttr(cpy_r_r296, cpy_r_r297, cpy_r_r298);
    cpy_r_r300 = cpy_r_r299 >= 0;
    if (unlikely(!cpy_r_r300)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 362, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r301 = (PyObject *)CPyType_ops___Branch;
    cpy_r_r302 = CPyStatics[7832]; /* 'IS_ERROR' */
    cpy_r_r303 = CPyStatics[9053]; /* 101 */
    cpy_r_r304 = PyObject_SetAttr(cpy_r_r301, cpy_r_r302, cpy_r_r303);
    cpy_r_r305 = cpy_r_r304 >= 0;
    if (unlikely(!cpy_r_r305)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 363, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r306 = (PyObject *)CPyType_ops___ControlOp;
    cpy_r_r307 = PyTuple_Pack(1, cpy_r_r306);
    if (unlikely(cpy_r_r307 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 412, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r308 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r309 = (PyObject *)CPyType_ops___Return_template;
    cpy_r_r310 = CPyType_FromTemplate(cpy_r_r309, cpy_r_r307, cpy_r_r308);
    CPy_DECREF(cpy_r_r307);
    if (unlikely(cpy_r_r310 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 412, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r311 = CPyDef_ops___Return_trait_vtable_setup();
    if (unlikely(cpy_r_r311 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL432;
    }
    cpy_r_r312 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r313 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r314 = CPyStatics[2242]; /* 'value' */
    cpy_r_r315 = CPyStatics[2272]; /* 'line' */
    cpy_r_r316 = CPyStatics[802]; /* 'type' */
    cpy_r_r317 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r318 = PyTuple_Pack(5, cpy_r_r313, cpy_r_r314, cpy_r_r315, cpy_r_r316, cpy_r_r317);
    if (unlikely(cpy_r_r318 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 412, CPyStatic_ops___globals);
        goto CPyL432;
    }
    cpy_r_r319 = PyObject_SetAttr(cpy_r_r310, cpy_r_r312, cpy_r_r318);
    CPy_DECREF(cpy_r_r318);
    cpy_r_r320 = cpy_r_r319 >= 0;
    if (unlikely(!cpy_r_r320)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 412, CPyStatic_ops___globals);
        goto CPyL432;
    }
    CPyType_ops___Return = (PyTypeObject *)cpy_r_r310;
    CPy_INCREF(CPyType_ops___Return);
    cpy_r_r321 = CPyStatic_ops___globals;
    cpy_r_r322 = CPyStatics[2419]; /* 'Return' */
    cpy_r_r323 = CPyDict_SetItem(cpy_r_r321, cpy_r_r322, cpy_r_r310);
    CPy_DECREF(cpy_r_r310);
    cpy_r_r324 = cpy_r_r323 >= 0;
    if (unlikely(!cpy_r_r324)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 412, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r325 = (PyObject *)CPyType_ops___ControlOp;
    cpy_r_r326 = PyTuple_Pack(1, cpy_r_r325);
    if (unlikely(cpy_r_r326 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 431, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r327 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r328 = (PyObject *)CPyType_ops___Unreachable_template;
    cpy_r_r329 = CPyType_FromTemplate(cpy_r_r328, cpy_r_r326, cpy_r_r327);
    CPy_DECREF(cpy_r_r326);
    if (unlikely(cpy_r_r329 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 431, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r330 = CPyDef_ops___Unreachable_trait_vtable_setup();
    if (unlikely(cpy_r_r330 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL433;
    }
    cpy_r_r331 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r332 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r333 = CPyStatics[2272]; /* 'line' */
    cpy_r_r334 = CPyStatics[802]; /* 'type' */
    cpy_r_r335 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r336 = PyTuple_Pack(4, cpy_r_r332, cpy_r_r333, cpy_r_r334, cpy_r_r335);
    if (unlikely(cpy_r_r336 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 431, CPyStatic_ops___globals);
        goto CPyL433;
    }
    cpy_r_r337 = PyObject_SetAttr(cpy_r_r329, cpy_r_r331, cpy_r_r336);
    CPy_DECREF(cpy_r_r336);
    cpy_r_r338 = cpy_r_r337 >= 0;
    if (unlikely(!cpy_r_r338)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 431, CPyStatic_ops___globals);
        goto CPyL433;
    }
    CPyType_ops___Unreachable = (PyTypeObject *)cpy_r_r329;
    CPy_INCREF(CPyType_ops___Unreachable);
    cpy_r_r339 = CPyStatic_ops___globals;
    cpy_r_r340 = CPyStatics[6673]; /* 'Unreachable' */
    cpy_r_r341 = CPyDict_SetItem(cpy_r_r339, cpy_r_r340, cpy_r_r329);
    CPy_DECREF(cpy_r_r329);
    cpy_r_r342 = cpy_r_r341 >= 0;
    if (unlikely(!cpy_r_r342)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 431, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r343 = (PyObject *)CPyType_ops___Op;
    cpy_r_r344 = PyTuple_Pack(1, cpy_r_r343);
    if (unlikely(cpy_r_r344 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 459, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r345 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r346 = (PyObject *)CPyType_ops___RegisterOp_template;
    cpy_r_r347 = CPyType_FromTemplate(cpy_r_r346, cpy_r_r344, cpy_r_r345);
    CPy_DECREF(cpy_r_r344);
    if (unlikely(cpy_r_r347 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 459, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r348 = CPyDef_ops___RegisterOp_trait_vtable_setup();
    if (unlikely(cpy_r_r348 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL434;
    }
    cpy_r_r349 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r350 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r351 = CPyStatics[5126]; /* '_type' */
    cpy_r_r352 = CPyStatics[2272]; /* 'line' */
    cpy_r_r353 = CPyStatics[802]; /* 'type' */
    cpy_r_r354 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r355 = PyTuple_Pack(5, cpy_r_r350, cpy_r_r351, cpy_r_r352, cpy_r_r353, cpy_r_r354);
    if (unlikely(cpy_r_r355 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 459, CPyStatic_ops___globals);
        goto CPyL434;
    }
    cpy_r_r356 = PyObject_SetAttr(cpy_r_r347, cpy_r_r349, cpy_r_r355);
    CPy_DECREF(cpy_r_r355);
    cpy_r_r357 = cpy_r_r356 >= 0;
    if (unlikely(!cpy_r_r357)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 459, CPyStatic_ops___globals);
        goto CPyL434;
    }
    CPyType_ops___RegisterOp = (PyTypeObject *)cpy_r_r347;
    CPy_INCREF(CPyType_ops___RegisterOp);
    cpy_r_r358 = CPyStatic_ops___globals;
    cpy_r_r359 = CPyStatics[6670]; /* 'RegisterOp' */
    cpy_r_r360 = CPyDict_SetItem(cpy_r_r358, cpy_r_r359, cpy_r_r347);
    CPy_DECREF(cpy_r_r347);
    cpy_r_r361 = cpy_r_r360 >= 0;
    if (unlikely(!cpy_r_r361)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 459, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r362 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r363 = PyTuple_Pack(1, cpy_r_r362);
    if (unlikely(cpy_r_r363 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 484, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r364 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r365 = (PyObject *)CPyType_ops___IncRef_template;
    cpy_r_r366 = CPyType_FromTemplate(cpy_r_r365, cpy_r_r363, cpy_r_r364);
    CPy_DECREF(cpy_r_r363);
    if (unlikely(cpy_r_r366 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 484, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r367 = CPyDef_ops___IncRef_trait_vtable_setup();
    if (unlikely(cpy_r_r367 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL435;
    }
    cpy_r_r368 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r369 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r370 = CPyStatics[6937]; /* 'src' */
    cpy_r_r371 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r372 = CPyStatics[5126]; /* '_type' */
    cpy_r_r373 = CPyStatics[2272]; /* 'line' */
    cpy_r_r374 = CPyStatics[802]; /* 'type' */
    cpy_r_r375 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r376 = PyTuple_Pack(7, cpy_r_r369, cpy_r_r370, cpy_r_r371, cpy_r_r372, cpy_r_r373, cpy_r_r374, cpy_r_r375);
    if (unlikely(cpy_r_r376 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 484, CPyStatic_ops___globals);
        goto CPyL435;
    }
    cpy_r_r377 = PyObject_SetAttr(cpy_r_r366, cpy_r_r368, cpy_r_r376);
    CPy_DECREF(cpy_r_r376);
    cpy_r_r378 = cpy_r_r377 >= 0;
    if (unlikely(!cpy_r_r378)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 484, CPyStatic_ops___globals);
        goto CPyL435;
    }
    CPyType_ops___IncRef = (PyTypeObject *)cpy_r_r366;
    CPy_INCREF(CPyType_ops___IncRef);
    cpy_r_r379 = CPyStatic_ops___globals;
    cpy_r_r380 = CPyStatics[6756]; /* 'IncRef' */
    cpy_r_r381 = CPyDict_SetItem(cpy_r_r379, cpy_r_r380, cpy_r_r366);
    CPy_DECREF(cpy_r_r366);
    cpy_r_r382 = cpy_r_r381 >= 0;
    if (unlikely(!cpy_r_r382)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 484, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r383 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r384 = PyTuple_Pack(1, cpy_r_r383);
    if (unlikely(cpy_r_r384 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 501, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r385 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r386 = (PyObject *)CPyType_ops___DecRef_template;
    cpy_r_r387 = CPyType_FromTemplate(cpy_r_r386, cpy_r_r384, cpy_r_r385);
    CPy_DECREF(cpy_r_r384);
    if (unlikely(cpy_r_r387 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 501, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r388 = CPyDef_ops___DecRef_trait_vtable_setup();
    if (unlikely(cpy_r_r388 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL436;
    }
    cpy_r_r389 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r390 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r391 = CPyStatics[6937]; /* 'src' */
    cpy_r_r392 = CPyStatics[7836]; /* 'is_xdec' */
    cpy_r_r393 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r394 = CPyStatics[5126]; /* '_type' */
    cpy_r_r395 = CPyStatics[2272]; /* 'line' */
    cpy_r_r396 = CPyStatics[802]; /* 'type' */
    cpy_r_r397 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r398 = PyTuple_Pack(8, cpy_r_r390, cpy_r_r391, cpy_r_r392, cpy_r_r393, cpy_r_r394, cpy_r_r395, cpy_r_r396, cpy_r_r397);
    if (unlikely(cpy_r_r398 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 501, CPyStatic_ops___globals);
        goto CPyL436;
    }
    cpy_r_r399 = PyObject_SetAttr(cpy_r_r387, cpy_r_r389, cpy_r_r398);
    CPy_DECREF(cpy_r_r398);
    cpy_r_r400 = cpy_r_r399 >= 0;
    if (unlikely(!cpy_r_r400)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 501, CPyStatic_ops___globals);
        goto CPyL436;
    }
    CPyType_ops___DecRef = (PyTypeObject *)cpy_r_r387;
    CPy_INCREF(CPyType_ops___DecRef);
    cpy_r_r401 = CPyStatic_ops___globals;
    cpy_r_r402 = CPyStatics[6755]; /* 'DecRef' */
    cpy_r_r403 = CPyDict_SetItem(cpy_r_r401, cpy_r_r402, cpy_r_r387);
    CPy_DECREF(cpy_r_r387);
    cpy_r_r404 = cpy_r_r403 >= 0;
    if (unlikely(!cpy_r_r404)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 501, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r405 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r406 = PyTuple_Pack(1, cpy_r_r405);
    if (unlikely(cpy_r_r406 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 526, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r407 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r408 = (PyObject *)CPyType_ops___Call_template;
    cpy_r_r409 = CPyType_FromTemplate(cpy_r_r408, cpy_r_r406, cpy_r_r407);
    CPy_DECREF(cpy_r_r406);
    if (unlikely(cpy_r_r409 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 526, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r410 = CPyDef_ops___Call_trait_vtable_setup();
    if (unlikely(cpy_r_r410 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL437;
    }
    cpy_r_r411 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r412 = CPyStatics[7837]; /* 'fn' */
    cpy_r_r413 = CPyStatics[1678]; /* 'args' */
    cpy_r_r414 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r415 = CPyStatics[5126]; /* '_type' */
    cpy_r_r416 = CPyStatics[2272]; /* 'line' */
    cpy_r_r417 = CPyStatics[802]; /* 'type' */
    cpy_r_r418 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r419 = PyTuple_Pack(7, cpy_r_r412, cpy_r_r413, cpy_r_r414, cpy_r_r415, cpy_r_r416, cpy_r_r417, cpy_r_r418);
    if (unlikely(cpy_r_r419 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 526, CPyStatic_ops___globals);
        goto CPyL437;
    }
    cpy_r_r420 = PyObject_SetAttr(cpy_r_r409, cpy_r_r411, cpy_r_r419);
    CPy_DECREF(cpy_r_r419);
    cpy_r_r421 = cpy_r_r420 >= 0;
    if (unlikely(!cpy_r_r421)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 526, CPyStatic_ops___globals);
        goto CPyL437;
    }
    CPyType_ops___Call = (PyTypeObject *)cpy_r_r409;
    CPy_INCREF(CPyType_ops___Call);
    cpy_r_r422 = CPyStatic_ops___globals;
    cpy_r_r423 = CPyStatics[2499]; /* 'Call' */
    cpy_r_r424 = CPyDict_SetItem(cpy_r_r422, cpy_r_r423, cpy_r_r409);
    CPy_DECREF(cpy_r_r409);
    cpy_r_r425 = cpy_r_r424 >= 0;
    if (unlikely(!cpy_r_r425)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 526, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r426 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r427 = PyTuple_Pack(1, cpy_r_r426);
    if (unlikely(cpy_r_r427 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 551, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r428 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r429 = (PyObject *)CPyType_ops___MethodCall_template;
    cpy_r_r430 = CPyType_FromTemplate(cpy_r_r429, cpy_r_r427, cpy_r_r428);
    CPy_DECREF(cpy_r_r427);
    if (unlikely(cpy_r_r430 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 551, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r431 = CPyDef_ops___MethodCall_trait_vtable_setup();
    if (unlikely(cpy_r_r431 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL438;
    }
    cpy_r_r432 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r433 = CPyStatics[7838]; /* 'obj' */
    cpy_r_r434 = CPyStatics[6083]; /* 'method' */
    cpy_r_r435 = CPyStatics[1678]; /* 'args' */
    cpy_r_r436 = CPyStatics[7839]; /* 'receiver_type' */
    cpy_r_r437 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r438 = CPyStatics[5126]; /* '_type' */
    cpy_r_r439 = CPyStatics[2272]; /* 'line' */
    cpy_r_r440 = CPyStatics[802]; /* 'type' */
    cpy_r_r441 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r442 = PyTuple_Pack(9, cpy_r_r433, cpy_r_r434, cpy_r_r435, cpy_r_r436, cpy_r_r437, cpy_r_r438, cpy_r_r439, cpy_r_r440, cpy_r_r441);
    if (unlikely(cpy_r_r442 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 551, CPyStatic_ops___globals);
        goto CPyL438;
    }
    cpy_r_r443 = PyObject_SetAttr(cpy_r_r430, cpy_r_r432, cpy_r_r442);
    CPy_DECREF(cpy_r_r442);
    cpy_r_r444 = cpy_r_r443 >= 0;
    if (unlikely(!cpy_r_r444)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 551, CPyStatic_ops___globals);
        goto CPyL438;
    }
    CPyType_ops___MethodCall = (PyTypeObject *)cpy_r_r430;
    CPy_INCREF(CPyType_ops___MethodCall);
    cpy_r_r445 = CPyStatic_ops___globals;
    cpy_r_r446 = CPyStatics[6713]; /* 'MethodCall' */
    cpy_r_r447 = CPyDict_SetItem(cpy_r_r445, cpy_r_r446, cpy_r_r430);
    CPy_DECREF(cpy_r_r430);
    cpy_r_r448 = cpy_r_r447 >= 0;
    if (unlikely(!cpy_r_r448)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 551, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r449 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r450 = PyTuple_Pack(1, cpy_r_r449);
    if (unlikely(cpy_r_r450 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 579, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r451 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r452 = (PyObject *)CPyType_ops___LoadErrorValue_template;
    cpy_r_r453 = CPyType_FromTemplate(cpy_r_r452, cpy_r_r450, cpy_r_r451);
    CPy_DECREF(cpy_r_r450);
    if (unlikely(cpy_r_r453 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 579, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r454 = CPyDef_ops___LoadErrorValue_trait_vtable_setup();
    if (unlikely(cpy_r_r454 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL439;
    }
    cpy_r_r455 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r456 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r457 = CPyStatics[7840]; /* 'undefines' */
    cpy_r_r458 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r459 = CPyStatics[5126]; /* '_type' */
    cpy_r_r460 = CPyStatics[2272]; /* 'line' */
    cpy_r_r461 = CPyStatics[802]; /* 'type' */
    cpy_r_r462 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r463 = PyTuple_Pack(7, cpy_r_r456, cpy_r_r457, cpy_r_r458, cpy_r_r459, cpy_r_r460, cpy_r_r461, cpy_r_r462);
    if (unlikely(cpy_r_r463 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 579, CPyStatic_ops___globals);
        goto CPyL439;
    }
    cpy_r_r464 = PyObject_SetAttr(cpy_r_r453, cpy_r_r455, cpy_r_r463);
    CPy_DECREF(cpy_r_r463);
    cpy_r_r465 = cpy_r_r464 >= 0;
    if (unlikely(!cpy_r_r465)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 579, CPyStatic_ops___globals);
        goto CPyL439;
    }
    CPyType_ops___LoadErrorValue = (PyTypeObject *)cpy_r_r453;
    CPy_INCREF(CPyType_ops___LoadErrorValue);
    cpy_r_r466 = CPyStatic_ops___globals;
    cpy_r_r467 = CPyStatics[6708]; /* 'LoadErrorValue' */
    cpy_r_r468 = CPyDict_SetItem(cpy_r_r466, cpy_r_r467, cpy_r_r453);
    CPy_DECREF(cpy_r_r453);
    cpy_r_r469 = cpy_r_r468 >= 0;
    if (unlikely(!cpy_r_r469)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 579, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r470 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r471 = PyTuple_Pack(1, cpy_r_r470);
    if (unlikely(cpy_r_r471 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 606, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r472 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r473 = (PyObject *)CPyType_ops___LoadLiteral_template;
    cpy_r_r474 = CPyType_FromTemplate(cpy_r_r473, cpy_r_r471, cpy_r_r472);
    CPy_DECREF(cpy_r_r471);
    if (unlikely(cpy_r_r474 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 606, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r475 = CPyDef_ops___LoadLiteral_trait_vtable_setup();
    if (unlikely(cpy_r_r475 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL440;
    }
    cpy_r_r476 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r477 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r478 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r479 = CPyStatics[2242]; /* 'value' */
    cpy_r_r480 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r481 = CPyStatics[5126]; /* '_type' */
    cpy_r_r482 = CPyStatics[2272]; /* 'line' */
    cpy_r_r483 = CPyStatics[802]; /* 'type' */
    cpy_r_r484 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r485 = PyTuple_Pack(8, cpy_r_r477, cpy_r_r478, cpy_r_r479, cpy_r_r480, cpy_r_r481, cpy_r_r482, cpy_r_r483, cpy_r_r484);
    if (unlikely(cpy_r_r485 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 606, CPyStatic_ops___globals);
        goto CPyL440;
    }
    cpy_r_r486 = PyObject_SetAttr(cpy_r_r474, cpy_r_r476, cpy_r_r485);
    CPy_DECREF(cpy_r_r485);
    cpy_r_r487 = cpy_r_r486 >= 0;
    if (unlikely(!cpy_r_r487)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 606, CPyStatic_ops___globals);
        goto CPyL440;
    }
    CPyType_ops___LoadLiteral = (PyTypeObject *)cpy_r_r474;
    CPy_INCREF(CPyType_ops___LoadLiteral);
    cpy_r_r488 = CPyStatic_ops___globals;
    cpy_r_r489 = CPyStatics[6710]; /* 'LoadLiteral' */
    cpy_r_r490 = CPyDict_SetItem(cpy_r_r488, cpy_r_r489, cpy_r_r474);
    CPy_DECREF(cpy_r_r474);
    cpy_r_r491 = cpy_r_r490 >= 0;
    if (unlikely(!cpy_r_r491)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 606, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r492 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r493 = PyTuple_Pack(1, cpy_r_r492);
    if (unlikely(cpy_r_r493 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 638, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r494 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r495 = (PyObject *)CPyType_ops___GetAttr_template;
    cpy_r_r496 = CPyType_FromTemplate(cpy_r_r495, cpy_r_r493, cpy_r_r494);
    CPy_DECREF(cpy_r_r493);
    if (unlikely(cpy_r_r496 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 638, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r497 = CPyDef_ops___GetAttr_trait_vtable_setup();
    if (unlikely(cpy_r_r497 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL441;
    }
    cpy_r_r498 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r499 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r500 = CPyStatics[7838]; /* 'obj' */
    cpy_r_r501 = CPyStatics[2363]; /* 'attr' */
    cpy_r_r502 = CPyStatics[7841]; /* 'class_type' */
    cpy_r_r503 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r504 = CPyStatics[5126]; /* '_type' */
    cpy_r_r505 = CPyStatics[2272]; /* 'line' */
    cpy_r_r506 = CPyStatics[802]; /* 'type' */
    cpy_r_r507 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r508 = PyTuple_Pack(9, cpy_r_r499, cpy_r_r500, cpy_r_r501, cpy_r_r502, cpy_r_r503, cpy_r_r504, cpy_r_r505, cpy_r_r506, cpy_r_r507);
    if (unlikely(cpy_r_r508 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 638, CPyStatic_ops___globals);
        goto CPyL441;
    }
    cpy_r_r509 = PyObject_SetAttr(cpy_r_r496, cpy_r_r498, cpy_r_r508);
    CPy_DECREF(cpy_r_r508);
    cpy_r_r510 = cpy_r_r509 >= 0;
    if (unlikely(!cpy_r_r510)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 638, CPyStatic_ops___globals);
        goto CPyL441;
    }
    CPyType_ops___GetAttr = (PyTypeObject *)cpy_r_r496;
    CPy_INCREF(CPyType_ops___GetAttr);
    cpy_r_r511 = CPyStatic_ops___globals;
    cpy_r_r512 = CPyStatics[6668]; /* 'GetAttr' */
    cpy_r_r513 = CPyDict_SetItem(cpy_r_r511, cpy_r_r512, cpy_r_r496);
    CPy_DECREF(cpy_r_r496);
    cpy_r_r514 = cpy_r_r513 >= 0;
    if (unlikely(!cpy_r_r514)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 638, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r515 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r516 = PyTuple_Pack(1, cpy_r_r515);
    if (unlikely(cpy_r_r516 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 662, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r517 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r518 = (PyObject *)CPyType_ops___SetAttr_template;
    cpy_r_r519 = CPyType_FromTemplate(cpy_r_r518, cpy_r_r516, cpy_r_r517);
    CPy_DECREF(cpy_r_r516);
    if (unlikely(cpy_r_r519 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 662, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r520 = CPyDef_ops___SetAttr_trait_vtable_setup();
    if (unlikely(cpy_r_r520 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL442;
    }
    cpy_r_r521 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r522 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r523 = CPyStatics[7838]; /* 'obj' */
    cpy_r_r524 = CPyStatics[2363]; /* 'attr' */
    cpy_r_r525 = CPyStatics[6937]; /* 'src' */
    cpy_r_r526 = CPyStatics[7841]; /* 'class_type' */
    cpy_r_r527 = CPyStatics[7842]; /* 'is_init' */
    cpy_r_r528 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r529 = CPyStatics[5126]; /* '_type' */
    cpy_r_r530 = CPyStatics[2272]; /* 'line' */
    cpy_r_r531 = CPyStatics[802]; /* 'type' */
    cpy_r_r532 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r533 = PyTuple_Pack(11, cpy_r_r522, cpy_r_r523, cpy_r_r524, cpy_r_r525, cpy_r_r526, cpy_r_r527, cpy_r_r528, cpy_r_r529, cpy_r_r530, cpy_r_r531, cpy_r_r532);
    if (unlikely(cpy_r_r533 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 662, CPyStatic_ops___globals);
        goto CPyL442;
    }
    cpy_r_r534 = PyObject_SetAttr(cpy_r_r519, cpy_r_r521, cpy_r_r533);
    CPy_DECREF(cpy_r_r533);
    cpy_r_r535 = cpy_r_r534 >= 0;
    if (unlikely(!cpy_r_r535)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 662, CPyStatic_ops___globals);
        goto CPyL442;
    }
    CPyType_ops___SetAttr = (PyTypeObject *)cpy_r_r519;
    CPy_INCREF(CPyType_ops___SetAttr);
    cpy_r_r536 = CPyStatic_ops___globals;
    cpy_r_r537 = CPyStatics[6671]; /* 'SetAttr' */
    cpy_r_r538 = CPyDict_SetItem(cpy_r_r536, cpy_r_r537, cpy_r_r519);
    CPy_DECREF(cpy_r_r519);
    cpy_r_r539 = cpy_r_r538 >= 0;
    if (unlikely(!cpy_r_r539)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 662, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r540 = CPyStatics[7396]; /* 'static' */
    cpy_r_r541 = CPyStatic_ops___globals;
    cpy_r_r542 = CPyStatics[7404]; /* 'NAMESPACE_STATIC' */
    cpy_r_r543 = CPyDict_SetItem(cpy_r_r541, cpy_r_r542, cpy_r_r540);
    cpy_r_r544 = cpy_r_r543 >= 0;
    if (unlikely(!cpy_r_r544)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 698, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r545 = CPyStatics[802]; /* 'type' */
    cpy_r_r546 = CPyStatic_ops___globals;
    cpy_r_r547 = CPyStatics[7405]; /* 'NAMESPACE_TYPE' */
    cpy_r_r548 = CPyDict_SetItem(cpy_r_r546, cpy_r_r547, cpy_r_r545);
    cpy_r_r549 = cpy_r_r548 >= 0;
    if (unlikely(!cpy_r_r549)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 701, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r550 = CPyStatics[408]; /* 'module' */
    cpy_r_r551 = CPyStatic_ops___globals;
    cpy_r_r552 = CPyStatics[7403]; /* 'NAMESPACE_MODULE' */
    cpy_r_r553 = CPyDict_SetItem(cpy_r_r551, cpy_r_r552, cpy_r_r550);
    cpy_r_r554 = cpy_r_r553 >= 0;
    if (unlikely(!cpy_r_r554)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 704, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r555 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r556 = PyTuple_Pack(1, cpy_r_r555);
    if (unlikely(cpy_r_r556 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 707, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r557 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r558 = (PyObject *)CPyType_ops___LoadStatic_template;
    cpy_r_r559 = CPyType_FromTemplate(cpy_r_r558, cpy_r_r556, cpy_r_r557);
    CPy_DECREF(cpy_r_r556);
    if (unlikely(cpy_r_r559 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 707, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r560 = CPyDef_ops___LoadStatic_trait_vtable_setup();
    if (unlikely(cpy_r_r560 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL443;
    }
    cpy_r_r561 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r562 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r563 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r564 = CPyStatics[7843]; /* 'identifier' */
    cpy_r_r565 = CPyStatics[3995]; /* 'module_name' */
    cpy_r_r566 = CPyStatics[6188]; /* 'namespace' */
    cpy_r_r567 = CPyStatics[7844]; /* 'ann' */
    cpy_r_r568 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r569 = CPyStatics[5126]; /* '_type' */
    cpy_r_r570 = CPyStatics[2272]; /* 'line' */
    cpy_r_r571 = CPyStatics[802]; /* 'type' */
    cpy_r_r572 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r573 = PyTuple_Pack(11, cpy_r_r562, cpy_r_r563, cpy_r_r564, cpy_r_r565, cpy_r_r566, cpy_r_r567, cpy_r_r568, cpy_r_r569, cpy_r_r570, cpy_r_r571, cpy_r_r572);
    if (unlikely(cpy_r_r573 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 707, CPyStatic_ops___globals);
        goto CPyL443;
    }
    cpy_r_r574 = PyObject_SetAttr(cpy_r_r559, cpy_r_r561, cpy_r_r573);
    CPy_DECREF(cpy_r_r573);
    cpy_r_r575 = cpy_r_r574 >= 0;
    if (unlikely(!cpy_r_r575)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 707, CPyStatic_ops___globals);
        goto CPyL443;
    }
    CPyType_ops___LoadStatic = (PyTypeObject *)cpy_r_r559;
    CPy_INCREF(CPyType_ops___LoadStatic);
    cpy_r_r576 = CPyStatic_ops___globals;
    cpy_r_r577 = CPyStatics[6712]; /* 'LoadStatic' */
    cpy_r_r578 = CPyDict_SetItem(cpy_r_r576, cpy_r_r577, cpy_r_r559);
    CPy_DECREF(cpy_r_r559);
    cpy_r_r579 = cpy_r_r578 >= 0;
    if (unlikely(!cpy_r_r579)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 707, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r580 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r581 = PyTuple_Pack(1, cpy_r_r580);
    if (unlikely(cpy_r_r581 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 744, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r582 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r583 = (PyObject *)CPyType_ops___InitStatic_template;
    cpy_r_r584 = CPyType_FromTemplate(cpy_r_r583, cpy_r_r581, cpy_r_r582);
    CPy_DECREF(cpy_r_r581);
    if (unlikely(cpy_r_r584 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 744, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r585 = CPyDef_ops___InitStatic_trait_vtable_setup();
    if (unlikely(cpy_r_r585 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL444;
    }
    cpy_r_r586 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r587 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r588 = CPyStatics[7843]; /* 'identifier' */
    cpy_r_r589 = CPyStatics[3995]; /* 'module_name' */
    cpy_r_r590 = CPyStatics[6188]; /* 'namespace' */
    cpy_r_r591 = CPyStatics[2242]; /* 'value' */
    cpy_r_r592 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r593 = CPyStatics[5126]; /* '_type' */
    cpy_r_r594 = CPyStatics[2272]; /* 'line' */
    cpy_r_r595 = CPyStatics[802]; /* 'type' */
    cpy_r_r596 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r597 = PyTuple_Pack(10, cpy_r_r587, cpy_r_r588, cpy_r_r589, cpy_r_r590, cpy_r_r591, cpy_r_r592, cpy_r_r593, cpy_r_r594, cpy_r_r595, cpy_r_r596);
    if (unlikely(cpy_r_r597 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 744, CPyStatic_ops___globals);
        goto CPyL444;
    }
    cpy_r_r598 = PyObject_SetAttr(cpy_r_r584, cpy_r_r586, cpy_r_r597);
    CPy_DECREF(cpy_r_r597);
    cpy_r_r599 = cpy_r_r598 >= 0;
    if (unlikely(!cpy_r_r599)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 744, CPyStatic_ops___globals);
        goto CPyL444;
    }
    CPyType_ops___InitStatic = (PyTypeObject *)cpy_r_r584;
    CPy_INCREF(CPyType_ops___InitStatic);
    cpy_r_r600 = CPyStatic_ops___globals;
    cpy_r_r601 = CPyStatics[6703]; /* 'InitStatic' */
    cpy_r_r602 = CPyDict_SetItem(cpy_r_r600, cpy_r_r601, cpy_r_r584);
    CPy_DECREF(cpy_r_r584);
    cpy_r_r603 = cpy_r_r602 >= 0;
    if (unlikely(!cpy_r_r603)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 744, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r604 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r605 = PyTuple_Pack(1, cpy_r_r604);
    if (unlikely(cpy_r_r605 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 773, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r606 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r607 = (PyObject *)CPyType_ops___TupleSet_template;
    cpy_r_r608 = CPyType_FromTemplate(cpy_r_r607, cpy_r_r605, cpy_r_r606);
    CPy_DECREF(cpy_r_r605);
    if (unlikely(cpy_r_r608 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 773, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r609 = CPyDef_ops___TupleSet_trait_vtable_setup();
    if (unlikely(cpy_r_r609 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL445;
    }
    cpy_r_r610 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r611 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r612 = CPyStatics[219]; /* 'items' */
    cpy_r_r613 = CPyStatics[4003]; /* 'tuple_type' */
    cpy_r_r614 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r615 = CPyStatics[5126]; /* '_type' */
    cpy_r_r616 = CPyStatics[2272]; /* 'line' */
    cpy_r_r617 = CPyStatics[802]; /* 'type' */
    cpy_r_r618 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r619 = PyTuple_Pack(8, cpy_r_r611, cpy_r_r612, cpy_r_r613, cpy_r_r614, cpy_r_r615, cpy_r_r616, cpy_r_r617, cpy_r_r618);
    if (unlikely(cpy_r_r619 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 773, CPyStatic_ops___globals);
        goto CPyL445;
    }
    cpy_r_r620 = PyObject_SetAttr(cpy_r_r608, cpy_r_r610, cpy_r_r619);
    CPy_DECREF(cpy_r_r619);
    cpy_r_r621 = cpy_r_r620 >= 0;
    if (unlikely(!cpy_r_r621)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 773, CPyStatic_ops___globals);
        goto CPyL445;
    }
    CPyType_ops___TupleSet = (PyTypeObject *)cpy_r_r608;
    CPy_INCREF(CPyType_ops___TupleSet);
    cpy_r_r622 = CPyStatic_ops___globals;
    cpy_r_r623 = CPyStatics[6719]; /* 'TupleSet' */
    cpy_r_r624 = CPyDict_SetItem(cpy_r_r622, cpy_r_r623, cpy_r_r608);
    CPy_DECREF(cpy_r_r608);
    cpy_r_r625 = cpy_r_r624 >= 0;
    if (unlikely(!cpy_r_r625)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 773, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r626 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r627 = PyTuple_Pack(1, cpy_r_r626);
    if (unlikely(cpy_r_r627 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 799, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r628 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r629 = (PyObject *)CPyType_ops___TupleGet_template;
    cpy_r_r630 = CPyType_FromTemplate(cpy_r_r629, cpy_r_r627, cpy_r_r628);
    CPy_DECREF(cpy_r_r627);
    if (unlikely(cpy_r_r630 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 799, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r631 = CPyDef_ops___TupleGet_trait_vtable_setup();
    if (unlikely(cpy_r_r631 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL446;
    }
    cpy_r_r632 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r633 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r634 = CPyStatics[6937]; /* 'src' */
    cpy_r_r635 = CPyStatics[56]; /* 'index' */
    cpy_r_r636 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r637 = CPyStatics[5126]; /* '_type' */
    cpy_r_r638 = CPyStatics[2272]; /* 'line' */
    cpy_r_r639 = CPyStatics[802]; /* 'type' */
    cpy_r_r640 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r641 = PyTuple_Pack(8, cpy_r_r633, cpy_r_r634, cpy_r_r635, cpy_r_r636, cpy_r_r637, cpy_r_r638, cpy_r_r639, cpy_r_r640);
    if (unlikely(cpy_r_r641 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 799, CPyStatic_ops___globals);
        goto CPyL446;
    }
    cpy_r_r642 = PyObject_SetAttr(cpy_r_r630, cpy_r_r632, cpy_r_r641);
    CPy_DECREF(cpy_r_r641);
    cpy_r_r643 = cpy_r_r642 >= 0;
    if (unlikely(!cpy_r_r643)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 799, CPyStatic_ops___globals);
        goto CPyL446;
    }
    CPyType_ops___TupleGet = (PyTypeObject *)cpy_r_r630;
    CPy_INCREF(CPyType_ops___TupleGet);
    cpy_r_r644 = CPyStatic_ops___globals;
    cpy_r_r645 = CPyStatics[6718]; /* 'TupleGet' */
    cpy_r_r646 = CPyDict_SetItem(cpy_r_r644, cpy_r_r645, cpy_r_r630);
    CPy_DECREF(cpy_r_r630);
    cpy_r_r647 = cpy_r_r646 >= 0;
    if (unlikely(!cpy_r_r647)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 799, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r648 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r649 = PyTuple_Pack(1, cpy_r_r648);
    if (unlikely(cpy_r_r649 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 819, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r650 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r651 = (PyObject *)CPyType_ops___Cast_template;
    cpy_r_r652 = CPyType_FromTemplate(cpy_r_r651, cpy_r_r649, cpy_r_r650);
    CPy_DECREF(cpy_r_r649);
    if (unlikely(cpy_r_r652 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 819, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r653 = CPyDef_ops___Cast_trait_vtable_setup();
    if (unlikely(cpy_r_r653 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL447;
    }
    cpy_r_r654 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r655 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r656 = CPyStatics[6937]; /* 'src' */
    cpy_r_r657 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r658 = CPyStatics[5126]; /* '_type' */
    cpy_r_r659 = CPyStatics[2272]; /* 'line' */
    cpy_r_r660 = CPyStatics[802]; /* 'type' */
    cpy_r_r661 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r662 = PyTuple_Pack(7, cpy_r_r655, cpy_r_r656, cpy_r_r657, cpy_r_r658, cpy_r_r659, cpy_r_r660, cpy_r_r661);
    if (unlikely(cpy_r_r662 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 819, CPyStatic_ops___globals);
        goto CPyL447;
    }
    cpy_r_r663 = PyObject_SetAttr(cpy_r_r652, cpy_r_r654, cpy_r_r662);
    CPy_DECREF(cpy_r_r662);
    cpy_r_r664 = cpy_r_r663 >= 0;
    if (unlikely(!cpy_r_r664)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 819, CPyStatic_ops___globals);
        goto CPyL447;
    }
    CPyType_ops___Cast = (PyTypeObject *)cpy_r_r652;
    CPy_INCREF(CPyType_ops___Cast);
    cpy_r_r665 = CPyStatic_ops___globals;
    cpy_r_r666 = CPyStatics[6695]; /* 'Cast' */
    cpy_r_r667 = CPyDict_SetItem(cpy_r_r665, cpy_r_r666, cpy_r_r652);
    CPy_DECREF(cpy_r_r652);
    cpy_r_r668 = cpy_r_r667 >= 0;
    if (unlikely(!cpy_r_r668)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 819, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r669 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r670 = PyTuple_Pack(1, cpy_r_r669);
    if (unlikely(cpy_r_r670 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 847, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r671 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r672 = (PyObject *)CPyType_ops___Box_template;
    cpy_r_r673 = CPyType_FromTemplate(cpy_r_r672, cpy_r_r670, cpy_r_r671);
    CPy_DECREF(cpy_r_r670);
    if (unlikely(cpy_r_r673 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 847, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r674 = CPyDef_ops___Box_trait_vtable_setup();
    if (unlikely(cpy_r_r674 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL448;
    }
    cpy_r_r675 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r676 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r677 = CPyStatics[6937]; /* 'src' */
    cpy_r_r678 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r679 = CPyStatics[5126]; /* '_type' */
    cpy_r_r680 = CPyStatics[2272]; /* 'line' */
    cpy_r_r681 = CPyStatics[802]; /* 'type' */
    cpy_r_r682 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r683 = PyTuple_Pack(7, cpy_r_r676, cpy_r_r677, cpy_r_r678, cpy_r_r679, cpy_r_r680, cpy_r_r681, cpy_r_r682);
    if (unlikely(cpy_r_r683 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 847, CPyStatic_ops___globals);
        goto CPyL448;
    }
    cpy_r_r684 = PyObject_SetAttr(cpy_r_r673, cpy_r_r675, cpy_r_r683);
    CPy_DECREF(cpy_r_r683);
    cpy_r_r685 = cpy_r_r684 >= 0;
    if (unlikely(!cpy_r_r685)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 847, CPyStatic_ops___globals);
        goto CPyL448;
    }
    CPyType_ops___Box = (PyTypeObject *)cpy_r_r673;
    CPy_INCREF(CPyType_ops___Box);
    cpy_r_r686 = CPyStatic_ops___globals;
    cpy_r_r687 = CPyStatics[6693]; /* 'Box' */
    cpy_r_r688 = CPyDict_SetItem(cpy_r_r686, cpy_r_r687, cpy_r_r673);
    CPy_DECREF(cpy_r_r673);
    cpy_r_r689 = cpy_r_r688 >= 0;
    if (unlikely(!cpy_r_r689)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 847, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r690 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r691 = PyTuple_Pack(1, cpy_r_r690);
    if (unlikely(cpy_r_r691 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 878, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r692 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r693 = (PyObject *)CPyType_ops___Unbox_template;
    cpy_r_r694 = CPyType_FromTemplate(cpy_r_r693, cpy_r_r691, cpy_r_r692);
    CPy_DECREF(cpy_r_r691);
    if (unlikely(cpy_r_r694 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 878, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r695 = CPyDef_ops___Unbox_trait_vtable_setup();
    if (unlikely(cpy_r_r695 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL449;
    }
    cpy_r_r696 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r697 = CPyStatics[6937]; /* 'src' */
    cpy_r_r698 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r699 = CPyStatics[5126]; /* '_type' */
    cpy_r_r700 = CPyStatics[2272]; /* 'line' */
    cpy_r_r701 = CPyStatics[802]; /* 'type' */
    cpy_r_r702 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r703 = PyTuple_Pack(6, cpy_r_r697, cpy_r_r698, cpy_r_r699, cpy_r_r700, cpy_r_r701, cpy_r_r702);
    if (unlikely(cpy_r_r703 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 878, CPyStatic_ops___globals);
        goto CPyL449;
    }
    cpy_r_r704 = PyObject_SetAttr(cpy_r_r694, cpy_r_r696, cpy_r_r703);
    CPy_DECREF(cpy_r_r703);
    cpy_r_r705 = cpy_r_r704 >= 0;
    if (unlikely(!cpy_r_r705)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 878, CPyStatic_ops___globals);
        goto CPyL449;
    }
    CPyType_ops___Unbox = (PyTypeObject *)cpy_r_r694;
    CPy_INCREF(CPyType_ops___Unbox);
    cpy_r_r706 = CPyStatic_ops___globals;
    cpy_r_r707 = CPyStatics[6720]; /* 'Unbox' */
    cpy_r_r708 = CPyDict_SetItem(cpy_r_r706, cpy_r_r707, cpy_r_r694);
    CPy_DECREF(cpy_r_r694);
    cpy_r_r709 = cpy_r_r708 >= 0;
    if (unlikely(!cpy_r_r709)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 878, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r710 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r711 = PyTuple_Pack(1, cpy_r_r710);
    if (unlikely(cpy_r_r711 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 901, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r712 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r713 = (PyObject *)CPyType_ops___RaiseStandardError_template;
    cpy_r_r714 = CPyType_FromTemplate(cpy_r_r713, cpy_r_r711, cpy_r_r712);
    CPy_DECREF(cpy_r_r711);
    if (unlikely(cpy_r_r714 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 901, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r715 = CPyDef_ops___RaiseStandardError_trait_vtable_setup();
    if (unlikely(cpy_r_r715 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL450;
    }
    cpy_r_r716 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r717 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r718 = CPyStatics[7845]; /* 'VALUE_ERROR' */
    cpy_r_r719 = CPyStatics[7846]; /* 'ASSERTION_ERROR' */
    cpy_r_r720 = CPyStatics[7847]; /* 'STOP_ITERATION' */
    cpy_r_r721 = CPyStatics[7848]; /* 'UNBOUND_LOCAL_ERROR' */
    cpy_r_r722 = CPyStatics[7849]; /* 'RUNTIME_ERROR' */
    cpy_r_r723 = CPyStatics[7850]; /* 'NAME_ERROR' */
    cpy_r_r724 = CPyStatics[7851]; /* 'ZERO_DIVISION_ERROR' */
    cpy_r_r725 = CPyStatics[3473]; /* 'class_name' */
    cpy_r_r726 = CPyStatics[2242]; /* 'value' */
    cpy_r_r727 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r728 = CPyStatics[5126]; /* '_type' */
    cpy_r_r729 = CPyStatics[2272]; /* 'line' */
    cpy_r_r730 = CPyStatics[802]; /* 'type' */
    cpy_r_r731 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r732 = PyTuple_Pack(15, cpy_r_r717, cpy_r_r718, cpy_r_r719, cpy_r_r720, cpy_r_r721, cpy_r_r722, cpy_r_r723, cpy_r_r724, cpy_r_r725, cpy_r_r726, cpy_r_r727, cpy_r_r728, cpy_r_r729, cpy_r_r730, cpy_r_r731);
    if (unlikely(cpy_r_r732 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 901, CPyStatic_ops___globals);
        goto CPyL450;
    }
    cpy_r_r733 = PyObject_SetAttr(cpy_r_r714, cpy_r_r716, cpy_r_r732);
    CPy_DECREF(cpy_r_r732);
    cpy_r_r734 = cpy_r_r733 >= 0;
    if (unlikely(!cpy_r_r734)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 901, CPyStatic_ops___globals);
        goto CPyL450;
    }
    CPyType_ops___RaiseStandardError = (PyTypeObject *)cpy_r_r714;
    CPy_INCREF(CPyType_ops___RaiseStandardError);
    cpy_r_r735 = CPyStatic_ops___globals;
    cpy_r_r736 = CPyStatics[6716]; /* 'RaiseStandardError' */
    cpy_r_r737 = CPyDict_SetItem(cpy_r_r735, cpy_r_r736, cpy_r_r714);
    CPy_DECREF(cpy_r_r714);
    cpy_r_r738 = cpy_r_r737 >= 0;
    if (unlikely(!cpy_r_r738)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 901, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r739 = (PyObject *)CPyType_ops___RaiseStandardError;
    cpy_r_r740 = CPyStatics[1544]; /* 'ValueError' */
    cpy_r_r741 = CPyStatics[7845]; /* 'VALUE_ERROR' */
    cpy_r_r742 = PyObject_SetAttr(cpy_r_r739, cpy_r_r741, cpy_r_r740);
    cpy_r_r743 = cpy_r_r742 >= 0;
    if (unlikely(!cpy_r_r743)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 912, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r744 = (PyObject *)CPyType_ops___RaiseStandardError;
    cpy_r_r745 = CPyStatics[23]; /* 'AssertionError' */
    cpy_r_r746 = CPyStatics[7846]; /* 'ASSERTION_ERROR' */
    cpy_r_r747 = PyObject_SetAttr(cpy_r_r744, cpy_r_r746, cpy_r_r745);
    cpy_r_r748 = cpy_r_r747 >= 0;
    if (unlikely(!cpy_r_r748)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 913, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r749 = (PyObject *)CPyType_ops___RaiseStandardError;
    cpy_r_r750 = CPyStatics[75]; /* 'StopIteration' */
    cpy_r_r751 = CPyStatics[7847]; /* 'STOP_ITERATION' */
    cpy_r_r752 = PyObject_SetAttr(cpy_r_r749, cpy_r_r751, cpy_r_r750);
    cpy_r_r753 = cpy_r_r752 >= 0;
    if (unlikely(!cpy_r_r753)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 914, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r754 = (PyObject *)CPyType_ops___RaiseStandardError;
    cpy_r_r755 = CPyStatics[7811]; /* 'UnboundLocalError' */
    cpy_r_r756 = CPyStatics[7848]; /* 'UNBOUND_LOCAL_ERROR' */
    cpy_r_r757 = PyObject_SetAttr(cpy_r_r754, cpy_r_r756, cpy_r_r755);
    cpy_r_r758 = cpy_r_r757 >= 0;
    if (unlikely(!cpy_r_r758)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 915, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r759 = (PyObject *)CPyType_ops___RaiseStandardError;
    cpy_r_r760 = CPyStatics[718]; /* 'RuntimeError' */
    cpy_r_r761 = CPyStatics[7849]; /* 'RUNTIME_ERROR' */
    cpy_r_r762 = PyObject_SetAttr(cpy_r_r759, cpy_r_r761, cpy_r_r760);
    cpy_r_r763 = cpy_r_r762 >= 0;
    if (unlikely(!cpy_r_r763)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 916, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r764 = (PyObject *)CPyType_ops___RaiseStandardError;
    cpy_r_r765 = CPyStatics[7812]; /* 'NameError' */
    cpy_r_r766 = CPyStatics[7850]; /* 'NAME_ERROR' */
    cpy_r_r767 = PyObject_SetAttr(cpy_r_r764, cpy_r_r766, cpy_r_r765);
    cpy_r_r768 = cpy_r_r767 >= 0;
    if (unlikely(!cpy_r_r768)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 917, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r769 = (PyObject *)CPyType_ops___RaiseStandardError;
    cpy_r_r770 = CPyStatics[7813]; /* 'ZeroDivisionError' */
    cpy_r_r771 = CPyStatics[7851]; /* 'ZERO_DIVISION_ERROR' */
    cpy_r_r772 = PyObject_SetAttr(cpy_r_r769, cpy_r_r771, cpy_r_r770);
    cpy_r_r773 = cpy_r_r772 >= 0;
    if (unlikely(!cpy_r_r773)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 918, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r774 = CPyStatic_ops___globals;
    cpy_r_r775 = CPyStatics[84]; /* 'Union' */
    cpy_r_r776 = CPyDict_GetItem(cpy_r_r774, cpy_r_r775);
    if (unlikely(cpy_r_r776 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 934, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r777 = (PyObject *)&PyBool_Type;
    cpy_r_r778 = CPyStatic_ops___globals;
    cpy_r_r779 = CPyStatics[81]; /* 'List' */
    cpy_r_r780 = CPyDict_GetItem(cpy_r_r778, cpy_r_r779);
    if (unlikely(cpy_r_r780 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 934, CPyStatic_ops___globals);
        goto CPyL451;
    }
    cpy_r_r781 = (PyObject *)&PyBool_Type;
    cpy_r_r782 = PyObject_GetItem(cpy_r_r780, cpy_r_r781);
    CPy_DECREF(cpy_r_r780);
    if (unlikely(cpy_r_r782 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 934, CPyStatic_ops___globals);
        goto CPyL451;
    }
    cpy_r_r783.f0 = cpy_r_r777;
    cpy_r_r783.f1 = cpy_r_r782;
    CPy_INCREF(cpy_r_r783.f0);
    CPy_INCREF(cpy_r_r783.f1);
    CPy_DECREF(cpy_r_r782);
    cpy_r_r784 = PyTuple_New(2);
    if (unlikely(cpy_r_r784 == NULL))
        CPyError_OutOfMemory();
    PyObject *__tmp9874 = cpy_r_r783.f0;
    PyTuple_SET_ITEM(cpy_r_r784, 0, __tmp9874);
    PyObject *__tmp9875 = cpy_r_r783.f1;
    PyTuple_SET_ITEM(cpy_r_r784, 1, __tmp9875);
    cpy_r_r785 = PyObject_GetItem(cpy_r_r776, cpy_r_r784);
    CPy_DECREF(cpy_r_r776);
    CPy_DECREF(cpy_r_r784);
    if (unlikely(cpy_r_r785 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 934, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r786 = CPyStatic_ops___globals;
    cpy_r_r787 = CPyStatics[7852]; /* 'StealsDescription' */
    cpy_r_r788 = CPyDict_SetItem(cpy_r_r786, cpy_r_r787, cpy_r_r785);
    CPy_DECREF(cpy_r_r785);
    cpy_r_r789 = cpy_r_r788 >= 0;
    if (unlikely(!cpy_r_r789)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 934, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r790 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r791 = PyTuple_Pack(1, cpy_r_r790);
    if (unlikely(cpy_r_r791 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 937, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r792 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r793 = (PyObject *)CPyType_ops___CallC_template;
    cpy_r_r794 = CPyType_FromTemplate(cpy_r_r793, cpy_r_r791, cpy_r_r792);
    CPy_DECREF(cpy_r_r791);
    if (unlikely(cpy_r_r794 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 937, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r795 = CPyDef_ops___CallC_trait_vtable_setup();
    if (unlikely(cpy_r_r795 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL452;
    }
    cpy_r_r796 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r797 = CPyStatics[7853]; /* 'function_name' */
    cpy_r_r798 = CPyStatics[1678]; /* 'args' */
    cpy_r_r799 = CPyStatics[7854]; /* 'steals' */
    cpy_r_r800 = CPyStatics[7855]; /* 'var_arg_idx' */
    cpy_r_r801 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r802 = CPyStatics[5126]; /* '_type' */
    cpy_r_r803 = CPyStatics[2272]; /* 'line' */
    cpy_r_r804 = CPyStatics[802]; /* 'type' */
    cpy_r_r805 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r806 = PyTuple_Pack(9, cpy_r_r797, cpy_r_r798, cpy_r_r799, cpy_r_r800, cpy_r_r801, cpy_r_r802, cpy_r_r803, cpy_r_r804, cpy_r_r805);
    if (unlikely(cpy_r_r806 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 937, CPyStatic_ops___globals);
        goto CPyL452;
    }
    cpy_r_r807 = PyObject_SetAttr(cpy_r_r794, cpy_r_r796, cpy_r_r806);
    CPy_DECREF(cpy_r_r806);
    cpy_r_r808 = cpy_r_r807 >= 0;
    if (unlikely(!cpy_r_r808)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 937, CPyStatic_ops___globals);
        goto CPyL452;
    }
    CPyType_ops___CallC = (PyTypeObject *)cpy_r_r794;
    CPy_INCREF(CPyType_ops___CallC);
    cpy_r_r809 = CPyStatic_ops___globals;
    cpy_r_r810 = CPyStatics[6694]; /* 'CallC' */
    cpy_r_r811 = CPyDict_SetItem(cpy_r_r809, cpy_r_r810, cpy_r_r794);
    CPy_DECREF(cpy_r_r794);
    cpy_r_r812 = cpy_r_r811 >= 0;
    if (unlikely(!cpy_r_r812)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 937, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r813 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r814 = PyTuple_Pack(1, cpy_r_r813);
    if (unlikely(cpy_r_r814 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 980, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r815 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r816 = (PyObject *)CPyType_ops___Truncate_template;
    cpy_r_r817 = CPyType_FromTemplate(cpy_r_r816, cpy_r_r814, cpy_r_r815);
    CPy_DECREF(cpy_r_r814);
    if (unlikely(cpy_r_r817 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 980, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r818 = CPyDef_ops___Truncate_trait_vtable_setup();
    if (unlikely(cpy_r_r818 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL453;
    }
    cpy_r_r819 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r820 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r821 = CPyStatics[6937]; /* 'src' */
    cpy_r_r822 = CPyStatics[7856]; /* 'src_type' */
    cpy_r_r823 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r824 = CPyStatics[5126]; /* '_type' */
    cpy_r_r825 = CPyStatics[2272]; /* 'line' */
    cpy_r_r826 = CPyStatics[802]; /* 'type' */
    cpy_r_r827 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r828 = PyTuple_Pack(8, cpy_r_r820, cpy_r_r821, cpy_r_r822, cpy_r_r823, cpy_r_r824, cpy_r_r825, cpy_r_r826, cpy_r_r827);
    if (unlikely(cpy_r_r828 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 980, CPyStatic_ops___globals);
        goto CPyL453;
    }
    cpy_r_r829 = PyObject_SetAttr(cpy_r_r817, cpy_r_r819, cpy_r_r828);
    CPy_DECREF(cpy_r_r828);
    cpy_r_r830 = cpy_r_r829 >= 0;
    if (unlikely(!cpy_r_r830)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 980, CPyStatic_ops___globals);
        goto CPyL453;
    }
    CPyType_ops___Truncate = (PyTypeObject *)cpy_r_r817;
    CPy_INCREF(CPyType_ops___Truncate);
    cpy_r_r831 = CPyStatic_ops___globals;
    cpy_r_r832 = CPyStatics[6717]; /* 'Truncate' */
    cpy_r_r833 = CPyDict_SetItem(cpy_r_r831, cpy_r_r832, cpy_r_r817);
    CPy_DECREF(cpy_r_r817);
    cpy_r_r834 = cpy_r_r833 >= 0;
    if (unlikely(!cpy_r_r834)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 980, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r835 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r836 = PyTuple_Pack(1, cpy_r_r835);
    if (unlikely(cpy_r_r836 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1007, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r837 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r838 = (PyObject *)CPyType_ops___Extend_template;
    cpy_r_r839 = CPyType_FromTemplate(cpy_r_r838, cpy_r_r836, cpy_r_r837);
    CPy_DECREF(cpy_r_r836);
    if (unlikely(cpy_r_r839 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1007, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r840 = CPyDef_ops___Extend_trait_vtable_setup();
    if (unlikely(cpy_r_r840 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL454;
    }
    cpy_r_r841 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r842 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r843 = CPyStatics[6937]; /* 'src' */
    cpy_r_r844 = CPyStatics[7856]; /* 'src_type' */
    cpy_r_r845 = CPyStatics[7857]; /* 'signed' */
    cpy_r_r846 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r847 = CPyStatics[5126]; /* '_type' */
    cpy_r_r848 = CPyStatics[2272]; /* 'line' */
    cpy_r_r849 = CPyStatics[802]; /* 'type' */
    cpy_r_r850 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r851 = PyTuple_Pack(9, cpy_r_r842, cpy_r_r843, cpy_r_r844, cpy_r_r845, cpy_r_r846, cpy_r_r847, cpy_r_r848, cpy_r_r849, cpy_r_r850);
    if (unlikely(cpy_r_r851 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1007, CPyStatic_ops___globals);
        goto CPyL454;
    }
    cpy_r_r852 = PyObject_SetAttr(cpy_r_r839, cpy_r_r841, cpy_r_r851);
    CPy_DECREF(cpy_r_r851);
    cpy_r_r853 = cpy_r_r852 >= 0;
    if (unlikely(!cpy_r_r853)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1007, CPyStatic_ops___globals);
        goto CPyL454;
    }
    CPyType_ops___Extend = (PyTypeObject *)cpy_r_r839;
    CPy_INCREF(CPyType_ops___Extend);
    cpy_r_r854 = CPyStatic_ops___globals;
    cpy_r_r855 = CPyStatics[6697]; /* 'Extend' */
    cpy_r_r856 = CPyDict_SetItem(cpy_r_r854, cpy_r_r855, cpy_r_r839);
    CPy_DECREF(cpy_r_r839);
    cpy_r_r857 = cpy_r_r856 >= 0;
    if (unlikely(!cpy_r_r857)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1007, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r858 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r859 = PyTuple_Pack(1, cpy_r_r858);
    if (unlikely(cpy_r_r859 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1038, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r860 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r861 = (PyObject *)CPyType_ops___LoadGlobal_template;
    cpy_r_r862 = CPyType_FromTemplate(cpy_r_r861, cpy_r_r859, cpy_r_r860);
    CPy_DECREF(cpy_r_r859);
    if (unlikely(cpy_r_r862 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1038, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r863 = CPyDef_ops___LoadGlobal_trait_vtable_setup();
    if (unlikely(cpy_r_r863 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL455;
    }
    cpy_r_r864 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r865 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r866 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r867 = CPyStatics[7843]; /* 'identifier' */
    cpy_r_r868 = CPyStatics[7844]; /* 'ann' */
    cpy_r_r869 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r870 = CPyStatics[5126]; /* '_type' */
    cpy_r_r871 = CPyStatics[2272]; /* 'line' */
    cpy_r_r872 = CPyStatics[802]; /* 'type' */
    cpy_r_r873 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r874 = PyTuple_Pack(9, cpy_r_r865, cpy_r_r866, cpy_r_r867, cpy_r_r868, cpy_r_r869, cpy_r_r870, cpy_r_r871, cpy_r_r872, cpy_r_r873);
    if (unlikely(cpy_r_r874 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1038, CPyStatic_ops___globals);
        goto CPyL455;
    }
    cpy_r_r875 = PyObject_SetAttr(cpy_r_r862, cpy_r_r864, cpy_r_r874);
    CPy_DECREF(cpy_r_r874);
    cpy_r_r876 = cpy_r_r875 >= 0;
    if (unlikely(!cpy_r_r876)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1038, CPyStatic_ops___globals);
        goto CPyL455;
    }
    CPyType_ops___LoadGlobal = (PyTypeObject *)cpy_r_r862;
    CPy_INCREF(CPyType_ops___LoadGlobal);
    cpy_r_r877 = CPyStatic_ops___globals;
    cpy_r_r878 = CPyStatics[6709]; /* 'LoadGlobal' */
    cpy_r_r879 = CPyDict_SetItem(cpy_r_r877, cpy_r_r878, cpy_r_r862);
    CPy_DECREF(cpy_r_r862);
    cpy_r_r880 = cpy_r_r879 >= 0;
    if (unlikely(!cpy_r_r880)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1038, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r881 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r882 = PyTuple_Pack(1, cpy_r_r881);
    if (unlikely(cpy_r_r882 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1062, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r883 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r884 = (PyObject *)CPyType_ops___IntOp_template;
    cpy_r_r885 = CPyType_FromTemplate(cpy_r_r884, cpy_r_r882, cpy_r_r883);
    CPy_DECREF(cpy_r_r882);
    if (unlikely(cpy_r_r885 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1062, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r886 = CPyDef_ops___IntOp_trait_vtable_setup();
    if (unlikely(cpy_r_r886 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL456;
    }
    cpy_r_r887 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r888 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r889 = CPyStatics[7858]; /* 'ADD' */
    cpy_r_r890 = CPyStatics[7859]; /* 'SUB' */
    cpy_r_r891 = CPyStatics[7860]; /* 'MUL' */
    cpy_r_r892 = CPyStatics[7861]; /* 'DIV' */
    cpy_r_r893 = CPyStatics[7862]; /* 'MOD' */
    cpy_r_r894 = CPyStatics[7863]; /* 'AND' */
    cpy_r_r895 = CPyStatics[7864]; /* 'OR' */
    cpy_r_r896 = CPyStatics[7865]; /* 'XOR' */
    cpy_r_r897 = CPyStatics[7866]; /* 'LEFT_SHIFT' */
    cpy_r_r898 = CPyStatics[7867]; /* 'RIGHT_SHIFT' */
    cpy_r_r899 = CPyStatics[7868]; /* 'op_str' */
    cpy_r_r900 = CPyStatics[7629]; /* 'lhs' */
    cpy_r_r901 = CPyStatics[7630]; /* 'rhs' */
    cpy_r_r902 = CPyStatics[1628]; /* 'op' */
    cpy_r_r903 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r904 = CPyStatics[5126]; /* '_type' */
    cpy_r_r905 = CPyStatics[2272]; /* 'line' */
    cpy_r_r906 = CPyStatics[802]; /* 'type' */
    cpy_r_r907 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r908 = PyTuple_Pack(20, cpy_r_r888, cpy_r_r889, cpy_r_r890, cpy_r_r891, cpy_r_r892, cpy_r_r893, cpy_r_r894, cpy_r_r895, cpy_r_r896, cpy_r_r897, cpy_r_r898, cpy_r_r899, cpy_r_r900, cpy_r_r901, cpy_r_r902, cpy_r_r903, cpy_r_r904, cpy_r_r905, cpy_r_r906, cpy_r_r907);
    if (unlikely(cpy_r_r908 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1062, CPyStatic_ops___globals);
        goto CPyL456;
    }
    cpy_r_r909 = PyObject_SetAttr(cpy_r_r885, cpy_r_r887, cpy_r_r908);
    CPy_DECREF(cpy_r_r908);
    cpy_r_r910 = cpy_r_r909 >= 0;
    if (unlikely(!cpy_r_r910)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1062, CPyStatic_ops___globals);
        goto CPyL456;
    }
    CPyType_ops___IntOp = (PyTypeObject *)cpy_r_r885;
    CPy_INCREF(CPyType_ops___IntOp);
    cpy_r_r911 = CPyStatic_ops___globals;
    cpy_r_r912 = CPyStatics[6705]; /* 'IntOp' */
    cpy_r_r913 = CPyDict_SetItem(cpy_r_r911, cpy_r_r912, cpy_r_r885);
    CPy_DECREF(cpy_r_r885);
    cpy_r_r914 = cpy_r_r913 >= 0;
    if (unlikely(!cpy_r_r914)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1062, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r915 = (PyObject *)CPyType_ops___IntOp;
    cpy_r_r916 = CPyStatics[7858]; /* 'ADD' */
    cpy_r_r917 = CPyStatics[9015]; /* 0 */
    cpy_r_r918 = PyObject_SetAttr(cpy_r_r915, cpy_r_r916, cpy_r_r917);
    cpy_r_r919 = cpy_r_r918 >= 0;
    if (unlikely(!cpy_r_r919)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1078, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r920 = (PyObject *)CPyType_ops___IntOp;
    cpy_r_r921 = CPyStatics[7859]; /* 'SUB' */
    cpy_r_r922 = CPyStatics[9016]; /* 1 */
    cpy_r_r923 = PyObject_SetAttr(cpy_r_r920, cpy_r_r921, cpy_r_r922);
    cpy_r_r924 = cpy_r_r923 >= 0;
    if (unlikely(!cpy_r_r924)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1079, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r925 = (PyObject *)CPyType_ops___IntOp;
    cpy_r_r926 = CPyStatics[7860]; /* 'MUL' */
    cpy_r_r927 = CPyStatics[9018]; /* 2 */
    cpy_r_r928 = PyObject_SetAttr(cpy_r_r925, cpy_r_r926, cpy_r_r927);
    cpy_r_r929 = cpy_r_r928 >= 0;
    if (unlikely(!cpy_r_r929)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1080, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r930 = (PyObject *)CPyType_ops___IntOp;
    cpy_r_r931 = CPyStatics[7861]; /* 'DIV' */
    cpy_r_r932 = CPyStatics[9026]; /* 3 */
    cpy_r_r933 = PyObject_SetAttr(cpy_r_r930, cpy_r_r931, cpy_r_r932);
    cpy_r_r934 = cpy_r_r933 >= 0;
    if (unlikely(!cpy_r_r934)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1081, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r935 = (PyObject *)CPyType_ops___IntOp;
    cpy_r_r936 = CPyStatics[7862]; /* 'MOD' */
    cpy_r_r937 = CPyStatics[9025]; /* 4 */
    cpy_r_r938 = PyObject_SetAttr(cpy_r_r935, cpy_r_r936, cpy_r_r937);
    cpy_r_r939 = cpy_r_r938 >= 0;
    if (unlikely(!cpy_r_r939)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1082, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r940 = (PyObject *)CPyType_ops___IntOp;
    cpy_r_r941 = CPyStatics[7863]; /* 'AND' */
    cpy_r_r942 = CPyStatics[9048]; /* 200 */
    cpy_r_r943 = PyObject_SetAttr(cpy_r_r940, cpy_r_r941, cpy_r_r942);
    cpy_r_r944 = cpy_r_r943 >= 0;
    if (unlikely(!cpy_r_r944)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1085, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r945 = (PyObject *)CPyType_ops___IntOp;
    cpy_r_r946 = CPyStatics[7864]; /* 'OR' */
    cpy_r_r947 = CPyStatics[9049]; /* 201 */
    cpy_r_r948 = PyObject_SetAttr(cpy_r_r945, cpy_r_r946, cpy_r_r947);
    cpy_r_r949 = cpy_r_r948 >= 0;
    if (unlikely(!cpy_r_r949)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1086, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r950 = (PyObject *)CPyType_ops___IntOp;
    cpy_r_r951 = CPyStatics[7865]; /* 'XOR' */
    cpy_r_r952 = CPyStatics[9050]; /* 202 */
    cpy_r_r953 = PyObject_SetAttr(cpy_r_r950, cpy_r_r951, cpy_r_r952);
    cpy_r_r954 = cpy_r_r953 >= 0;
    if (unlikely(!cpy_r_r954)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1087, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r955 = (PyObject *)CPyType_ops___IntOp;
    cpy_r_r956 = CPyStatics[7866]; /* 'LEFT_SHIFT' */
    cpy_r_r957 = CPyStatics[9051]; /* 203 */
    cpy_r_r958 = PyObject_SetAttr(cpy_r_r955, cpy_r_r956, cpy_r_r957);
    cpy_r_r959 = cpy_r_r958 >= 0;
    if (unlikely(!cpy_r_r959)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1088, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r960 = (PyObject *)CPyType_ops___IntOp;
    cpy_r_r961 = CPyStatics[7867]; /* 'RIGHT_SHIFT' */
    cpy_r_r962 = CPyStatics[9052]; /* 204 */
    cpy_r_r963 = PyObject_SetAttr(cpy_r_r960, cpy_r_r961, cpy_r_r962);
    cpy_r_r964 = cpy_r_r963 >= 0;
    if (unlikely(!cpy_r_r964)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1089, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r965 = (PyObject *)CPyType_ops___IntOp;
    cpy_r_r966 = CPyStatics[886]; /* '+' */
    cpy_r_r967 = CPyStatics[1198]; /* '-' */
    cpy_r_r968 = CPyStatics[282]; /* '*' */
    cpy_r_r969 = CPyStatics[1594]; /* '/' */
    cpy_r_r970 = CPyStatics[1183]; /* '%' */
    cpy_r_r971 = CPyStatics[1596]; /* '&' */
    cpy_r_r972 = CPyStatics[885]; /* '|' */
    cpy_r_r973 = CPyStatics[1597]; /* '^' */
    cpy_r_r974 = CPyStatics[1598]; /* '<<' */
    cpy_r_r975 = CPyStatics[1599]; /* '>>' */
    cpy_r_r976 = CPyStatics[9015]; /* 0 */
    cpy_r_r977 = CPyStatics[9016]; /* 1 */
    cpy_r_r978 = CPyStatics[9018]; /* 2 */
    cpy_r_r979 = CPyStatics[9026]; /* 3 */
    cpy_r_r980 = CPyStatics[9025]; /* 4 */
    cpy_r_r981 = CPyStatics[9048]; /* 200 */
    cpy_r_r982 = CPyStatics[9049]; /* 201 */
    cpy_r_r983 = CPyStatics[9050]; /* 202 */
    cpy_r_r984 = CPyStatics[9051]; /* 203 */
    cpy_r_r985 = CPyStatics[9052]; /* 204 */
    cpy_r_r986 = CPyDict_Build(10, cpy_r_r976, cpy_r_r966, cpy_r_r977, cpy_r_r967, cpy_r_r978, cpy_r_r968, cpy_r_r979, cpy_r_r969, cpy_r_r980, cpy_r_r970, cpy_r_r981, cpy_r_r971, cpy_r_r982, cpy_r_r972, cpy_r_r983, cpy_r_r973, cpy_r_r984, cpy_r_r974, cpy_r_r985, cpy_r_r975);
    if (unlikely(cpy_r_r986 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1091, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r987 = CPyStatics[7868]; /* 'op_str' */
    cpy_r_r988 = PyObject_SetAttr(cpy_r_r965, cpy_r_r987, cpy_r_r986);
    cpy_r_r989 = cpy_r_r988 >= 0;
    if (unlikely(!cpy_r_r989)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1091, CPyStatic_ops___globals);
        goto CPyL457;
    }
    CPyStatic_ops___IntOp___op_str = cpy_r_r986;
    CPy_INCREF(CPyStatic_ops___IntOp___op_str);
    CPy_DECREF(cpy_r_r986);
    cpy_r_r990 = PyDict_New();
    if (unlikely(cpy_r_r990 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1120, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r991 = CPyStatic_ops___IntOp___op_str;
    if (unlikely(cpy_r_r991 == NULL)) {
        goto CPyL458;
    } else
        goto CPyL267;
CPyL265: ;
    PyErr_SetString(PyExc_NameError, "value for final name \"op_str\" was not set");
    cpy_r_r992 = 0;
    if (unlikely(!cpy_r_r992)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1120, CPyStatic_ops___globals);
        goto CPyL419;
    }
    CPy_Unreachable();
CPyL267: ;
    cpy_r_r993 = 0;
    cpy_r_r994 = PyDict_Size(cpy_r_r991);
    cpy_r_r995 = cpy_r_r994 << 1;
    cpy_r_r996 = CPyDict_GetItemsIter(cpy_r_r991);
    if (unlikely(cpy_r_r996 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1120, CPyStatic_ops___globals);
        goto CPyL459;
    }
CPyL268: ;
    cpy_r_r997 = CPyDict_NextItem(cpy_r_r996, cpy_r_r993);
    cpy_r_r998 = cpy_r_r997.f1;
    cpy_r_r993 = cpy_r_r998;
    cpy_r_r999 = cpy_r_r997.f0;
    if (!cpy_r_r999) goto CPyL460;
    cpy_r_r1000 = cpy_r_r997.f2;
    CPy_INCREF(cpy_r_r1000);
    cpy_r_r1001 = cpy_r_r997.f3;
    CPy_INCREF(cpy_r_r1001);
    CPy_DECREF(cpy_r_r997.f2);
    CPy_DECREF(cpy_r_r997.f3);
    if (likely(PyLong_Check(cpy_r_r1000)))
        cpy_r_r1002 = CPyTagged_FromObject(cpy_r_r1000);
    else {
        CPy_TypeError("int", cpy_r_r1000); cpy_r_r1002 = CPY_INT_TAG;
    }
    CPy_DECREF(cpy_r_r1000);
    if (unlikely(cpy_r_r1002 == CPY_INT_TAG)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1120, CPyStatic_ops___globals);
        goto CPyL461;
    }
    if (likely(PyUnicode_Check(cpy_r_r1001)))
        cpy_r_r1003 = cpy_r_r1001;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "<module>", 1120, CPyStatic_ops___globals, "str", cpy_r_r1001);
        goto CPyL462;
    }
    cpy_r_op_id = cpy_r_r1002;
    cpy_r_op = cpy_r_r1003;
    cpy_r_r1004 = CPyTagged_StealAsObject(cpy_r_op_id);
    cpy_r_r1005 = CPyDict_SetItem(cpy_r_r990, cpy_r_op, cpy_r_r1004);
    CPy_DECREF(cpy_r_op);
    CPy_DECREF(cpy_r_r1004);
    cpy_r_r1006 = cpy_r_r1005 >= 0;
    if (unlikely(!cpy_r_r1006)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1120, CPyStatic_ops___globals);
        goto CPyL463;
    }
    cpy_r_r1007 = CPyDict_CheckSize(cpy_r_r991, cpy_r_r995);
    if (unlikely(!cpy_r_r1007)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1120, CPyStatic_ops___globals);
        goto CPyL463;
    } else
        goto CPyL268;
CPyL273: ;
    cpy_r_r1008 = CPy_NoErrOccured();
    if (unlikely(!cpy_r_r1008)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1120, CPyStatic_ops___globals);
        goto CPyL459;
    }
    CPyStatic_ops___int_op_to_id = cpy_r_r990;
    CPy_INCREF(CPyStatic_ops___int_op_to_id);
    cpy_r_r1009 = CPyStatic_ops___globals;
    cpy_r_r1010 = CPyStatics[7869]; /* 'int_op_to_id' */
    cpy_r_r1011 = CPyDict_SetItem(cpy_r_r1009, cpy_r_r1010, cpy_r_r990);
    CPy_DECREF(cpy_r_r990);
    cpy_r_r1012 = cpy_r_r1011 >= 0;
    if (unlikely(!cpy_r_r1012)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1120, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1013 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r1014 = PyTuple_Pack(1, cpy_r_r1013);
    if (unlikely(cpy_r_r1014 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1123, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1015 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r1016 = (PyObject *)CPyType_ops___ComparisonOp_template;
    cpy_r_r1017 = CPyType_FromTemplate(cpy_r_r1016, cpy_r_r1014, cpy_r_r1015);
    CPy_DECREF(cpy_r_r1014);
    if (unlikely(cpy_r_r1017 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1123, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1018 = CPyDef_ops___ComparisonOp_trait_vtable_setup();
    if (unlikely(cpy_r_r1018 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL464;
    }
    cpy_r_r1019 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r1020 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1021 = CPyStatics[7870]; /* 'EQ' */
    cpy_r_r1022 = CPyStatics[7871]; /* 'NEQ' */
    cpy_r_r1023 = CPyStatics[7872]; /* 'SLT' */
    cpy_r_r1024 = CPyStatics[7873]; /* 'SGT' */
    cpy_r_r1025 = CPyStatics[7874]; /* 'SLE' */
    cpy_r_r1026 = CPyStatics[7875]; /* 'SGE' */
    cpy_r_r1027 = CPyStatics[7876]; /* 'ULT' */
    cpy_r_r1028 = CPyStatics[7877]; /* 'UGT' */
    cpy_r_r1029 = CPyStatics[7878]; /* 'ULE' */
    cpy_r_r1030 = CPyStatics[7879]; /* 'UGE' */
    cpy_r_r1031 = CPyStatics[7868]; /* 'op_str' */
    cpy_r_r1032 = CPyStatics[7880]; /* 'signed_ops' */
    cpy_r_r1033 = CPyStatics[7881]; /* 'unsigned_ops' */
    cpy_r_r1034 = CPyStatics[7629]; /* 'lhs' */
    cpy_r_r1035 = CPyStatics[7630]; /* 'rhs' */
    cpy_r_r1036 = CPyStatics[1628]; /* 'op' */
    cpy_r_r1037 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1038 = CPyStatics[5126]; /* '_type' */
    cpy_r_r1039 = CPyStatics[2272]; /* 'line' */
    cpy_r_r1040 = CPyStatics[802]; /* 'type' */
    cpy_r_r1041 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r1042 = PyTuple_Pack(22, cpy_r_r1020, cpy_r_r1021, cpy_r_r1022, cpy_r_r1023, cpy_r_r1024, cpy_r_r1025, cpy_r_r1026, cpy_r_r1027, cpy_r_r1028, cpy_r_r1029, cpy_r_r1030, cpy_r_r1031, cpy_r_r1032, cpy_r_r1033, cpy_r_r1034, cpy_r_r1035, cpy_r_r1036, cpy_r_r1037, cpy_r_r1038, cpy_r_r1039, cpy_r_r1040, cpy_r_r1041);
    if (unlikely(cpy_r_r1042 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1123, CPyStatic_ops___globals);
        goto CPyL464;
    }
    cpy_r_r1043 = PyObject_SetAttr(cpy_r_r1017, cpy_r_r1019, cpy_r_r1042);
    CPy_DECREF(cpy_r_r1042);
    cpy_r_r1044 = cpy_r_r1043 >= 0;
    if (unlikely(!cpy_r_r1044)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1123, CPyStatic_ops___globals);
        goto CPyL464;
    }
    CPyType_ops___ComparisonOp = (PyTypeObject *)cpy_r_r1017;
    CPy_INCREF(CPyType_ops___ComparisonOp);
    cpy_r_r1045 = CPyStatic_ops___globals;
    cpy_r_r1046 = CPyStatics[6696]; /* 'ComparisonOp' */
    cpy_r_r1047 = CPyDict_SetItem(cpy_r_r1045, cpy_r_r1046, cpy_r_r1017);
    CPy_DECREF(cpy_r_r1017);
    cpy_r_r1048 = cpy_r_r1047 >= 0;
    if (unlikely(!cpy_r_r1048)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1123, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1049 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1050 = CPyStatics[7870]; /* 'EQ' */
    cpy_r_r1051 = CPyStatics[9029]; /* 100 */
    cpy_r_r1052 = PyObject_SetAttr(cpy_r_r1049, cpy_r_r1050, cpy_r_r1051);
    cpy_r_r1053 = cpy_r_r1052 >= 0;
    if (unlikely(!cpy_r_r1053)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1140, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1054 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1055 = CPyStatics[7871]; /* 'NEQ' */
    cpy_r_r1056 = CPyStatics[9053]; /* 101 */
    cpy_r_r1057 = PyObject_SetAttr(cpy_r_r1054, cpy_r_r1055, cpy_r_r1056);
    cpy_r_r1058 = cpy_r_r1057 >= 0;
    if (unlikely(!cpy_r_r1058)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1141, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1059 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1060 = CPyStatics[7872]; /* 'SLT' */
    cpy_r_r1061 = CPyStatics[9054]; /* 102 */
    cpy_r_r1062 = PyObject_SetAttr(cpy_r_r1059, cpy_r_r1060, cpy_r_r1061);
    cpy_r_r1063 = cpy_r_r1062 >= 0;
    if (unlikely(!cpy_r_r1063)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1142, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1064 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1065 = CPyStatics[7873]; /* 'SGT' */
    cpy_r_r1066 = CPyStatics[9055]; /* 103 */
    cpy_r_r1067 = PyObject_SetAttr(cpy_r_r1064, cpy_r_r1065, cpy_r_r1066);
    cpy_r_r1068 = cpy_r_r1067 >= 0;
    if (unlikely(!cpy_r_r1068)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1143, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1069 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1070 = CPyStatics[7874]; /* 'SLE' */
    cpy_r_r1071 = CPyStatics[9056]; /* 104 */
    cpy_r_r1072 = PyObject_SetAttr(cpy_r_r1069, cpy_r_r1070, cpy_r_r1071);
    cpy_r_r1073 = cpy_r_r1072 >= 0;
    if (unlikely(!cpy_r_r1073)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1144, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1074 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1075 = CPyStatics[7875]; /* 'SGE' */
    cpy_r_r1076 = CPyStatics[9057]; /* 105 */
    cpy_r_r1077 = PyObject_SetAttr(cpy_r_r1074, cpy_r_r1075, cpy_r_r1076);
    cpy_r_r1078 = cpy_r_r1077 >= 0;
    if (unlikely(!cpy_r_r1078)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1145, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1079 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1080 = CPyStatics[7876]; /* 'ULT' */
    cpy_r_r1081 = CPyStatics[9058]; /* 106 */
    cpy_r_r1082 = PyObject_SetAttr(cpy_r_r1079, cpy_r_r1080, cpy_r_r1081);
    cpy_r_r1083 = cpy_r_r1082 >= 0;
    if (unlikely(!cpy_r_r1083)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1146, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1084 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1085 = CPyStatics[7877]; /* 'UGT' */
    cpy_r_r1086 = CPyStatics[9059]; /* 107 */
    cpy_r_r1087 = PyObject_SetAttr(cpy_r_r1084, cpy_r_r1085, cpy_r_r1086);
    cpy_r_r1088 = cpy_r_r1087 >= 0;
    if (unlikely(!cpy_r_r1088)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1147, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1089 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1090 = CPyStatics[7878]; /* 'ULE' */
    cpy_r_r1091 = CPyStatics[9060]; /* 108 */
    cpy_r_r1092 = PyObject_SetAttr(cpy_r_r1089, cpy_r_r1090, cpy_r_r1091);
    cpy_r_r1093 = cpy_r_r1092 >= 0;
    if (unlikely(!cpy_r_r1093)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1148, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1094 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1095 = CPyStatics[7879]; /* 'UGE' */
    cpy_r_r1096 = CPyStatics[9061]; /* 109 */
    cpy_r_r1097 = PyObject_SetAttr(cpy_r_r1094, cpy_r_r1095, cpy_r_r1096);
    cpy_r_r1098 = cpy_r_r1097 >= 0;
    if (unlikely(!cpy_r_r1098)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1149, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1099 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1100 = CPyStatics[860]; /* '==' */
    cpy_r_r1101 = CPyStatics[863]; /* '!=' */
    cpy_r_r1102 = CPyStatics[2465]; /* '<' */
    cpy_r_r1103 = CPyStatics[840]; /* '>' */
    cpy_r_r1104 = CPyStatics[2470]; /* '<=' */
    cpy_r_r1105 = CPyStatics[2468]; /* '>=' */
    cpy_r_r1106 = CPyStatics[2465]; /* '<' */
    cpy_r_r1107 = CPyStatics[840]; /* '>' */
    cpy_r_r1108 = CPyStatics[2470]; /* '<=' */
    cpy_r_r1109 = CPyStatics[2468]; /* '>=' */
    cpy_r_r1110 = CPyStatics[9029]; /* 100 */
    cpy_r_r1111 = CPyStatics[9053]; /* 101 */
    cpy_r_r1112 = CPyStatics[9054]; /* 102 */
    cpy_r_r1113 = CPyStatics[9055]; /* 103 */
    cpy_r_r1114 = CPyStatics[9056]; /* 104 */
    cpy_r_r1115 = CPyStatics[9057]; /* 105 */
    cpy_r_r1116 = CPyStatics[9058]; /* 106 */
    cpy_r_r1117 = CPyStatics[9059]; /* 107 */
    cpy_r_r1118 = CPyStatics[9060]; /* 108 */
    cpy_r_r1119 = CPyStatics[9061]; /* 109 */
    cpy_r_r1120 = CPyDict_Build(10, cpy_r_r1110, cpy_r_r1100, cpy_r_r1111, cpy_r_r1101, cpy_r_r1112, cpy_r_r1102, cpy_r_r1113, cpy_r_r1103, cpy_r_r1114, cpy_r_r1104, cpy_r_r1115, cpy_r_r1105, cpy_r_r1116, cpy_r_r1106, cpy_r_r1117, cpy_r_r1107, cpy_r_r1118, cpy_r_r1108, cpy_r_r1119, cpy_r_r1109);
    if (unlikely(cpy_r_r1120 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1151, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1121 = CPyStatics[7868]; /* 'op_str' */
    cpy_r_r1122 = PyObject_SetAttr(cpy_r_r1099, cpy_r_r1121, cpy_r_r1120);
    cpy_r_r1123 = cpy_r_r1122 >= 0;
    if (unlikely(!cpy_r_r1123)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1151, CPyStatic_ops___globals);
        goto CPyL465;
    }
    CPyStatic_ops___ComparisonOp___op_str = cpy_r_r1120;
    CPy_INCREF(CPyStatic_ops___ComparisonOp___op_str);
    CPy_DECREF(cpy_r_r1120);
    cpy_r_r1124 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1125 = CPyStatics[860]; /* '==' */
    cpy_r_r1126 = CPyStatics[863]; /* '!=' */
    cpy_r_r1127 = CPyStatics[2465]; /* '<' */
    cpy_r_r1128 = CPyStatics[840]; /* '>' */
    cpy_r_r1129 = CPyStatics[2470]; /* '<=' */
    cpy_r_r1130 = CPyStatics[2468]; /* '>=' */
    cpy_r_r1131 = CPyStatics[9029]; /* 100 */
    cpy_r_r1132 = CPyStatics[9053]; /* 101 */
    cpy_r_r1133 = CPyStatics[9054]; /* 102 */
    cpy_r_r1134 = CPyStatics[9055]; /* 103 */
    cpy_r_r1135 = CPyStatics[9056]; /* 104 */
    cpy_r_r1136 = CPyStatics[9057]; /* 105 */
    cpy_r_r1137 = CPyDict_Build(6, cpy_r_r1125, cpy_r_r1131, cpy_r_r1126, cpy_r_r1132, cpy_r_r1127, cpy_r_r1133, cpy_r_r1128, cpy_r_r1134, cpy_r_r1129, cpy_r_r1135, cpy_r_r1130, cpy_r_r1136);
    if (unlikely(cpy_r_r1137 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1164, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1138 = CPyStatics[7880]; /* 'signed_ops' */
    cpy_r_r1139 = PyObject_SetAttr(cpy_r_r1124, cpy_r_r1138, cpy_r_r1137);
    cpy_r_r1140 = cpy_r_r1139 >= 0;
    if (unlikely(!cpy_r_r1140)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1164, CPyStatic_ops___globals);
        goto CPyL466;
    }
    CPyStatic_ops___ComparisonOp___signed_ops = cpy_r_r1137;
    CPy_INCREF(CPyStatic_ops___ComparisonOp___signed_ops);
    CPy_DECREF(cpy_r_r1137);
    cpy_r_r1141 = (PyObject *)CPyType_ops___ComparisonOp;
    cpy_r_r1142 = CPyStatics[860]; /* '==' */
    cpy_r_r1143 = CPyStatics[863]; /* '!=' */
    cpy_r_r1144 = CPyStatics[2465]; /* '<' */
    cpy_r_r1145 = CPyStatics[840]; /* '>' */
    cpy_r_r1146 = CPyStatics[2470]; /* '<=' */
    cpy_r_r1147 = CPyStatics[2468]; /* '>=' */
    cpy_r_r1148 = CPyStatics[9029]; /* 100 */
    cpy_r_r1149 = CPyStatics[9053]; /* 101 */
    cpy_r_r1150 = CPyStatics[9058]; /* 106 */
    cpy_r_r1151 = CPyStatics[9059]; /* 107 */
    cpy_r_r1152 = CPyStatics[9060]; /* 108 */
    cpy_r_r1153 = CPyStatics[9061]; /* 109 */
    cpy_r_r1154 = CPyDict_Build(6, cpy_r_r1142, cpy_r_r1148, cpy_r_r1143, cpy_r_r1149, cpy_r_r1144, cpy_r_r1150, cpy_r_r1145, cpy_r_r1151, cpy_r_r1146, cpy_r_r1152, cpy_r_r1147, cpy_r_r1153);
    if (unlikely(cpy_r_r1154 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1165, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1155 = CPyStatics[7881]; /* 'unsigned_ops' */
    cpy_r_r1156 = PyObject_SetAttr(cpy_r_r1141, cpy_r_r1155, cpy_r_r1154);
    cpy_r_r1157 = cpy_r_r1156 >= 0;
    if (unlikely(!cpy_r_r1157)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1165, CPyStatic_ops___globals);
        goto CPyL467;
    }
    CPyStatic_ops___ComparisonOp___unsigned_ops = cpy_r_r1154;
    CPy_INCREF(CPyStatic_ops___ComparisonOp___unsigned_ops);
    CPy_DECREF(cpy_r_r1154);
    cpy_r_r1158 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r1159 = PyTuple_Pack(1, cpy_r_r1158);
    if (unlikely(cpy_r_r1159 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1181, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1160 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r1161 = (PyObject *)CPyType_ops___FloatOp_template;
    cpy_r_r1162 = CPyType_FromTemplate(cpy_r_r1161, cpy_r_r1159, cpy_r_r1160);
    CPy_DECREF(cpy_r_r1159);
    if (unlikely(cpy_r_r1162 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1181, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1163 = CPyDef_ops___FloatOp_trait_vtable_setup();
    if (unlikely(cpy_r_r1163 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL468;
    }
    cpy_r_r1164 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r1165 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1166 = CPyStatics[7858]; /* 'ADD' */
    cpy_r_r1167 = CPyStatics[7859]; /* 'SUB' */
    cpy_r_r1168 = CPyStatics[7860]; /* 'MUL' */
    cpy_r_r1169 = CPyStatics[7861]; /* 'DIV' */
    cpy_r_r1170 = CPyStatics[7862]; /* 'MOD' */
    cpy_r_r1171 = CPyStatics[7868]; /* 'op_str' */
    cpy_r_r1172 = CPyStatics[7629]; /* 'lhs' */
    cpy_r_r1173 = CPyStatics[7630]; /* 'rhs' */
    cpy_r_r1174 = CPyStatics[1628]; /* 'op' */
    cpy_r_r1175 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1176 = CPyStatics[5126]; /* '_type' */
    cpy_r_r1177 = CPyStatics[2272]; /* 'line' */
    cpy_r_r1178 = CPyStatics[802]; /* 'type' */
    cpy_r_r1179 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r1180 = PyTuple_Pack(15, cpy_r_r1165, cpy_r_r1166, cpy_r_r1167, cpy_r_r1168, cpy_r_r1169, cpy_r_r1170, cpy_r_r1171, cpy_r_r1172, cpy_r_r1173, cpy_r_r1174, cpy_r_r1175, cpy_r_r1176, cpy_r_r1177, cpy_r_r1178, cpy_r_r1179);
    if (unlikely(cpy_r_r1180 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1181, CPyStatic_ops___globals);
        goto CPyL468;
    }
    cpy_r_r1181 = PyObject_SetAttr(cpy_r_r1162, cpy_r_r1164, cpy_r_r1180);
    CPy_DECREF(cpy_r_r1180);
    cpy_r_r1182 = cpy_r_r1181 >= 0;
    if (unlikely(!cpy_r_r1182)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1181, CPyStatic_ops___globals);
        goto CPyL468;
    }
    CPyType_ops___FloatOp = (PyTypeObject *)cpy_r_r1162;
    CPy_INCREF(CPyType_ops___FloatOp);
    cpy_r_r1183 = CPyStatic_ops___globals;
    cpy_r_r1184 = CPyStatics[6701]; /* 'FloatOp' */
    cpy_r_r1185 = CPyDict_SetItem(cpy_r_r1183, cpy_r_r1184, cpy_r_r1162);
    CPy_DECREF(cpy_r_r1162);
    cpy_r_r1186 = cpy_r_r1185 >= 0;
    if (unlikely(!cpy_r_r1186)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1181, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1187 = (PyObject *)CPyType_ops___FloatOp;
    cpy_r_r1188 = CPyStatics[7858]; /* 'ADD' */
    cpy_r_r1189 = CPyStatics[9015]; /* 0 */
    cpy_r_r1190 = PyObject_SetAttr(cpy_r_r1187, cpy_r_r1188, cpy_r_r1189);
    cpy_r_r1191 = cpy_r_r1190 >= 0;
    if (unlikely(!cpy_r_r1191)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1192, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1192 = (PyObject *)CPyType_ops___FloatOp;
    cpy_r_r1193 = CPyStatics[7859]; /* 'SUB' */
    cpy_r_r1194 = CPyStatics[9016]; /* 1 */
    cpy_r_r1195 = PyObject_SetAttr(cpy_r_r1192, cpy_r_r1193, cpy_r_r1194);
    cpy_r_r1196 = cpy_r_r1195 >= 0;
    if (unlikely(!cpy_r_r1196)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1193, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1197 = (PyObject *)CPyType_ops___FloatOp;
    cpy_r_r1198 = CPyStatics[7860]; /* 'MUL' */
    cpy_r_r1199 = CPyStatics[9018]; /* 2 */
    cpy_r_r1200 = PyObject_SetAttr(cpy_r_r1197, cpy_r_r1198, cpy_r_r1199);
    cpy_r_r1201 = cpy_r_r1200 >= 0;
    if (unlikely(!cpy_r_r1201)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1194, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1202 = (PyObject *)CPyType_ops___FloatOp;
    cpy_r_r1203 = CPyStatics[7861]; /* 'DIV' */
    cpy_r_r1204 = CPyStatics[9026]; /* 3 */
    cpy_r_r1205 = PyObject_SetAttr(cpy_r_r1202, cpy_r_r1203, cpy_r_r1204);
    cpy_r_r1206 = cpy_r_r1205 >= 0;
    if (unlikely(!cpy_r_r1206)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1195, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1207 = (PyObject *)CPyType_ops___FloatOp;
    cpy_r_r1208 = CPyStatics[7862]; /* 'MOD' */
    cpy_r_r1209 = CPyStatics[9025]; /* 4 */
    cpy_r_r1210 = PyObject_SetAttr(cpy_r_r1207, cpy_r_r1208, cpy_r_r1209);
    cpy_r_r1211 = cpy_r_r1210 >= 0;
    if (unlikely(!cpy_r_r1211)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1196, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1212 = (PyObject *)CPyType_ops___FloatOp;
    cpy_r_r1213 = CPyStatics[886]; /* '+' */
    cpy_r_r1214 = CPyStatics[1198]; /* '-' */
    cpy_r_r1215 = CPyStatics[282]; /* '*' */
    cpy_r_r1216 = CPyStatics[1594]; /* '/' */
    cpy_r_r1217 = CPyStatics[1183]; /* '%' */
    cpy_r_r1218 = CPyStatics[9015]; /* 0 */
    cpy_r_r1219 = CPyStatics[9016]; /* 1 */
    cpy_r_r1220 = CPyStatics[9018]; /* 2 */
    cpy_r_r1221 = CPyStatics[9026]; /* 3 */
    cpy_r_r1222 = CPyStatics[9025]; /* 4 */
    cpy_r_r1223 = CPyDict_Build(5, cpy_r_r1218, cpy_r_r1213, cpy_r_r1219, cpy_r_r1214, cpy_r_r1220, cpy_r_r1215, cpy_r_r1221, cpy_r_r1216, cpy_r_r1222, cpy_r_r1217);
    if (unlikely(cpy_r_r1223 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1198, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1224 = CPyStatics[7868]; /* 'op_str' */
    cpy_r_r1225 = PyObject_SetAttr(cpy_r_r1212, cpy_r_r1224, cpy_r_r1223);
    cpy_r_r1226 = cpy_r_r1225 >= 0;
    if (unlikely(!cpy_r_r1226)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1198, CPyStatic_ops___globals);
        goto CPyL469;
    }
    CPyStatic_ops___FloatOp___op_str = cpy_r_r1223;
    CPy_INCREF(CPyStatic_ops___FloatOp___op_str);
    CPy_DECREF(cpy_r_r1223);
    cpy_r_r1227 = PyDict_New();
    if (unlikely(cpy_r_r1227 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1216, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1228 = CPyStatic_ops___FloatOp___op_str;
    if (unlikely(cpy_r_r1228 == NULL)) {
        goto CPyL470;
    } else
        goto CPyL314;
CPyL312: ;
    PyErr_SetString(PyExc_NameError, "value for final name \"op_str\" was not set");
    cpy_r_r1229 = 0;
    if (unlikely(!cpy_r_r1229)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1216, CPyStatic_ops___globals);
        goto CPyL419;
    }
    CPy_Unreachable();
CPyL314: ;
    cpy_r_r1230 = 0;
    cpy_r_r1231 = PyDict_Size(cpy_r_r1228);
    cpy_r_r1232 = cpy_r_r1231 << 1;
    cpy_r_r1233 = CPyDict_GetItemsIter(cpy_r_r1228);
    if (unlikely(cpy_r_r1233 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1216, CPyStatic_ops___globals);
        goto CPyL471;
    }
CPyL315: ;
    cpy_r_r1234 = CPyDict_NextItem(cpy_r_r1233, cpy_r_r1230);
    cpy_r_r1235 = cpy_r_r1234.f1;
    cpy_r_r1230 = cpy_r_r1235;
    cpy_r_r1236 = cpy_r_r1234.f0;
    if (!cpy_r_r1236) goto CPyL472;
    cpy_r_r1237 = cpy_r_r1234.f2;
    CPy_INCREF(cpy_r_r1237);
    cpy_r_r1238 = cpy_r_r1234.f3;
    CPy_INCREF(cpy_r_r1238);
    CPy_DECREF(cpy_r_r1234.f2);
    CPy_DECREF(cpy_r_r1234.f3);
    if (likely(PyLong_Check(cpy_r_r1237)))
        cpy_r_r1239 = CPyTagged_FromObject(cpy_r_r1237);
    else {
        CPy_TypeError("int", cpy_r_r1237); cpy_r_r1239 = CPY_INT_TAG;
    }
    CPy_DECREF(cpy_r_r1237);
    if (unlikely(cpy_r_r1239 == CPY_INT_TAG)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1216, CPyStatic_ops___globals);
        goto CPyL473;
    }
    if (likely(PyUnicode_Check(cpy_r_r1238)))
        cpy_r_r1240 = cpy_r_r1238;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "<module>", 1216, CPyStatic_ops___globals, "str", cpy_r_r1238);
        goto CPyL474;
    }
    cpy_r_op_id_2 = cpy_r_r1239;
    cpy_r_op_2 = cpy_r_r1240;
    cpy_r_r1241 = CPyTagged_StealAsObject(cpy_r_op_id_2);
    cpy_r_r1242 = CPyDict_SetItem(cpy_r_r1227, cpy_r_op_2, cpy_r_r1241);
    CPy_DECREF(cpy_r_op_2);
    CPy_DECREF(cpy_r_r1241);
    cpy_r_r1243 = cpy_r_r1242 >= 0;
    if (unlikely(!cpy_r_r1243)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1216, CPyStatic_ops___globals);
        goto CPyL475;
    }
    cpy_r_r1244 = CPyDict_CheckSize(cpy_r_r1228, cpy_r_r1232);
    if (unlikely(!cpy_r_r1244)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1216, CPyStatic_ops___globals);
        goto CPyL475;
    } else
        goto CPyL315;
CPyL320: ;
    cpy_r_r1245 = CPy_NoErrOccured();
    if (unlikely(!cpy_r_r1245)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1216, CPyStatic_ops___globals);
        goto CPyL471;
    }
    CPyStatic_ops___float_op_to_id = cpy_r_r1227;
    CPy_INCREF(CPyStatic_ops___float_op_to_id);
    cpy_r_r1246 = CPyStatic_ops___globals;
    cpy_r_r1247 = CPyStatics[7882]; /* 'float_op_to_id' */
    cpy_r_r1248 = CPyDict_SetItem(cpy_r_r1246, cpy_r_r1247, cpy_r_r1227);
    CPy_DECREF(cpy_r_r1227);
    cpy_r_r1249 = cpy_r_r1248 >= 0;
    if (unlikely(!cpy_r_r1249)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1216, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1250 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r1251 = PyTuple_Pack(1, cpy_r_r1250);
    if (unlikely(cpy_r_r1251 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1219, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1252 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r1253 = (PyObject *)CPyType_ops___FloatNeg_template;
    cpy_r_r1254 = CPyType_FromTemplate(cpy_r_r1253, cpy_r_r1251, cpy_r_r1252);
    CPy_DECREF(cpy_r_r1251);
    if (unlikely(cpy_r_r1254 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1219, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1255 = CPyDef_ops___FloatNeg_trait_vtable_setup();
    if (unlikely(cpy_r_r1255 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL476;
    }
    cpy_r_r1256 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r1257 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1258 = CPyStatics[6937]; /* 'src' */
    cpy_r_r1259 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1260 = CPyStatics[5126]; /* '_type' */
    cpy_r_r1261 = CPyStatics[2272]; /* 'line' */
    cpy_r_r1262 = CPyStatics[802]; /* 'type' */
    cpy_r_r1263 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r1264 = PyTuple_Pack(7, cpy_r_r1257, cpy_r_r1258, cpy_r_r1259, cpy_r_r1260, cpy_r_r1261, cpy_r_r1262, cpy_r_r1263);
    if (unlikely(cpy_r_r1264 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1219, CPyStatic_ops___globals);
        goto CPyL476;
    }
    cpy_r_r1265 = PyObject_SetAttr(cpy_r_r1254, cpy_r_r1256, cpy_r_r1264);
    CPy_DECREF(cpy_r_r1264);
    cpy_r_r1266 = cpy_r_r1265 >= 0;
    if (unlikely(!cpy_r_r1266)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1219, CPyStatic_ops___globals);
        goto CPyL476;
    }
    CPyType_ops___FloatNeg = (PyTypeObject *)cpy_r_r1254;
    CPy_INCREF(CPyType_ops___FloatNeg);
    cpy_r_r1267 = CPyStatic_ops___globals;
    cpy_r_r1268 = CPyStatics[6700]; /* 'FloatNeg' */
    cpy_r_r1269 = CPyDict_SetItem(cpy_r_r1267, cpy_r_r1268, cpy_r_r1254);
    CPy_DECREF(cpy_r_r1254);
    cpy_r_r1270 = cpy_r_r1269 >= 0;
    if (unlikely(!cpy_r_r1270)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1219, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1271 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r1272 = PyTuple_Pack(1, cpy_r_r1271);
    if (unlikely(cpy_r_r1272 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1236, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1273 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r1274 = (PyObject *)CPyType_ops___FloatComparisonOp_template;
    cpy_r_r1275 = CPyType_FromTemplate(cpy_r_r1274, cpy_r_r1272, cpy_r_r1273);
    CPy_DECREF(cpy_r_r1272);
    if (unlikely(cpy_r_r1275 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1236, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1276 = CPyDef_ops___FloatComparisonOp_trait_vtable_setup();
    if (unlikely(cpy_r_r1276 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL477;
    }
    cpy_r_r1277 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r1278 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1279 = CPyStatics[7870]; /* 'EQ' */
    cpy_r_r1280 = CPyStatics[7871]; /* 'NEQ' */
    cpy_r_r1281 = CPyStatics[7883]; /* 'LT' */
    cpy_r_r1282 = CPyStatics[7884]; /* 'GT' */
    cpy_r_r1283 = CPyStatics[7885]; /* 'LE' */
    cpy_r_r1284 = CPyStatics[7886]; /* 'GE' */
    cpy_r_r1285 = CPyStatics[7868]; /* 'op_str' */
    cpy_r_r1286 = CPyStatics[7629]; /* 'lhs' */
    cpy_r_r1287 = CPyStatics[7630]; /* 'rhs' */
    cpy_r_r1288 = CPyStatics[1628]; /* 'op' */
    cpy_r_r1289 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1290 = CPyStatics[5126]; /* '_type' */
    cpy_r_r1291 = CPyStatics[2272]; /* 'line' */
    cpy_r_r1292 = CPyStatics[802]; /* 'type' */
    cpy_r_r1293 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r1294 = PyTuple_Pack(16, cpy_r_r1278, cpy_r_r1279, cpy_r_r1280, cpy_r_r1281, cpy_r_r1282, cpy_r_r1283, cpy_r_r1284, cpy_r_r1285, cpy_r_r1286, cpy_r_r1287, cpy_r_r1288, cpy_r_r1289, cpy_r_r1290, cpy_r_r1291, cpy_r_r1292, cpy_r_r1293);
    if (unlikely(cpy_r_r1294 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1236, CPyStatic_ops___globals);
        goto CPyL477;
    }
    cpy_r_r1295 = PyObject_SetAttr(cpy_r_r1275, cpy_r_r1277, cpy_r_r1294);
    CPy_DECREF(cpy_r_r1294);
    cpy_r_r1296 = cpy_r_r1295 >= 0;
    if (unlikely(!cpy_r_r1296)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1236, CPyStatic_ops___globals);
        goto CPyL477;
    }
    CPyType_ops___FloatComparisonOp = (PyTypeObject *)cpy_r_r1275;
    CPy_INCREF(CPyType_ops___FloatComparisonOp);
    cpy_r_r1297 = CPyStatic_ops___globals;
    cpy_r_r1298 = CPyStatics[6699]; /* 'FloatComparisonOp' */
    cpy_r_r1299 = CPyDict_SetItem(cpy_r_r1297, cpy_r_r1298, cpy_r_r1275);
    CPy_DECREF(cpy_r_r1275);
    cpy_r_r1300 = cpy_r_r1299 >= 0;
    if (unlikely(!cpy_r_r1300)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1236, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1301 = (PyObject *)CPyType_ops___FloatComparisonOp;
    cpy_r_r1302 = CPyStatics[7870]; /* 'EQ' */
    cpy_r_r1303 = CPyStatics[9048]; /* 200 */
    cpy_r_r1304 = PyObject_SetAttr(cpy_r_r1301, cpy_r_r1302, cpy_r_r1303);
    cpy_r_r1305 = cpy_r_r1304 >= 0;
    if (unlikely(!cpy_r_r1305)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1241, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1306 = (PyObject *)CPyType_ops___FloatComparisonOp;
    cpy_r_r1307 = CPyStatics[7871]; /* 'NEQ' */
    cpy_r_r1308 = CPyStatics[9049]; /* 201 */
    cpy_r_r1309 = PyObject_SetAttr(cpy_r_r1306, cpy_r_r1307, cpy_r_r1308);
    cpy_r_r1310 = cpy_r_r1309 >= 0;
    if (unlikely(!cpy_r_r1310)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1242, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1311 = (PyObject *)CPyType_ops___FloatComparisonOp;
    cpy_r_r1312 = CPyStatics[7883]; /* 'LT' */
    cpy_r_r1313 = CPyStatics[9050]; /* 202 */
    cpy_r_r1314 = PyObject_SetAttr(cpy_r_r1311, cpy_r_r1312, cpy_r_r1313);
    cpy_r_r1315 = cpy_r_r1314 >= 0;
    if (unlikely(!cpy_r_r1315)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1243, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1316 = (PyObject *)CPyType_ops___FloatComparisonOp;
    cpy_r_r1317 = CPyStatics[7884]; /* 'GT' */
    cpy_r_r1318 = CPyStatics[9051]; /* 203 */
    cpy_r_r1319 = PyObject_SetAttr(cpy_r_r1316, cpy_r_r1317, cpy_r_r1318);
    cpy_r_r1320 = cpy_r_r1319 >= 0;
    if (unlikely(!cpy_r_r1320)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1244, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1321 = (PyObject *)CPyType_ops___FloatComparisonOp;
    cpy_r_r1322 = CPyStatics[7885]; /* 'LE' */
    cpy_r_r1323 = CPyStatics[9052]; /* 204 */
    cpy_r_r1324 = PyObject_SetAttr(cpy_r_r1321, cpy_r_r1322, cpy_r_r1323);
    cpy_r_r1325 = cpy_r_r1324 >= 0;
    if (unlikely(!cpy_r_r1325)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1245, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1326 = (PyObject *)CPyType_ops___FloatComparisonOp;
    cpy_r_r1327 = CPyStatics[7886]; /* 'GE' */
    cpy_r_r1328 = CPyStatics[9062]; /* 205 */
    cpy_r_r1329 = PyObject_SetAttr(cpy_r_r1326, cpy_r_r1327, cpy_r_r1328);
    cpy_r_r1330 = cpy_r_r1329 >= 0;
    if (unlikely(!cpy_r_r1330)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1246, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1331 = (PyObject *)CPyType_ops___FloatComparisonOp;
    cpy_r_r1332 = CPyStatics[860]; /* '==' */
    cpy_r_r1333 = CPyStatics[863]; /* '!=' */
    cpy_r_r1334 = CPyStatics[2465]; /* '<' */
    cpy_r_r1335 = CPyStatics[840]; /* '>' */
    cpy_r_r1336 = CPyStatics[2470]; /* '<=' */
    cpy_r_r1337 = CPyStatics[2468]; /* '>=' */
    cpy_r_r1338 = CPyStatics[9048]; /* 200 */
    cpy_r_r1339 = CPyStatics[9049]; /* 201 */
    cpy_r_r1340 = CPyStatics[9050]; /* 202 */
    cpy_r_r1341 = CPyStatics[9051]; /* 203 */
    cpy_r_r1342 = CPyStatics[9052]; /* 204 */
    cpy_r_r1343 = CPyStatics[9062]; /* 205 */
    cpy_r_r1344 = CPyDict_Build(6, cpy_r_r1338, cpy_r_r1332, cpy_r_r1339, cpy_r_r1333, cpy_r_r1340, cpy_r_r1334, cpy_r_r1341, cpy_r_r1335, cpy_r_r1342, cpy_r_r1336, cpy_r_r1343, cpy_r_r1337);
    if (unlikely(cpy_r_r1344 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1248, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1345 = CPyStatics[7868]; /* 'op_str' */
    cpy_r_r1346 = PyObject_SetAttr(cpy_r_r1331, cpy_r_r1345, cpy_r_r1344);
    cpy_r_r1347 = cpy_r_r1346 >= 0;
    if (unlikely(!cpy_r_r1347)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1248, CPyStatic_ops___globals);
        goto CPyL478;
    }
    CPyStatic_ops___FloatComparisonOp___op_str = cpy_r_r1344;
    CPy_INCREF(CPyStatic_ops___FloatComparisonOp___op_str);
    CPy_DECREF(cpy_r_r1344);
    cpy_r_r1348 = PyDict_New();
    if (unlikely(cpy_r_r1348 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1266, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1349 = CPyStatic_ops___FloatComparisonOp___op_str;
    if (unlikely(cpy_r_r1349 == NULL)) {
        goto CPyL479;
    } else
        goto CPyL346;
CPyL344: ;
    PyErr_SetString(PyExc_NameError, "value for final name \"op_str\" was not set");
    cpy_r_r1350 = 0;
    if (unlikely(!cpy_r_r1350)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1266, CPyStatic_ops___globals);
        goto CPyL419;
    }
    CPy_Unreachable();
CPyL346: ;
    cpy_r_r1351 = 0;
    cpy_r_r1352 = PyDict_Size(cpy_r_r1349);
    cpy_r_r1353 = cpy_r_r1352 << 1;
    cpy_r_r1354 = CPyDict_GetItemsIter(cpy_r_r1349);
    if (unlikely(cpy_r_r1354 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1266, CPyStatic_ops___globals);
        goto CPyL480;
    }
CPyL347: ;
    cpy_r_r1355 = CPyDict_NextItem(cpy_r_r1354, cpy_r_r1351);
    cpy_r_r1356 = cpy_r_r1355.f1;
    cpy_r_r1351 = cpy_r_r1356;
    cpy_r_r1357 = cpy_r_r1355.f0;
    if (!cpy_r_r1357) goto CPyL481;
    cpy_r_r1358 = cpy_r_r1355.f2;
    CPy_INCREF(cpy_r_r1358);
    cpy_r_r1359 = cpy_r_r1355.f3;
    CPy_INCREF(cpy_r_r1359);
    CPy_DECREF(cpy_r_r1355.f2);
    CPy_DECREF(cpy_r_r1355.f3);
    if (likely(PyLong_Check(cpy_r_r1358)))
        cpy_r_r1360 = CPyTagged_FromObject(cpy_r_r1358);
    else {
        CPy_TypeError("int", cpy_r_r1358); cpy_r_r1360 = CPY_INT_TAG;
    }
    CPy_DECREF(cpy_r_r1358);
    if (unlikely(cpy_r_r1360 == CPY_INT_TAG)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1266, CPyStatic_ops___globals);
        goto CPyL482;
    }
    if (likely(PyUnicode_Check(cpy_r_r1359)))
        cpy_r_r1361 = cpy_r_r1359;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "<module>", 1266, CPyStatic_ops___globals, "str", cpy_r_r1359);
        goto CPyL483;
    }
    cpy_r_op_id_3 = cpy_r_r1360;
    cpy_r_op_3 = cpy_r_r1361;
    cpy_r_r1362 = CPyTagged_StealAsObject(cpy_r_op_id_3);
    cpy_r_r1363 = CPyDict_SetItem(cpy_r_r1348, cpy_r_op_3, cpy_r_r1362);
    CPy_DECREF(cpy_r_op_3);
    CPy_DECREF(cpy_r_r1362);
    cpy_r_r1364 = cpy_r_r1363 >= 0;
    if (unlikely(!cpy_r_r1364)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1266, CPyStatic_ops___globals);
        goto CPyL484;
    }
    cpy_r_r1365 = CPyDict_CheckSize(cpy_r_r1349, cpy_r_r1353);
    if (unlikely(!cpy_r_r1365)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1266, CPyStatic_ops___globals);
        goto CPyL484;
    } else
        goto CPyL347;
CPyL352: ;
    cpy_r_r1366 = CPy_NoErrOccured();
    if (unlikely(!cpy_r_r1366)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1266, CPyStatic_ops___globals);
        goto CPyL480;
    }
    CPyStatic_ops___float_comparison_op_to_id = cpy_r_r1348;
    CPy_INCREF(CPyStatic_ops___float_comparison_op_to_id);
    cpy_r_r1367 = CPyStatic_ops___globals;
    cpy_r_r1368 = CPyStatics[7887]; /* 'float_comparison_op_to_id' */
    cpy_r_r1369 = CPyDict_SetItem(cpy_r_r1367, cpy_r_r1368, cpy_r_r1348);
    CPy_DECREF(cpy_r_r1348);
    cpy_r_r1370 = cpy_r_r1369 >= 0;
    if (unlikely(!cpy_r_r1370)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1266, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1371 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r1372 = PyTuple_Pack(1, cpy_r_r1371);
    if (unlikely(cpy_r_r1372 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1269, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1373 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r1374 = (PyObject *)CPyType_ops___LoadMem_template;
    cpy_r_r1375 = CPyType_FromTemplate(cpy_r_r1374, cpy_r_r1372, cpy_r_r1373);
    CPy_DECREF(cpy_r_r1372);
    if (unlikely(cpy_r_r1375 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1269, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1376 = CPyDef_ops___LoadMem_trait_vtable_setup();
    if (unlikely(cpy_r_r1376 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL485;
    }
    cpy_r_r1377 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r1378 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1379 = CPyStatics[6937]; /* 'src' */
    cpy_r_r1380 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1381 = CPyStatics[5126]; /* '_type' */
    cpy_r_r1382 = CPyStatics[2272]; /* 'line' */
    cpy_r_r1383 = CPyStatics[802]; /* 'type' */
    cpy_r_r1384 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r1385 = PyTuple_Pack(7, cpy_r_r1378, cpy_r_r1379, cpy_r_r1380, cpy_r_r1381, cpy_r_r1382, cpy_r_r1383, cpy_r_r1384);
    if (unlikely(cpy_r_r1385 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1269, CPyStatic_ops___globals);
        goto CPyL485;
    }
    cpy_r_r1386 = PyObject_SetAttr(cpy_r_r1375, cpy_r_r1377, cpy_r_r1385);
    CPy_DECREF(cpy_r_r1385);
    cpy_r_r1387 = cpy_r_r1386 >= 0;
    if (unlikely(!cpy_r_r1387)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1269, CPyStatic_ops___globals);
        goto CPyL485;
    }
    CPyType_ops___LoadMem = (PyTypeObject *)cpy_r_r1375;
    CPy_INCREF(CPyType_ops___LoadMem);
    cpy_r_r1388 = CPyStatic_ops___globals;
    cpy_r_r1389 = CPyStatics[6711]; /* 'LoadMem' */
    cpy_r_r1390 = CPyDict_SetItem(cpy_r_r1388, cpy_r_r1389, cpy_r_r1375);
    CPy_DECREF(cpy_r_r1375);
    cpy_r_r1391 = cpy_r_r1390 >= 0;
    if (unlikely(!cpy_r_r1391)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1269, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1392 = (PyObject *)CPyType_ops___Op;
    cpy_r_r1393 = PyTuple_Pack(1, cpy_r_r1392);
    if (unlikely(cpy_r_r1393 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1295, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1394 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r1395 = (PyObject *)CPyType_ops___SetMem_template;
    cpy_r_r1396 = CPyType_FromTemplate(cpy_r_r1395, cpy_r_r1393, cpy_r_r1394);
    CPy_DECREF(cpy_r_r1393);
    if (unlikely(cpy_r_r1396 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1295, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1397 = CPyDef_ops___SetMem_trait_vtable_setup();
    if (unlikely(cpy_r_r1397 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL486;
    }
    cpy_r_r1398 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r1399 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1400 = CPyStatics[7888]; /* 'dest_type' */
    cpy_r_r1401 = CPyStatics[6937]; /* 'src' */
    cpy_r_r1402 = CPyStatics[2747]; /* 'dest' */
    cpy_r_r1403 = CPyStatics[2272]; /* 'line' */
    cpy_r_r1404 = CPyStatics[802]; /* 'type' */
    cpy_r_r1405 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r1406 = PyTuple_Pack(7, cpy_r_r1399, cpy_r_r1400, cpy_r_r1401, cpy_r_r1402, cpy_r_r1403, cpy_r_r1404, cpy_r_r1405);
    if (unlikely(cpy_r_r1406 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1295, CPyStatic_ops___globals);
        goto CPyL486;
    }
    cpy_r_r1407 = PyObject_SetAttr(cpy_r_r1396, cpy_r_r1398, cpy_r_r1406);
    CPy_DECREF(cpy_r_r1406);
    cpy_r_r1408 = cpy_r_r1407 >= 0;
    if (unlikely(!cpy_r_r1408)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1295, CPyStatic_ops___globals);
        goto CPyL486;
    }
    CPyType_ops___SetMem = (PyTypeObject *)cpy_r_r1396;
    CPy_INCREF(CPyType_ops___SetMem);
    cpy_r_r1409 = CPyStatic_ops___globals;
    cpy_r_r1410 = CPyStatics[6672]; /* 'SetMem' */
    cpy_r_r1411 = CPyDict_SetItem(cpy_r_r1409, cpy_r_r1410, cpy_r_r1396);
    CPy_DECREF(cpy_r_r1396);
    cpy_r_r1412 = cpy_r_r1411 >= 0;
    if (unlikely(!cpy_r_r1412)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1295, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1413 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r1414 = PyTuple_Pack(1, cpy_r_r1413);
    if (unlikely(cpy_r_r1414 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1323, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1415 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r1416 = (PyObject *)CPyType_ops___GetElementPtr_template;
    cpy_r_r1417 = CPyType_FromTemplate(cpy_r_r1416, cpy_r_r1414, cpy_r_r1415);
    CPy_DECREF(cpy_r_r1414);
    if (unlikely(cpy_r_r1417 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1323, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1418 = CPyDef_ops___GetElementPtr_trait_vtable_setup();
    if (unlikely(cpy_r_r1418 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL487;
    }
    cpy_r_r1419 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r1420 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1421 = CPyStatics[6937]; /* 'src' */
    cpy_r_r1422 = CPyStatics[7856]; /* 'src_type' */
    cpy_r_r1423 = CPyStatics[1400]; /* 'field' */
    cpy_r_r1424 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1425 = CPyStatics[5126]; /* '_type' */
    cpy_r_r1426 = CPyStatics[2272]; /* 'line' */
    cpy_r_r1427 = CPyStatics[802]; /* 'type' */
    cpy_r_r1428 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r1429 = PyTuple_Pack(9, cpy_r_r1420, cpy_r_r1421, cpy_r_r1422, cpy_r_r1423, cpy_r_r1424, cpy_r_r1425, cpy_r_r1426, cpy_r_r1427, cpy_r_r1428);
    if (unlikely(cpy_r_r1429 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1323, CPyStatic_ops___globals);
        goto CPyL487;
    }
    cpy_r_r1430 = PyObject_SetAttr(cpy_r_r1417, cpy_r_r1419, cpy_r_r1429);
    CPy_DECREF(cpy_r_r1429);
    cpy_r_r1431 = cpy_r_r1430 >= 0;
    if (unlikely(!cpy_r_r1431)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1323, CPyStatic_ops___globals);
        goto CPyL487;
    }
    CPyType_ops___GetElementPtr = (PyTypeObject *)cpy_r_r1417;
    CPy_INCREF(CPyType_ops___GetElementPtr);
    cpy_r_r1432 = CPyStatic_ops___globals;
    cpy_r_r1433 = CPyStatics[6702]; /* 'GetElementPtr' */
    cpy_r_r1434 = CPyDict_SetItem(cpy_r_r1432, cpy_r_r1433, cpy_r_r1417);
    CPy_DECREF(cpy_r_r1417);
    cpy_r_r1435 = cpy_r_r1434 >= 0;
    if (unlikely(!cpy_r_r1435)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1323, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1436 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r1437 = PyTuple_Pack(1, cpy_r_r1436);
    if (unlikely(cpy_r_r1437 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1346, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1438 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r1439 = (PyObject *)CPyType_ops___LoadAddress_template;
    cpy_r_r1440 = CPyType_FromTemplate(cpy_r_r1439, cpy_r_r1437, cpy_r_r1438);
    CPy_DECREF(cpy_r_r1437);
    if (unlikely(cpy_r_r1440 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1346, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1441 = CPyDef_ops___LoadAddress_trait_vtable_setup();
    if (unlikely(cpy_r_r1441 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL488;
    }
    cpy_r_r1442 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r1443 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1444 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r1445 = CPyStatics[6937]; /* 'src' */
    cpy_r_r1446 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1447 = CPyStatics[5126]; /* '_type' */
    cpy_r_r1448 = CPyStatics[2272]; /* 'line' */
    cpy_r_r1449 = CPyStatics[802]; /* 'type' */
    cpy_r_r1450 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r1451 = PyTuple_Pack(8, cpy_r_r1443, cpy_r_r1444, cpy_r_r1445, cpy_r_r1446, cpy_r_r1447, cpy_r_r1448, cpy_r_r1449, cpy_r_r1450);
    if (unlikely(cpy_r_r1451 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1346, CPyStatic_ops___globals);
        goto CPyL488;
    }
    cpy_r_r1452 = PyObject_SetAttr(cpy_r_r1440, cpy_r_r1442, cpy_r_r1451);
    CPy_DECREF(cpy_r_r1451);
    cpy_r_r1453 = cpy_r_r1452 >= 0;
    if (unlikely(!cpy_r_r1453)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1346, CPyStatic_ops___globals);
        goto CPyL488;
    }
    CPyType_ops___LoadAddress = (PyTypeObject *)cpy_r_r1440;
    CPy_INCREF(CPyType_ops___LoadAddress);
    cpy_r_r1454 = CPyStatic_ops___globals;
    cpy_r_r1455 = CPyStatics[6707]; /* 'LoadAddress' */
    cpy_r_r1456 = CPyDict_SetItem(cpy_r_r1454, cpy_r_r1455, cpy_r_r1440);
    CPy_DECREF(cpy_r_r1440);
    cpy_r_r1457 = cpy_r_r1456 >= 0;
    if (unlikely(!cpy_r_r1457)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1346, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1458 = (PyObject *)CPyType_ops___RegisterOp;
    cpy_r_r1459 = PyTuple_Pack(1, cpy_r_r1458);
    if (unlikely(cpy_r_r1459 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1374, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1460 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r1461 = (PyObject *)CPyType_ops___KeepAlive_template;
    cpy_r_r1462 = CPyType_FromTemplate(cpy_r_r1461, cpy_r_r1459, cpy_r_r1460);
    CPy_DECREF(cpy_r_r1459);
    if (unlikely(cpy_r_r1462 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1374, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1463 = CPyDef_ops___KeepAlive_trait_vtable_setup();
    if (unlikely(cpy_r_r1463 == 2)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", -1, CPyStatic_ops___globals);
        goto CPyL489;
    }
    cpy_r_r1464 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r1465 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1466 = CPyStatics[6937]; /* 'src' */
    cpy_r_r1467 = CPyStatics[7830]; /* 'error_kind' */
    cpy_r_r1468 = CPyStatics[5126]; /* '_type' */
    cpy_r_r1469 = CPyStatics[2272]; /* 'line' */
    cpy_r_r1470 = CPyStatics[802]; /* 'type' */
    cpy_r_r1471 = CPyStatics[7828]; /* 'is_borrowed' */
    cpy_r_r1472 = PyTuple_Pack(7, cpy_r_r1465, cpy_r_r1466, cpy_r_r1467, cpy_r_r1468, cpy_r_r1469, cpy_r_r1470, cpy_r_r1471);
    if (unlikely(cpy_r_r1472 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1374, CPyStatic_ops___globals);
        goto CPyL489;
    }
    cpy_r_r1473 = PyObject_SetAttr(cpy_r_r1462, cpy_r_r1464, cpy_r_r1472);
    CPy_DECREF(cpy_r_r1472);
    cpy_r_r1474 = cpy_r_r1473 >= 0;
    if (unlikely(!cpy_r_r1474)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1374, CPyStatic_ops___globals);
        goto CPyL489;
    }
    CPyType_ops___KeepAlive = (PyTypeObject *)cpy_r_r1462;
    CPy_INCREF(CPyType_ops___KeepAlive);
    cpy_r_r1475 = CPyStatic_ops___globals;
    cpy_r_r1476 = CPyStatics[6706]; /* 'KeepAlive' */
    cpy_r_r1477 = CPyDict_SetItem(cpy_r_r1475, cpy_r_r1476, cpy_r_r1462);
    CPy_DECREF(cpy_r_r1462);
    cpy_r_r1478 = cpy_r_r1477 >= 0;
    if (unlikely(!cpy_r_r1478)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1374, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1479 = CPyStatic_ops___globals;
    cpy_r_r1480 = CPyStatics[900]; /* 'Generic' */
    cpy_r_r1481 = CPyDict_GetItem(cpy_r_r1479, cpy_r_r1480);
    if (unlikely(cpy_r_r1481 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1406, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1482 = CPyStatic_ops___globals;
    cpy_r_r1483 = CPyStatics[1088]; /* 'T' */
    cpy_r_r1484 = CPyDict_GetItem(cpy_r_r1482, cpy_r_r1483);
    if (unlikely(cpy_r_r1484 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1406, CPyStatic_ops___globals);
        goto CPyL490;
    }
    cpy_r_r1485 = PyObject_GetItem(cpy_r_r1481, cpy_r_r1484);
    CPy_DECREF(cpy_r_r1481);
    CPy_DECREF(cpy_r_r1484);
    if (unlikely(cpy_r_r1485 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1406, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1486 = PyTuple_Pack(1, cpy_r_r1485);
    CPy_DECREF(cpy_r_r1485);
    if (unlikely(cpy_r_r1486 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1406, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1487 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r1488 = (PyObject *)CPyType_ops___OpVisitor_template;
    cpy_r_r1489 = CPyType_FromTemplate(cpy_r_r1488, cpy_r_r1486, cpy_r_r1487);
    CPy_DECREF(cpy_r_r1486);
    if (unlikely(cpy_r_r1489 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1406, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1490 = CPyStatics[65]; /* '__mypyc_attrs__' */
    cpy_r_r1491 = CPyStatics[663]; /* '__dict__' */
    cpy_r_r1492 = PyTuple_Pack(1, cpy_r_r1491);
    if (unlikely(cpy_r_r1492 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1406, CPyStatic_ops___globals);
        goto CPyL491;
    }
    cpy_r_r1493 = PyObject_SetAttr(cpy_r_r1489, cpy_r_r1490, cpy_r_r1492);
    CPy_DECREF(cpy_r_r1492);
    cpy_r_r1494 = cpy_r_r1493 >= 0;
    if (unlikely(!cpy_r_r1494)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1406, CPyStatic_ops___globals);
        goto CPyL491;
    }
    CPyType_ops___OpVisitor = (PyTypeObject *)cpy_r_r1489;
    CPy_INCREF(CPyType_ops___OpVisitor);
    cpy_r_r1495 = CPyStatic_ops___globals;
    cpy_r_r1496 = CPyStatics[6715]; /* 'OpVisitor' */
    cpy_r_r1497 = CPyDict_SetItem(cpy_r_r1495, cpy_r_r1496, cpy_r_r1489);
    CPy_DECREF(cpy_r_r1489);
    cpy_r_r1498 = cpy_r_r1497 >= 0;
    if (unlikely(!cpy_r_r1498)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1406, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1499 = CPyModule_typing;
    cpy_r_r1500 = (PyObject *)&_Py_NoneStruct;
    cpy_r_r1501 = cpy_r_r1499 != cpy_r_r1500;
    if (cpy_r_r1501) goto CPyL395;
    cpy_r_r1502 = CPyStatics[21]; /* 'typing' */
    cpy_r_r1503 = PyImport_Import(cpy_r_r1502);
    if (unlikely(cpy_r_r1503 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL419;
    }
    CPyModule_typing = cpy_r_r1503;
    CPy_INCREF(CPyModule_typing);
    CPy_DECREF(cpy_r_r1503);
CPyL395: ;
    cpy_r_r1504 = PyImport_GetModuleDict();
    cpy_r_r1505 = CPyStatics[21]; /* 'typing' */
    cpy_r_r1506 = CPyDict_GetItem(cpy_r_r1504, cpy_r_r1505);
    if (unlikely(cpy_r_r1506 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1507 = CPyStatics[612]; /* '_NamedTuple' */
    cpy_r_r1508 = CPyObject_GetAttr(cpy_r_r1506, cpy_r_r1507);
    CPy_DECREF(cpy_r_r1506);
    if (unlikely(cpy_r_r1508 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1509 = PyTuple_Pack(1, cpy_r_r1508);
    CPy_DECREF(cpy_r_r1508);
    if (unlikely(cpy_r_r1509 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1510 = CPyModule_typing;
    cpy_r_r1511 = (PyObject *)&_Py_NoneStruct;
    cpy_r_r1512 = cpy_r_r1510 != cpy_r_r1511;
    if (cpy_r_r1512) goto CPyL401;
    cpy_r_r1513 = CPyStatics[21]; /* 'typing' */
    cpy_r_r1514 = PyImport_Import(cpy_r_r1513);
    if (unlikely(cpy_r_r1514 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL492;
    }
    CPyModule_typing = cpy_r_r1514;
    CPy_INCREF(CPyModule_typing);
    CPy_DECREF(cpy_r_r1514);
CPyL401: ;
    cpy_r_r1515 = PyImport_GetModuleDict();
    cpy_r_r1516 = CPyStatics[21]; /* 'typing' */
    cpy_r_r1517 = CPyDict_GetItem(cpy_r_r1515, cpy_r_r1516);
    if (unlikely(cpy_r_r1517 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL492;
    }
    cpy_r_r1518 = CPyStatics[613]; /* 'NamedTupleMeta' */
    cpy_r_r1519 = CPyObject_GetAttr(cpy_r_r1517, cpy_r_r1518);
    CPy_DECREF(cpy_r_r1517);
    if (unlikely(cpy_r_r1519 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL492;
    }
    cpy_r_r1520 = CPyStatics[614]; /* '__prepare__' */
    cpy_r_r1521 = PyObject_HasAttr(cpy_r_r1519, cpy_r_r1520);
    if (!cpy_r_r1521) goto CPyL408;
    cpy_r_r1522 = CPyStatics[7420]; /* 'DeserMaps' */
    cpy_r_r1523 = CPyStatics[614]; /* '__prepare__' */
    cpy_r_r1524 = CPyObject_GetAttr(cpy_r_r1519, cpy_r_r1523);
    if (unlikely(cpy_r_r1524 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL493;
    }
    PyObject *cpy_r_r1525[2] = {cpy_r_r1522, cpy_r_r1509};
    cpy_r_r1526 = (PyObject **)&cpy_r_r1525;
    cpy_r_r1527 = _PyObject_Vectorcall(cpy_r_r1524, cpy_r_r1526, 2, 0);
    CPy_DECREF(cpy_r_r1524);
    if (unlikely(cpy_r_r1527 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL493;
    }
    if (likely(PyDict_Check(cpy_r_r1527)))
        cpy_r_r1528 = cpy_r_r1527;
    else {
        CPy_TypeErrorTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals, "dict", cpy_r_r1527);
        goto CPyL493;
    }
    cpy_r_r1529 = cpy_r_r1528;
    goto CPyL410;
CPyL408: ;
    cpy_r_r1530 = PyDict_New();
    if (unlikely(cpy_r_r1530 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL493;
    }
    cpy_r_r1529 = cpy_r_r1530;
CPyL410: ;
    cpy_r_r1531 = PyDict_New();
    if (unlikely(cpy_r_r1531 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL494;
    }
    cpy_r_r1532 = (PyObject *)&PyDict_Type;
    cpy_r_r1533 = CPyStatics[4733]; /* 'classes' */
    cpy_r_r1534 = CPyDict_SetItem(cpy_r_r1531, cpy_r_r1533, cpy_r_r1532);
    cpy_r_r1535 = cpy_r_r1534 >= 0;
    if (unlikely(!cpy_r_r1535)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1578, CPyStatic_ops___globals);
        goto CPyL495;
    }
    cpy_r_r1536 = (PyObject *)&PyDict_Type;
    cpy_r_r1537 = CPyStatics[4820]; /* 'functions' */
    cpy_r_r1538 = CPyDict_SetItem(cpy_r_r1531, cpy_r_r1537, cpy_r_r1536);
    cpy_r_r1539 = cpy_r_r1538 >= 0;
    if (unlikely(!cpy_r_r1539)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1579, CPyStatic_ops___globals);
        goto CPyL495;
    }
    cpy_r_r1540 = CPyStatics[7420]; /* 'DeserMaps' */
    cpy_r_r1541 = CPyStatics[616]; /* '__annotations__' */
    cpy_r_r1542 = CPyDict_SetItem(cpy_r_r1529, cpy_r_r1541, cpy_r_r1531);
    CPy_DECREF(cpy_r_r1531);
    cpy_r_r1543 = cpy_r_r1542 >= 0;
    if (unlikely(!cpy_r_r1543)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL494;
    }
    cpy_r_r1544 = CPyStatics[617]; /* 'mypyc filler docstring' */
    cpy_r_r1545 = CPyStatics[618]; /* '__doc__' */
    cpy_r_r1546 = CPyDict_SetItem(cpy_r_r1529, cpy_r_r1545, cpy_r_r1544);
    cpy_r_r1547 = cpy_r_r1546 >= 0;
    if (unlikely(!cpy_r_r1547)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL494;
    }
    cpy_r_r1548 = CPyStatics[6674]; /* 'mypyc.ir.ops' */
    cpy_r_r1549 = CPyStatics[619]; /* '__module__' */
    cpy_r_r1550 = CPyDict_SetItem(cpy_r_r1529, cpy_r_r1549, cpy_r_r1548);
    cpy_r_r1551 = cpy_r_r1550 >= 0;
    if (unlikely(!cpy_r_r1551)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL494;
    }
    PyObject *cpy_r_r1552[3] = {cpy_r_r1540, cpy_r_r1509, cpy_r_r1529};
    cpy_r_r1553 = (PyObject **)&cpy_r_r1552;
    cpy_r_r1554 = _PyObject_Vectorcall(cpy_r_r1519, cpy_r_r1553, 3, 0);
    CPy_DECREF(cpy_r_r1519);
    if (unlikely(cpy_r_r1554 == NULL)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL496;
    }
    CPy_DECREF(cpy_r_r1509);
    CPy_DECREF(cpy_r_r1529);
    CPyType_ops___DeserMaps = (PyTypeObject *)cpy_r_r1554;
    CPy_INCREF(CPyType_ops___DeserMaps);
    cpy_r_r1555 = CPyStatic_ops___globals;
    cpy_r_r1556 = CPyStatics[7420]; /* 'DeserMaps' */
    cpy_r_r1557 = CPyDict_SetItem(cpy_r_r1555, cpy_r_r1556, cpy_r_r1554);
    CPy_DECREF(cpy_r_r1554);
    cpy_r_r1558 = cpy_r_r1557 >= 0;
    if (unlikely(!cpy_r_r1558)) {
        CPy_AddTraceback("mypyc/ir/ops.py", "<module>", 1577, CPyStatic_ops___globals);
        goto CPyL419;
    }
    cpy_r_r1559 = (PyObject *)CPyType_ops___DeserMaps;
    return 1;
CPyL419: ;
    cpy_r_r1560 = 2;
    return cpy_r_r1560;
CPyL420: ;
    CPy_DecRef(cpy_r_r43);
    goto CPyL419;
CPyL421: ;
    CPy_DecRef(cpy_r_r90);
    goto CPyL419;
CPyL422: ;
    CPy_DecRef(cpy_r_r107);
    goto CPyL419;
CPyL423: ;
    CPy_DecRef(cpy_r_r126);
    goto CPyL419;
CPyL424: ;
    CPy_DecRef(cpy_r_r144);
    goto CPyL419;
CPyL425: ;
    CPy_DecRef(cpy_r_r162);
    goto CPyL419;
CPyL426: ;
    CPy_DecRef(cpy_r_r179);
    goto CPyL419;
CPyL427: ;
    CPy_DecRef(cpy_r_r197);
    goto CPyL419;
CPyL428: ;
    CPy_DecRef(cpy_r_r217);
    goto CPyL419;
CPyL429: ;
    CPy_DecRef(cpy_r_r237);
    goto CPyL419;
CPyL430: ;
    CPy_DecRef(cpy_r_r254);
    goto CPyL419;
CPyL431: ;
    CPy_DecRef(cpy_r_r273);
    goto CPyL419;
CPyL432: ;
    CPy_DecRef(cpy_r_r310);
    goto CPyL419;
CPyL433: ;
    CPy_DecRef(cpy_r_r329);
    goto CPyL419;
CPyL434: ;
    CPy_DecRef(cpy_r_r347);
    goto CPyL419;
CPyL435: ;
    CPy_DecRef(cpy_r_r366);
    goto CPyL419;
CPyL436: ;
    CPy_DecRef(cpy_r_r387);
    goto CPyL419;
CPyL437: ;
    CPy_DecRef(cpy_r_r409);
    goto CPyL419;
CPyL438: ;
    CPy_DecRef(cpy_r_r430);
    goto CPyL419;
CPyL439: ;
    CPy_DecRef(cpy_r_r453);
    goto CPyL419;
CPyL440: ;
    CPy_DecRef(cpy_r_r474);
    goto CPyL419;
CPyL441: ;
    CPy_DecRef(cpy_r_r496);
    goto CPyL419;
CPyL442: ;
    CPy_DecRef(cpy_r_r519);
    goto CPyL419;
CPyL443: ;
    CPy_DecRef(cpy_r_r559);
    goto CPyL419;
CPyL444: ;
    CPy_DecRef(cpy_r_r584);
    goto CPyL419;
CPyL445: ;
    CPy_DecRef(cpy_r_r608);
    goto CPyL419;
CPyL446: ;
    CPy_DecRef(cpy_r_r630);
    goto CPyL419;
CPyL447: ;
    CPy_DecRef(cpy_r_r652);
    goto CPyL419;
CPyL448: ;
    CPy_DecRef(cpy_r_r673);
    goto CPyL419;
CPyL449: ;
    CPy_DecRef(cpy_r_r694);
    goto CPyL419;
CPyL450: ;
    CPy_DecRef(cpy_r_r714);
    goto CPyL419;
CPyL451: ;
    CPy_DecRef(cpy_r_r776);
    goto CPyL419;
CPyL452: ;
    CPy_DecRef(cpy_r_r794);
    goto CPyL419;
CPyL453: ;
    CPy_DecRef(cpy_r_r817);
    goto CPyL419;
CPyL454: ;
    CPy_DecRef(cpy_r_r839);
    goto CPyL419;
CPyL455: ;
    CPy_DecRef(cpy_r_r862);
    goto CPyL419;
CPyL456: ;
    CPy_DecRef(cpy_r_r885);
    goto CPyL419;
CPyL457: ;
    CPy_DecRef(cpy_r_r986);
    goto CPyL419;
CPyL458: ;
    CPy_DecRef(cpy_r_r990);
    goto CPyL265;
CPyL459: ;
    CPy_DecRef(cpy_r_r990);
    goto CPyL419;
CPyL460: ;
    CPy_DECREF(cpy_r_r996);
    CPy_DECREF(cpy_r_r997.f2);
    CPy_DECREF(cpy_r_r997.f3);
    goto CPyL273;
CPyL461: ;
    CPy_DecRef(cpy_r_r990);
    CPy_DecRef(cpy_r_r996);
    CPy_DecRef(cpy_r_r1001);
    goto CPyL419;
CPyL462: ;
    CPy_DecRef(cpy_r_r990);
    CPy_DecRef(cpy_r_r996);
    CPyTagged_DecRef(cpy_r_r1002);
    goto CPyL419;
CPyL463: ;
    CPy_DecRef(cpy_r_r990);
    CPy_DecRef(cpy_r_r996);
    goto CPyL419;
CPyL464: ;
    CPy_DecRef(cpy_r_r1017);
    goto CPyL419;
CPyL465: ;
    CPy_DecRef(cpy_r_r1120);
    goto CPyL419;
CPyL466: ;
    CPy_DecRef(cpy_r_r1137);
    goto CPyL419;
CPyL467: ;
    CPy_DecRef(cpy_r_r1154);
    goto CPyL419;
CPyL468: ;
    CPy_DecRef(cpy_r_r1162);
    goto CPyL419;
CPyL469: ;
    CPy_DecRef(cpy_r_r1223);
    goto CPyL419;
CPyL470: ;
    CPy_DecRef(cpy_r_r1227);
    goto CPyL312;
CPyL471: ;
    CPy_DecRef(cpy_r_r1227);
    goto CPyL419;
CPyL472: ;
    CPy_DECREF(cpy_r_r1233);
    CPy_DECREF(cpy_r_r1234.f2);
    CPy_DECREF(cpy_r_r1234.f3);
    goto CPyL320;
CPyL473: ;
    CPy_DecRef(cpy_r_r1227);
    CPy_DecRef(cpy_r_r1233);
    CPy_DecRef(cpy_r_r1238);
    goto CPyL419;
CPyL474: ;
    CPy_DecRef(cpy_r_r1227);
    CPy_DecRef(cpy_r_r1233);
    CPyTagged_DecRef(cpy_r_r1239);
    goto CPyL419;
CPyL475: ;
    CPy_DecRef(cpy_r_r1227);
    CPy_DecRef(cpy_r_r1233);
    goto CPyL419;
CPyL476: ;
    CPy_DecRef(cpy_r_r1254);
    goto CPyL419;
CPyL477: ;
    CPy_DecRef(cpy_r_r1275);
    goto CPyL419;
CPyL478: ;
    CPy_DecRef(cpy_r_r1344);
    goto CPyL419;
CPyL479: ;
    CPy_DecRef(cpy_r_r1348);
    goto CPyL344;
CPyL480: ;
    CPy_DecRef(cpy_r_r1348);
    goto CPyL419;
CPyL481: ;
    CPy_DECREF(cpy_r_r1354);
    CPy_DECREF(cpy_r_r1355.f2);
    CPy_DECREF(cpy_r_r1355.f3);
    goto CPyL352;
CPyL482: ;
    CPy_DecRef(cpy_r_r1348);
    CPy_DecRef(cpy_r_r1354);
    CPy_DecRef(cpy_r_r1359);
    goto CPyL419;
CPyL483: ;
    CPy_DecRef(cpy_r_r1348);
    CPy_DecRef(cpy_r_r1354);
    CPyTagged_DecRef(cpy_r_r1360);
    goto CPyL419;
CPyL484: ;
    CPy_DecRef(cpy_r_r1348);
    CPy_DecRef(cpy_r_r1354);
    goto CPyL419;
CPyL485: ;
    CPy_DecRef(cpy_r_r1375);
    goto CPyL419;
CPyL486: ;
    CPy_DecRef(cpy_r_r1396);
    goto CPyL419;
CPyL487: ;
    CPy_DecRef(cpy_r_r1417);
    goto CPyL419;
CPyL488: ;
    CPy_DecRef(cpy_r_r1440);
    goto CPyL419;
CPyL489: ;
    CPy_DecRef(cpy_r_r1462);
    goto CPyL419;
CPyL490: ;
    CPy_DecRef(cpy_r_r1481);
    goto CPyL419;
CPyL491: ;
    CPy_DecRef(cpy_r_r1489);
    goto CPyL419;
CPyL492: ;
    CPy_DecRef(cpy_r_r1509);
    goto CPyL419;
CPyL493: ;
    CPy_DecRef(cpy_r_r1509);
    CPy_DecRef(cpy_r_r1519);
    goto CPyL419;
CPyL494: ;
    CPy_DecRef(cpy_r_r1509);
    CPy_DecRef(cpy_r_r1519);
    CPy_DecRef(cpy_r_r1529);
    goto CPyL419;
CPyL495: ;
    CPy_DecRef(cpy_r_r1509);
    CPy_DecRef(cpy_r_r1519);
    CPy_DecRef(cpy_r_r1529);
    CPy_DecRef(cpy_r_r1531);
    goto CPyL419;
CPyL496: ;
    CPy_DecRef(cpy_r_r1509);
    CPy_DecRef(cpy_r_r1529);
    goto CPyL419;
}
